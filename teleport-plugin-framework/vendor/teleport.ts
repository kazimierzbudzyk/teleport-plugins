namespace __proto {
    /**
     * Decoder implements protobuf message decode interface.
     *
     * Useful references:
     *
     * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
     * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
     * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
     */
    export class Decoder {
        public view: DataView;
        public pos: i32;

        constructor(view: DataView) {
            this.view = view;
            this.pos = 0;
        }

        /**
         * Returns true if current reader has reached the buffer end
         * @returns True if current reader has reached the buffer end
         */
        @inline
        eof(): bool {
            return this.pos >= this.view.byteLength;
        }

        /**
         * Returns current buffer length in bytes
         * @returns Length in bytes
         */
        @inline
        get byteLength(): i32 {
            return this.view.byteLength;
        }

        /**
         * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].
         * TODO: Replace with return tuple when tuples become implemented in AS.
         * @returns Message tag value
         */
        @inline
        tag(): u32 {
            return this.uint32();
        }

        /**
         * Returns byte at offset, alias for getUint8
         * @param byteOffset Offset
         * @returns u8
         */
        @inline
        private u8at(byteOffset: i32): u8 {
            return this.view.getUint8(byteOffset);
        }

        /**
         * Reads and returns varint number (128 + 10 bits max) from a current position.
         * @returns Returns varint
         */
        varint(): u64 {
            let value: u64;

            // u32
            value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u32 remainder or u64 byte
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u64
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value |
                    ((u64(u8(this.u8at(this.pos))) & 127) <<
                        42)) /* 42!!! */ >>>
                0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u64 remainder
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;

            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            return value;
        }

        @inline
        int32(): i32 {
            return i32(this.varint());
        }

        @inline
        int64(): i64 {
            return i32(this.varint());
        }

        @inline
        uint32(): u32 {
            return u32(this.varint());
        }

        @inline
        uint64(): u64 {
            return u64(this.varint());
        }

        @inline
        sint32(): i32 {
            const n: u64 = this.varint();
            return i32((n >>> 1) ^ -(n & 1));
        }

        @inline
        sint64(): i64 {
            const n: u64 = this.varint();
            return i64((n >>> 1) ^ -(n & 1));
        }

        fixed32(): u32 {
            this.pos += 4;
            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)
            return (
                u32(u8(this.u8at(this.pos - 4))) |
                (u32(u8(this.u8at(this.pos - 3))) << 8) |
                (u32(u8(this.u8at(this.pos - 2))) << 16) |
                (u32(u8(this.u8at(this.pos - 1))) << 24)
            );
        }

        @inline
        sfixed32(): i32 {
            return i32(this.fixed32());
        }

        fixed64(): u64 {
            this.pos += 8;
            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            return (
                u64(u8(this.u8at(this.pos - 8))) |
                (u64(u8(this.u8at(this.pos - 7))) << 8) |
                (u64(u8(this.u8at(this.pos - 6))) << 16) |
                (u64(u8(this.u8at(this.pos - 5))) << 24) |
                (u64(u8(this.u8at(this.pos - 4))) << 32) |
                (u64(u8(this.u8at(this.pos - 3))) << 40) |
                (u64(u8(this.u8at(this.pos - 2))) << 48) |
                (u64(u8(this.u8at(this.pos - 1))) << 56)
            );
        }

        @inline
        sfixed64(): i64 {
            return i64(this.fixed64());
        }

        @inline
        float(): f32 {
            return f32.reinterpret_i32(this.fixed32());
        }

        @inline
        double(): f64 {
            return f64.reinterpret_i64(this.fixed64());
        }

        @inline
        bool(): boolean {
            return this.uint32() > 0;
        }

        /**
         * Reads and returns UTF8 string.
         * @returns String
         */
        string(): string {
            const length = this.uint32();
            if (this.pos + length > this.byteLength) {
                this.throwOutOfRange();
            }

            const p = this.pos + this.view.byteOffset;
            const value = String.UTF8.decode(
                this.view.buffer.slice(p, p + length)
            );
            this.pos += length;
            return value;
        }

        /**
         * Reads and returns bytes array.
         * @returns Array<u8> of bytes
         */
        bytes(): Array<u8> {
            const len = this.uint32();
            if (this.pos + len > this.byteLength) {
                this.throwOutOfRange();
            }

            const a = new Array<u8>(len);
            for (let i: u32 = 0; i < len; i++) {
                a[i] = u8(this.u8at(this.pos++));
            }

            return a;
        }

        /**
         * Skips a message field if it can'be recognized by an object's decode() method
         * @param wireType Current wire type
         */
        skipType(wireType: u32): void {
            switch (wireType) {
                // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length
                case 0:
                    this.varint(); // Just read a varint
                    break;
                // fixed64, sfixed64, double: 8 bytes always
                case 1:
                    this.skip(8);
                    break;
                // length-delimited; length is determined by varint32; skip length bytes;
                case 2:
                    this.skip(this.uint32());
                    break;
                // tart group: skip till the end of the group, then skip group end marker
                case 3:
                    while ((wireType = this.uint32() & 7) !== 4) {
                        this.skipType(wireType);
                    }
                    break;
                // fixed32, sfixed32, float: 4 bytes always
                case 5:
                    this.skip(4);
                    break;

                // Something went beyond our capability to understand
                default:
                    throw new Error(
                        `Invalid wire type ${wireType} at offset ${this.pos}`
                    );
            }
        }

        /**
         * Fast-forwards cursor by length with boundary check
         * @param length Byte length
         */
        skip(length: u32): void {
            if (this.pos + length > this.byteLength) {
                this.throwOutOfRange();
            }
            this.pos += length;
        }

        /**
         * OutOfRange check. Throws an exception if current position exceeds current buffer range
         */
        @inline
        private throwOutOfRange(): void {
            throw new Error(`Decoder position ${this.pos} is out of range!`);
        }
    }

    /**
     * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses
     * Array<u8>.
     *
     * Useful references:
     *
     * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
     * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
     * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
     */
    export class Encoder {
        public buf: Array<u8>;

        constructor(buf: Array<u8>) {
            this.buf = buf;
        }

        /**
         * Encodes varint at a current position
         * @returns Returns varint
         */
        varint64(value: u64): void {
            let v: u64 = value;

            while (v > 127) {
                this.buf.push(u8((v & 127) | 128));
                v = v >> 7;
            }

            this.buf.push(u8(v));
        }

        @inline
        int32(value: i32): void {
            this.varint64(value);
        }

        @inline
        int64(value: i64): void {
            this.varint64(value);
        }

        @inline
        uint32(value: u32): void {
            this.varint64(value);
        }

        @inline
        uint64(value: u64): void {
            this.varint64(value);
        }

        @inline
        sint32(value: i32): void {
            this.varint64((value << 1) ^ (value >> 31));
        }

        @inline
        sint64(value: i64): void {
            this.varint64((value << 1) ^ (value >> 63));
        }

        @inline
        fixed32(value: u32): void {
            this.buf.push(u8(value & 255));
            this.buf.push(u8((value >> 8) & 255));
            this.buf.push(u8((value >> 16) & 255));
            this.buf.push(u8(value >> 24));
        }

        @inline
        sfixed32(value: i32): void {
            this.fixed32(u32(value));
        }

        @inline
        fixed64(value: u64): void {
            this.buf.push(u8(value & 255));
            this.buf.push(u8((value >> 8) & 255));
            this.buf.push(u8((value >> 16) & 255));
            this.buf.push(u8((value >> 24) & 255));
            this.buf.push(u8((value >> 32) & 255));
            this.buf.push(u8((value >> 40) & 255));
            this.buf.push(u8((value >> 48) & 255));
            this.buf.push(u8(value >> 56));
        }

        @inline
        sfixed64(value: i64): void {
            this.fixed64(u64(value));
        }

        @inline
        float(value: f32): void {
            this.fixed32(u32(i32.reinterpret_f32(value)));
        }

        @inline
        double(value: f64): void {
            this.fixed64(u64(i64.reinterpret_f64(value)));
        }

        @inline
        bool(value: boolean): void {
            this.buf.push(value ? 1 : 0);
        }

        string(value: string): void {
            const utf8string = new DataView(String.UTF8.encode(value));

            for (let i = 0; i < utf8string.byteLength; i++) {
                this.buf.push(utf8string.getUint8(i));
            }
        }

        @inline
        bytes(value: Array<u8>): void {
            for (let i = 0; i < value.length; i++) {
                this.buf.push(value[i]);
            }
        }
    }

    /**
     * Returns byte size required to encode a value of a certain type
     */
    export class Sizer {
        static varint64(value: u64): u32 {
            return value < 128
                ? 1 // 2^7
                : value < 16384
                ? 2 // 2^14
                : value < 2097152
                ? 3 // 2^21
                : value < 268435456
                ? 4 // 2^28
                : value < 34359738368
                ? 5 // 2^35
                : value < 4398046511104
                ? 6 // 2^42
                : value < 562949953421312
                ? 7 // 2^49
                : value < 72057594037927936
                ? 8 // 2^56
                : value < 9223372036854775808
                ? 9 // 2^63
                : 10;
        }

        @inline
        static int32(value: i32): u32 {
            return Sizer.varint64(u64(value));
        }

        @inline
        static int64(value: i64): u32 {
            return Sizer.varint64(u64(value));
        }

        @inline
        static uint32(value: u32): u32 {
            return Sizer.varint64(value);
        }

        @inline
        static uint64(value: u64): u32 {
            return Sizer.varint64(value);
        }

        @inline
        static sint32(value: i32): u32 {
            return Sizer.varint64((value << 1) ^ (value >> 31));
        }

        @inline
        static sint64(value: i64): u32 {
            return Sizer.varint64((value << 1) ^ (value >> 63));
        }

        @inline
        static string(value: string): u32 {
            return value.length;
        }

        @inline
        static bytes(value: Array<u8>): u32 {
            return value.length;
        }
    }
}
/**
 * Allocates and returns the DataView for a protobuf binary message.
 * @param length Message size
 * @returns (DataView addr << 32) | Buffer addr
 */
export function __protobuf_alloc(length: i32): u64 {
    const view = new DataView(new ArrayBuffer(length));
    return (
        (u64(changetype<usize>(view)) << 32) |
        (changetype<usize>(view.buffer) + view.byteOffset)
    );
}

/**
 * Returns the length of the DataView.
 * @param data DataView instance
 * @returns Length
 */
export function __protobuf_getLength(view: DataView): u32 {
    return view.byteLength;
}

/**
 * Returns address of the DataView, accessible via WASM memory.
 *
 * @param data DataView instance
 * @returns Memory address
 */
export function __protobuf_getAddr(view: DataView): usize {
    return changetype<usize>(view.buffer) + view.byteOffset;
}

export namespace google {
    export namespace protobuf {
        /**
         * A Timestamp represents a point in time independent of any time zone or local
         *  calendar, encoded as a count of seconds and fractions of seconds at
         *  nanosecond resolution. The count is relative to an epoch at UTC midnight on
         *  January 1, 1970, in the proleptic Gregorian calendar which extends the
         *  Gregorian calendar backwards to year one.
         *
         *  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
         *  second table is needed for interpretation, using a [24-hour linear
         *  smear](https://developers.google.com/time/smear).
         *
         *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
         *  restricting to that range, we ensure that we can convert to and from [RFC
         *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
         *
         *  # Examples
         *
         *  Example 1: Compute Timestamp from POSIX `time()`.
         *
         *      Timestamp timestamp;
         *      timestamp.set_seconds(time(NULL));
         *      timestamp.set_nanos(0);
         *
         *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
         *
         *      struct timeval tv;
         *      gettimeofday(&tv, NULL);
         *
         *      Timestamp timestamp;
         *      timestamp.set_seconds(tv.tv_sec);
         *      timestamp.set_nanos(tv.tv_usec * 1000);
         *
         *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
         *
         *      FILETIME ft;
         *      GetSystemTimeAsFileTime(&ft);
         *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
         *
         *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
         *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
         *      Timestamp timestamp;
         *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
         *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
         *
         *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
         *
         *      long millis = System.currentTimeMillis();
         *
         *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
         *          .setNanos((int) ((millis % 1000) * 1000000)).build();
         *
         *
         *  Example 5: Compute Timestamp from Java `Instant.now()`.
         *
         *      Instant now = Instant.now();
         *
         *      Timestamp timestamp =
         *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
         *              .setNanos(now.getNano()).build();
         *
         *
         *  Example 6: Compute Timestamp from current time in Python.
         *
         *      timestamp = Timestamp()
         *      timestamp.GetCurrentTime()
         *
         *  # JSON Mapping
         *
         *  In JSON format, the Timestamp type is encoded as a string in the
         *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
         *  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
         *  where {year} is always expressed using four digits while {month}, {day},
         *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
         *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
         *  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
         *  is required. A proto3 JSON serializer should always use UTC (as indicated by
         *  "Z") when printing the Timestamp type and a proto3 JSON parser should be
         *  able to accept both UTC and other timezones (as indicated by an offset).
         *
         *  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
         *  01:30 UTC on January 15, 2017.
         *
         *  In JavaScript, one can convert a Date object to this format using the
         *  standard
         *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
         *  method. In Python, a standard `datetime.datetime` object can be converted
         *  to this format using
         *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
         *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
         *  the Joda Time's [`ISODateTimeFormat.dateTime()`](
         *  http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
         *  ) to obtain a formatter capable of generating timestamps in this format.
         */
        export class Timestamp {
            /**
             * Represents seconds of UTC time since Unix epoch
             *  1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
             *  9999-12-31T23:59:59Z inclusive.
             */
            public seconds: i64;
            /**
             * Non-negative fractions of a second at nanosecond resolution. Negative
             *  second values with fractions must still have non-negative nanos values
             *  that count forward in time. Must be from 0 to 999,999,999
             *  inclusive.
             */
            public nanos: i32;

            // Decodes Timestamp from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Timestamp {
                return Timestamp.decode(new DataView(buf));
            }

            // Decodes Timestamp from a DataView
            static decode(view: DataView): Timestamp {
                const decoder = new __proto.Decoder(view);
                const obj = new Timestamp();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            obj.seconds = decoder.int64();
                            break;
                        }
                        case 2: {
                            obj.nanos = decoder.int32();
                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Timestamp

            public size(): u32 {
                let size: u32 = 0;

                size +=
                    this.seconds == 0
                        ? 0
                        : 1 + __proto.Sizer.int64(this.seconds);
                size +=
                    this.nanos == 0 ? 0 : 1 + __proto.Sizer.int32(this.nanos);

                return size;
            }

            // Encodes Timestamp to the DataView
            encode(): DataView {
                const source = this.encodeU8Array();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Timestamp to the Array<u8>
            encodeU8Array(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.seconds != 0) {
                    encoder.uint32(0x8);
                    encoder.int64(this.seconds);
                }
                if (this.nanos != 0) {
                    encoder.uint32(0x10);
                    encoder.int32(this.nanos);
                }

                return buf;
            } // encode Timestamp
        } // Timestamp

        /**
         * `NullValue` is a singleton enumeration to represent the null value for the
         *  `Value` type union.
         *
         *   The JSON representation for `NullValue` is JSON `null`.
         */
        export enum NullValue {
            // Null value.
            NULL_VALUE = 0,
        } // NullValue
        /**
         * `Struct` represents a structured data value, consisting of fields
         *  which map to dynamically typed values. In some languages, `Struct`
         *  might be supported by a native representation. For example, in
         *  scripting languages like JS a struct is represented as an
         *  object. The details of that representation are described together
         *  with the proto support for the language.
         *
         *  The JSON representation for `Struct` is JSON object.
         */
        export class Struct {
            // Unordered map of dynamically typed values.
            public fields: Map<string, google.protobuf.Value> = new Map<
                string,
                google.protobuf.Value
            >();

            // Decodes Struct from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Struct {
                return Struct.decode(new DataView(buf));
            }

            // Decodes Struct from a DataView
            static decode(view: DataView): Struct {
                const decoder = new __proto.Decoder(view);
                const obj = new Struct();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            const length = decoder.uint32();
                            __decodeMap_string_google_protobuf_Value(
                                decoder,
                                length,
                                obj.fields
                            );
                            decoder.skip(length);

                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Struct

            public size(): u32 {
                let size: u32 = 0;

                if (this.fields.size > 0) {
                    const keys = this.fields.keys();

                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = this.fields.get(key);
                        const itemSize =
                            __sizeMapEntry_string_google_protobuf_Value(
                                key,
                                value
                            );
                        if (itemSize > 0) {
                            size +=
                                1 + __proto.Sizer.varint64(itemSize) + itemSize;
                        }
                    }
                }

                return size;
            }

            // Encodes Struct to the DataView
            encode(): DataView {
                const source = this.encodeU8Array();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Struct to the Array<u8>
            encodeU8Array(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.fields.size > 0) {
                    const keys = this.fields.keys();
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = this.fields.get(key);
                        const size =
                            __sizeMapEntry_string_google_protobuf_Value(
                                key,
                                value
                            );
                        if (size > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(size);
                            if (key.length > 0) {
                                encoder.uint32(0xa);
                                encoder.uint32(key.length);
                                encoder.string(key);
                            }

                            const messageSize = value.size();

                            if (messageSize > 0) {
                                encoder.uint32(0x12);
                                encoder.uint32(messageSize);
                                value.encodeU8Array(encoder);
                            }
                        }
                    }
                }

                return buf;
            } // encode Struct
        } // Struct

        /**
         * `Value` represents a dynamically typed value which can be either
         *  null, a number, a string, a boolean, a recursive struct value, or a
         *  list of values. A producer of value is expected to set one of that
         *  variants, absence of any variant indicates an error.
         *
         *  The JSON representation for `Value` is JSON value.
         */
        export class Value {
            public __oneOf_kind: string = "";
            // Represents a null value.
            public null_value: u32;
            // Represents a double value.
            public number_value: f64;
            // Represents a string value.
            public string_value: string = "";
            // Represents a boolean value.
            public bool_value: bool;
            // Represents a structured value.
            public struct_value: google.protobuf.Struct | null;
            // Represents a repeated `Value`.
            public list_value: google.protobuf.ListValue | null;

            // Decodes Value from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Value {
                return Value.decode(new DataView(buf));
            }

            // Decodes Value from a DataView
            static decode(view: DataView): Value {
                const decoder = new __proto.Decoder(view);
                const obj = new Value();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            obj.null_value = decoder.uint32();
                            obj.__oneOf_kind = "null_value";
                            break;
                        }
                        case 2: {
                            obj.number_value = decoder.double();
                            obj.__oneOf_kind = "number_value";
                            break;
                        }
                        case 3: {
                            obj.string_value = decoder.string();
                            obj.__oneOf_kind = "string_value";
                            break;
                        }
                        case 4: {
                            obj.bool_value = decoder.bool();
                            obj.__oneOf_kind = "bool_value";
                            break;
                        }
                        case 5: {
                            const length = decoder.uint32();
                            obj.struct_value = google.protobuf.Struct.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                            decoder.skip(length);

                            obj.__oneOf_kind = "struct_value";
                            break;
                        }
                        case 6: {
                            const length = decoder.uint32();
                            obj.list_value = google.protobuf.ListValue.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                            decoder.skip(length);

                            obj.__oneOf_kind = "list_value";
                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Value

            public size(): u32 {
                let size: u32 = 0;

                size +=
                    this.null_value == 0
                        ? 0
                        : 1 + __proto.Sizer.uint32(this.null_value);
                size += this.number_value == 0 ? 0 : 1 + 8;
                size +=
                    this.string_value.length > 0
                        ? 1 +
                          __proto.Sizer.varint64(this.string_value.length) +
                          this.string_value.length
                        : 0;
                size += this.bool_value == 0 ? 0 : 1 + 1;

                if (this.struct_value != null) {
                    const f: google.protobuf.Struct = this
                        .struct_value as google.protobuf.Struct;
                    const messageSize = f.size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                if (this.list_value != null) {
                    const f: google.protobuf.ListValue = this
                        .list_value as google.protobuf.ListValue;
                    const messageSize = f.size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                return size;
            }

            // Encodes Value to the DataView
            encode(): DataView {
                const source = this.encodeU8Array();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Value to the Array<u8>
            encodeU8Array(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.null_value != 0) {
                    encoder.uint32(0x8);
                    encoder.uint32(this.null_value);
                }
                if (this.number_value != 0) {
                    encoder.uint32(0x11);
                    encoder.double(this.number_value);
                }
                if (this.string_value.length > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.string_value.length);
                    encoder.string(this.string_value);
                }
                if (this.bool_value != 0) {
                    encoder.uint32(0x20);
                    encoder.bool(this.bool_value);
                }

                if (this.struct_value != null) {
                    const f = this.struct_value as google.protobuf.Struct;

                    const messageSize = f.size();

                    if (messageSize > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(messageSize);
                        f.encodeU8Array(encoder);
                    }
                }

                if (this.list_value != null) {
                    const f = this.list_value as google.protobuf.ListValue;

                    const messageSize = f.size();

                    if (messageSize > 0) {
                        encoder.uint32(0x32);
                        encoder.uint32(messageSize);
                        f.encodeU8Array(encoder);
                    }
                }

                return buf;
            } // encode Value
        } // Value

        /**
         * `ListValue` is a wrapper around a repeated field of values.
         *
         *  The JSON representation for `ListValue` is JSON array.
         */
        export class ListValue {
            // Repeated field of dynamically typed values.
            public values: Array<google.protobuf.Value> =
                new Array<google.protobuf.Value>();

            // Decodes ListValue from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): ListValue {
                return ListValue.decode(new DataView(buf));
            }

            // Decodes ListValue from a DataView
            static decode(view: DataView): ListValue {
                const decoder = new __proto.Decoder(view);
                const obj = new ListValue();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            const length = decoder.uint32();
                            obj.values.push(
                                google.protobuf.Value.decode(
                                    new DataView(
                                        decoder.view.buffer,
                                        decoder.pos + decoder.view.byteOffset,
                                        length
                                    )
                                )
                            );
                            decoder.skip(length);

                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode ListValue

            public size(): u32 {
                let size: u32 = 0;

                for (let n: i32 = 0; n < this.values.length; n++) {
                    const messageSize = this.values[n].size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                return size;
            }

            // Encodes ListValue to the DataView
            encode(): DataView {
                const source = this.encodeU8Array();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes ListValue to the Array<u8>
            encodeU8Array(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                for (let n: i32 = 0; n < this.values.length; n++) {
                    const messageSize = this.values[n].size();

                    if (messageSize > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(messageSize);
                        this.values[n].encodeU8Array(encoder);
                    }
                }

                return buf;
            } // encode ListValue
        } // ListValue
    } // protobuf
} // google
export namespace wrappers {
    // StringValues is a list of strings.
    export class StringValues {
        public Values: Array<string> = new Array<string>();

        // Decodes StringValues from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StringValues {
            return StringValues.decode(new DataView(buf));
        }

        // Decodes StringValues from a DataView
        static decode(view: DataView): StringValues {
            const decoder = new __proto.Decoder(view);
            const obj = new StringValues();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Values.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StringValues

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Values);

            return size;
        }

        // Encodes StringValues to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StringValues to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Values.length > 0) {
                for (let n: i32 = 0; n < this.Values.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Values[n].length);
                    encoder.string(this.Values[n]);
                }
            }

            return buf;
        } // encode StringValues
    } // StringValues

    /**
     * LabelValues is a list of key value pairs, where key is a string
     *  and value is a list of string values.
     */
    export class LabelValues {
        // Values contains key value pairs.
        public Values: Map<string, wrappers.StringValues> = new Map<
            string,
            wrappers.StringValues
        >();

        // Decodes LabelValues from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LabelValues {
            return LabelValues.decode(new DataView(buf));
        }

        // Decodes LabelValues from a DataView
        static decode(view: DataView): LabelValues {
            const decoder = new __proto.Decoder(view);
            const obj = new LabelValues();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_wrappers_StringValues(
                            decoder,
                            length,
                            obj.Values
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LabelValues

        public size(): u32 {
            let size: u32 = 0;

            if (this.Values.size > 0) {
                const keys = this.Values.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Values.get(key);
                    const itemSize =
                        __sizeMapEntry_string_wrappers_StringValues(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes LabelValues to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LabelValues to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Values.size > 0) {
                const keys = this.Values.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Values.get(key);
                    const size = __sizeMapEntry_string_wrappers_StringValues(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode LabelValues
    } // LabelValues
} // wrappers
export namespace types {
    /**
     * DatabaseTLSMode represents the level of TLS verification performed by
     *  DB agent when connecting to a database.
     */
    export enum DatabaseTLSMode {
        // VERIFY_FULL performs full certificate validation.
        VERIFY_FULL = 0,
        // VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
        VERIFY_CA = 1,
        // INSECURE accepts any certificate provided by server. This is the least secure option.
        INSECURE = 2,
    } // DatabaseTLSMode
    // PrivateKeyType is the storage type of a private key.
    export enum PrivateKeyType {
        // RAW is a plaintext private key.
        RAW = 0,
        // PKCS11 is a private key backed by a PKCS11 device such as HSM.
        PKCS11 = 1,
    } // PrivateKeyType
    // ProxyListenerMode represents the cluster proxy listener mode.
    export enum ProxyListenerMode {
        /**
         * Separate is the proxy listener mode indicating that proxies are running
         *  in separate listener mode where Teleport Proxy services use different listeners.
         */
        Separate = 0,
        /**
         * Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
         *  where all proxy services are multiplexed on a single proxy port.
         */
        Multiplex = 1,
    } // ProxyListenerMode
    // RoutingStrategy determines the strategy used to route to nodes.
    export enum RoutingStrategy {
        // UnambiguousMatch only routes to distinct nodes.
        UNAMBIGUOUS_MATCH = 0,
        // MostRecent routes to the most recently heartbeated node if duplicates are present.
        MOST_RECENT = 1,
    } // RoutingStrategy
    // UserTokenUsage contains additional information about the intended usage of a user token.
    export enum UserTokenUsage {
        // Default value that implies token usage was not set.
        USER_TOKEN_USAGE_UNSPECIFIED = 0,
        // USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
        USER_TOKEN_RECOVER_PASSWORD = 1,
        // USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
        USER_TOKEN_RECOVER_MFA = 2,
    } // UserTokenUsage
    // RequestState represents the state of a request for escalated privilege.
    export enum RequestState {
        /**
         * NONE variant exists to allow RequestState to be explicitly omitted
         *  in certain circumstances (e.g. in an AccessRequestFilter).
         */
        NONE = 0,
        // PENDING variant is the default for newly created requests.
        PENDING = 1,
        /**
         * APPROVED variant indicates that a request has been accepted by
         *  an administrating party.
         */
        APPROVED = 2,
        /**
         * DENIED variant indicates that a request has been rejected by
         *  an administrating party.
         */
        DENIED = 3,
    } // RequestState
    export class KeepAlive {
        // Name of the resource to keep alive.
        public Name: string = "";
        // Namespace is the namespace of the resource.
        public Namespace: string = "";
        // LeaseID is ID of the lease.
        public LeaseID: i64;
        // Expires is set to update expiry time of the resource.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Type: u32;
        // HostID is an optional UUID of the host the resource belongs to.
        public HostID: string = "";

        // Decodes KeepAlive from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KeepAlive {
            return KeepAlive.decode(new DataView(buf));
        }

        // Decodes KeepAlive from a DataView
        static decode(view: DataView): KeepAlive {
            const decoder = new __proto.Decoder(view);
            const obj = new KeepAlive();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.LeaseID = decoder.int64();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.Type = decoder.uint32();
                        break;
                    }
                    case 10: {
                        obj.HostID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KeepAlive

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;
            size +=
                this.LeaseID == 0 ? 0 : 1 + __proto.Sizer.int64(this.LeaseID);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.Type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Type);
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            return size;
        }

        // Encodes KeepAlive to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KeepAlive to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }
            if (this.LeaseID != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Type != 0) {
                encoder.uint32(0x48);
                encoder.uint32(this.Type);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            return buf;
        } // encode KeepAlive
    } // KeepAlive

    /**
     * Type is the type of keep alive, used by servers. At the moment only
     *  "node", "app" and "database" are supported.
     */
    export enum KeepAlive_KeepAliveType {
        UNKNOWN = 0,
        NODE = 1,
        APP = 2,
        DATABASE = 3,
        WINDOWS_DESKTOP = 4,
    } // KeepAlive_KeepAliveType
    // ServerSpecV2 is a specification for V2 Server
    export class Metadata {
        // Name is an object name
        public Name: string = "";
        /**
         * Namespace is object namespace. The field should be called "namespace"
         *  when it returns in Teleport 2.4.
         */
        public Namespace: string = "";
        // Description is object description
        public Description: string = "";
        // Labels is a set of labels
        public Labels: Map<string, string> = new Map<string, string>();
        /**
         * Expires is a global expiry time header can be set on any resource in the
         *  system.
         */
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // ID is a record ID
        public ID: i64;

        // Decodes Metadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Metadata {
            return Metadata.decode(new DataView(buf));
        }

        // Decodes Metadata from a DataView
        static decode(view: DataView): Metadata {
            const decoder = new __proto.Decoder(view);
            const obj = new Metadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Description = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Labels);
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.ID = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Metadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;
            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;

            if (this.Labels.size > 0) {
                const keys = this.Labels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Labels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.ID == 0 ? 0 : 1 + __proto.Sizer.int64(this.ID);

            return size;
        }

        // Encodes Metadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Metadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }
            if (this.Description.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }

            if (this.Labels.size > 0) {
                const keys = this.Labels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Labels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ID != 0) {
                encoder.uint32(0x38);
                encoder.int64(this.ID);
            }

            return buf;
        } // encode Metadata
    } // Metadata

    // SSHKeyPair is an SSH CA key pair.
    export class Rotation {
        // State could be one of "init" or "in_progress".
        public State: string = "";
        // Phase is the current rotation phase.
        public Phase: string = "";
        // Mode sets manual or automatic rotation mode.
        public Mode: string = "";
        /**
         * CurrentID is the ID of the rotation operation
         *  to differentiate between rotation attempts.
         */
        public CurrentID: string = "";
        /**
         * Started is set to the time when rotation has been started
         *  in case if the state of the rotation is "in_progress".
         */
        public Started: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * GracePeriod is a period during which old and new CA
         *  are valid for checking purposes, but only new CA is issuing certificates.
         */
        public GracePeriod: i64;
        // LastRotated specifies the last time of the completed rotation.
        public LastRotated: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * Schedule is a rotation schedule - used in
         *  automatic mode to switch beetween phases.
         */
        public Schedule: types.RotationSchedule = new types.RotationSchedule();

        // Decodes Rotation from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rotation {
            return Rotation.decode(new DataView(buf));
        }

        // Decodes Rotation from a DataView
        static decode(view: DataView): Rotation {
            const decoder = new __proto.Decoder(view);
            const obj = new Rotation();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.State = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Phase = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Mode = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.CurrentID = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Started = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.GracePeriod = decoder.int64();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.LastRotated = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.Schedule = types.RotationSchedule.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rotation

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.State.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.State.length) +
                      this.State.length
                    : 0;
            size +=
                this.Phase.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Phase.length) +
                      this.Phase.length
                    : 0;
            size +=
                this.Mode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Mode.length) +
                      this.Mode.length
                    : 0;
            size +=
                this.CurrentID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CurrentID.length) +
                      this.CurrentID.length
                    : 0;

            if (this.Started != null) {
                const f: google.protobuf.Timestamp = this
                    .Started as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.GracePeriod == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.GracePeriod);

            if (this.LastRotated != null) {
                const f: google.protobuf.Timestamp = this
                    .LastRotated as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Schedule != null) {
                const f: types.RotationSchedule = this
                    .Schedule as types.RotationSchedule;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Rotation to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rotation to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.State.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.State.length);
                encoder.string(this.State);
            }
            if (this.Phase.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Phase.length);
                encoder.string(this.Phase);
            }
            if (this.Mode.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Mode.length);
                encoder.string(this.Mode);
            }
            if (this.CurrentID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CurrentID.length);
                encoder.string(this.CurrentID);
            }

            if (this.Started != null) {
                const f = this.Started as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.GracePeriod != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.GracePeriod);
            }

            if (this.LastRotated != null) {
                const f = this.LastRotated as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Schedule != null) {
                const f = this.Schedule as types.RotationSchedule;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode Rotation
    } // Rotation

    /**
     * TokenRule is a rule that a joining node must match in order to use the
     *  associated token.
     */
    export class RotationSchedule {
        // UpdateClients specifies time to switch to the "Update clients" phase
        public UpdateClients: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // UpdateServers specifies time to switch to the "Update servers" phase.
        public UpdateServers: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Standby specifies time to switch to the "Standby" phase.
        public Standby: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RotationSchedule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RotationSchedule {
            return RotationSchedule.decode(new DataView(buf));
        }

        // Decodes RotationSchedule from a DataView
        static decode(view: DataView): RotationSchedule {
            const decoder = new __proto.Decoder(view);
            const obj = new RotationSchedule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.UpdateClients = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.UpdateServers = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Standby = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RotationSchedule

        public size(): u32 {
            let size: u32 = 0;

            if (this.UpdateClients != null) {
                const f: google.protobuf.Timestamp = this
                    .UpdateClients as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UpdateServers != null) {
                const f: google.protobuf.Timestamp = this
                    .UpdateServers as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Standby != null) {
                const f: google.protobuf.Timestamp = this
                    .Standby as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RotationSchedule to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RotationSchedule to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UpdateClients != null) {
                const f = this.UpdateClients as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UpdateServers != null) {
                const f = this.UpdateServers as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Standby != null) {
                const f = this.Standby as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RotationSchedule
    } // RotationSchedule

    // SessionRecordingConfigV2 contains session recording configuration.
    export class ResourceHeader {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();

        // Decodes ResourceHeader from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceHeader {
            return ResourceHeader.decode(new DataView(buf));
        }

        // Decodes ResourceHeader from a DataView
        static decode(view: DataView): ResourceHeader {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceHeader();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceHeader

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ResourceHeader to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceHeader to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ResourceHeader
    } // ResourceHeader

    // NamespaceSpec is a namespace specificateion
    export class DatabaseServerV3 {
        // Kind is the database server resource kind.
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the database server metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the database server spec.
        public Spec: types.DatabaseServerSpecV3 =
            new types.DatabaseServerSpecV3();

        // Decodes DatabaseServerV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseServerV3 {
            return DatabaseServerV3.decode(new DataView(buf));
        }

        // Decodes DatabaseServerV3 from a DataView
        static decode(view: DataView): DatabaseServerV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseServerV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.DatabaseServerSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseServerV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.DatabaseServerSpecV3 = this
                    .Spec as types.DatabaseServerSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseServerV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseServerV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.DatabaseServerSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseServerV3
    } // DatabaseServerV3

    /**
     * AccessCapabilities is a summary of capabilities that a user
     *  is granted via their dynamic access privileges which may not be
     *  calculable by directly examining the user's own static roles.
     */
    export class DatabaseServerSpecV3 {
        /**
         * Description is a free-form text describing this database server.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public Description: string = "";
        /**
         * Protocol is the database type e.g. postgres, mysql, etc.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public Protocol: string = "";
        /**
         * URI is the database connection address.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public URI: string = "";
        /**
         * CACert is an optional base64-encoded database CA certificate.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public CACert: Array<u8> = new Array<u8>();
        /**
         * AWS contains AWS specific settings for RDS/Aurora databases.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public AWS: types.AWS = new types.AWS();
        // Version is the Teleport version that the server is running.
        public Version: string = "";
        // Hostname is the database server hostname.
        public Hostname: string = "";
        // HostID is the ID of the host the database server is running on.
        public HostID: string = "";
        /**
         * DynamicLabels is the database server dynamic labels.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        // Rotation contains the server CA rotation information.
        public Rotation: types.Rotation = new types.Rotation();
        /**
         * GCP contains parameters specific to GCP Cloud SQL databases.
         *
         *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.
         */
        public GCP: types.GCPCloudSQL = new types.GCPCloudSQL();
        // Database is the database proxied by this database server.
        public Database: types.DatabaseV3 = new types.DatabaseV3();

        // Decodes DatabaseServerSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseServerSpecV3 {
            return DatabaseServerSpecV3.decode(new DataView(buf));
        }

        // Decodes DatabaseServerSpecV3 from a DataView
        static decode(view: DataView): DatabaseServerSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseServerSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Description = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Protocol = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.CACert = decoder.bytes();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.GCP = types.GCPCloudSQL.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Database = types.DatabaseV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseServerSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;
            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GCP != null) {
                const f: types.GCPCloudSQL = this.GCP as types.GCPCloudSQL;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: types.DatabaseV3 = this.Database as types.DatabaseV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseServerSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseServerSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Description.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }
            if (this.Protocol.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.CACert.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CACert.length);
                encoder.bytes(this.CACert);
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Version.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x4a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.GCP != null) {
                const f = this.GCP as types.GCPCloudSQL;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as types.DatabaseV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseServerSpecV3
    } // DatabaseServerSpecV3

    /**
     * RoleConditions is a set of conditions that must all match to be allowed or
     *  denied access.
     */
    export class DatabaseV3List {
        // Databases is a list of database resources.
        public Databases: Array<types.DatabaseV3> =
            new Array<types.DatabaseV3>();

        // Decodes DatabaseV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseV3List {
            return DatabaseV3List.decode(new DataView(buf));
        }

        // Decodes DatabaseV3List from a DataView
        static decode(view: DataView): DatabaseV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Databases.push(
                            types.DatabaseV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Databases.length; n++) {
                const messageSize = this.Databases[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseV3List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseV3List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Databases.length; n++) {
                const messageSize = this.Databases[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Databases[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseV3List
    } // DatabaseV3List

    // LoginStatus is a login status of the user
    export class DatabaseV3 {
        // Kind is the database resource kind.
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the database metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the database spec.
        public Spec: types.DatabaseSpecV3 = new types.DatabaseSpecV3();
        // Status is the database runtime information.
        public Status: types.DatabaseStatusV3 = new types.DatabaseStatusV3();

        // Decodes DatabaseV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseV3 {
            return DatabaseV3.decode(new DataView(buf));
        }

        // Decodes DatabaseV3 from a DataView
        static decode(view: DataView): DatabaseV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.DatabaseSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = types.DatabaseStatusV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.DatabaseSpecV3 = this
                    .Spec as types.DatabaseSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.DatabaseStatusV3 = this
                    .Status as types.DatabaseStatusV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.DatabaseSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.DatabaseStatusV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseV3
    } // DatabaseV3

    // UserRef holds references to user
    export class DatabaseSpecV3 {
        // Protocol is the database protocol: postgres, mysql, mongodb, etc.
        public Protocol: string = "";
        // URI is the database connection endpoint.
        public URI: string = "";
        /**
         * CACert is the PEM-encoded database CA certificate.
         *
         *  DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
         */
        public CACert: string = "";
        // DynamicLabels is the database dynamic labels.
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        // AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
        public AWS: types.AWS = new types.AWS();
        // GCP contains parameters specific to GCP Cloud SQL databases.
        public GCP: types.GCPCloudSQL = new types.GCPCloudSQL();
        // Azure contains Azure specific database metadata.
        public Azure: types.Azure = new types.Azure();
        /**
         * TLS is the TLS configuration used when establishing connection to target database.
         *  Allows to provide custom CA cert or override server name.
         */
        public TLS: types.DatabaseTLS = new types.DatabaseTLS();

        // Decodes DatabaseSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSpecV3 {
            return DatabaseSpecV3.decode(new DataView(buf));
        }

        // Decodes DatabaseSpecV3 from a DataView
        static decode(view: DataView): DatabaseSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Protocol = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.CACert = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.GCP = types.GCPCloudSQL.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Azure = types.Azure.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.TLS = types.DatabaseTLS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GCP != null) {
                const f: types.GCPCloudSQL = this.GCP as types.GCPCloudSQL;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Azure != null) {
                const f: types.Azure = this.Azure as types.Azure;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TLS != null) {
                const f: types.DatabaseTLS = this.TLS as types.DatabaseTLS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Protocol.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.CACert.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.CACert.length);
                encoder.string(this.CACert);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.GCP != null) {
                const f = this.GCP as types.GCPCloudSQL;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Azure != null) {
                const f = this.Azure as types.Azure;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TLS != null) {
                const f = this.TLS as types.DatabaseTLS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseSpecV3
    } // DatabaseSpecV3

    // SemaphoreSpecV3 contains the data about lease
    export class DatabaseStatusV3 {
        // CACert is the auto-downloaded cloud database CA certificate.
        public CACert: string = "";
        // AWS is the auto-discovered AWS cloud database metadata.
        public AWS: types.AWS = new types.AWS();

        // Decodes DatabaseStatusV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseStatusV3 {
            return DatabaseStatusV3.decode(new DataView(buf));
        }

        // Decodes DatabaseStatusV3 from a DataView
        static decode(view: DataView): DatabaseStatusV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseStatusV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.CACert = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseStatusV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseStatusV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseStatusV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.CACert.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.CACert.length);
                encoder.string(this.CACert);
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseStatusV3
    } // DatabaseStatusV3

    // WebTokenSpecV3 is a unique time-limited token bound to a user's web session
    export class AWS {
        // Region is a AWS cloud region.
        public Region: string = "";
        // Redshift contains Redshift specific metadata.
        public Redshift: types.Redshift = new types.Redshift();
        // RDS contains RDS specific metadata.
        public RDS: types.RDS = new types.RDS();
        // AccountID is the AWS account ID this database belongs to.
        public AccountID: string = "";

        // Decodes AWS from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AWS {
            return AWS.decode(new DataView(buf));
        }

        // Decodes AWS from a DataView
        static decode(view: DataView): AWS {
            const decoder = new __proto.Decoder(view);
            const obj = new AWS();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Region = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Redshift = types.Redshift.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.RDS = types.RDS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.AccountID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AWS

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Region.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Region.length) +
                      this.Region.length
                    : 0;

            if (this.Redshift != null) {
                const f: types.Redshift = this.Redshift as types.Redshift;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RDS != null) {
                const f: types.RDS = this.RDS as types.RDS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.AccountID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AccountID.length) +
                      this.AccountID.length
                    : 0;

            return size;
        }

        // Encodes AWS to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AWS to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Region.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Region.length);
                encoder.string(this.Region);
            }

            if (this.Redshift != null) {
                const f = this.Redshift as types.Redshift;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RDS != null) {
                const f = this.RDS as types.RDS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AccountID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AccountID.length);
                encoder.string(this.AccountID);
            }

            return buf;
        } // encode AWS
    } // AWS

    // OIDCConnectorV3 represents an OIDC connector.
    export class Redshift {
        // ClusterID is the Redshift cluster identifier.
        public ClusterID: string = "";

        // Decodes Redshift from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Redshift {
            return Redshift.decode(new DataView(buf));
        }

        // Decodes Redshift from a DataView
        static decode(view: DataView): Redshift {
            const decoder = new __proto.Decoder(view);
            const obj = new Redshift();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Redshift

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;

            return size;
        }

        // Encodes Redshift to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Redshift to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }

            return buf;
        } // encode Redshift
    } // Redshift

    // GithubConnectorSpecV3 is a Github connector specification.
    export class RDS {
        // InstanceID is the RDS instance identifier.
        public InstanceID: string = "";
        // ClusterID is the RDS cluster (Aurora) identifier.
        public ClusterID: string = "";
        // ResourceID is the RDS instance resource identifier (db-xxx).
        public ResourceID: string = "";
        // IAMAuth indicates whether database IAM authentication is enabled.
        public IAMAuth: bool;

        // Decodes RDS from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RDS {
            return RDS.decode(new DataView(buf));
        }

        // Decodes RDS from a DataView
        static decode(view: DataView): RDS {
            const decoder = new __proto.Decoder(view);
            const obj = new RDS();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.InstanceID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ResourceID = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.IAMAuth = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RDS

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.InstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.InstanceID.length) +
                      this.InstanceID.length
                    : 0;
            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;
            size +=
                this.ResourceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceID.length) +
                      this.ResourceID.length
                    : 0;
            size += this.IAMAuth == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes RDS to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RDS to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.InstanceID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.InstanceID.length);
                encoder.string(this.InstanceID);
            }
            if (this.ClusterID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }
            if (this.ResourceID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ResourceID.length);
                encoder.string(this.ResourceID);
            }
            if (this.IAMAuth != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.IAMAuth);
            }

            return buf;
        } // encode RDS
    } // RDS

    /**
     * NetworkRestrictions specifies a list of addresses to restrict (block). The deny
     *  list is checked first and the allow lists overrides it. Thus an empty allow
     *  list does not mean that no addresses will be allowed, that will only be the
     *  case if the deny list covers the whole address range.
     */
    export class GCPCloudSQL {
        // ProjectID is the GCP project ID the Cloud SQL instance resides in.
        public ProjectID: string = "";
        // InstanceID is the Cloud SQL instance ID.
        public InstanceID: string = "";

        // Decodes GCPCloudSQL from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GCPCloudSQL {
            return GCPCloudSQL.decode(new DataView(buf));
        }

        // Decodes GCPCloudSQL from a DataView
        static decode(view: DataView): GCPCloudSQL {
            const decoder = new __proto.Decoder(view);
            const obj = new GCPCloudSQL();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ProjectID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.InstanceID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GCPCloudSQL

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ProjectID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProjectID.length) +
                      this.ProjectID.length
                    : 0;
            size +=
                this.InstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.InstanceID.length) +
                      this.InstanceID.length
                    : 0;

            return size;
        }

        // Encodes GCPCloudSQL to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GCPCloudSQL to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ProjectID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ProjectID.length);
                encoder.string(this.ProjectID);
            }
            if (this.InstanceID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.InstanceID.length);
                encoder.string(this.InstanceID);
            }

            return buf;
        } // encode GCPCloudSQL
    } // GCPCloudSQL

    // RecoveryCode describes a recovery code.
    export class Azure {
        // Name is the Azure database server name.
        public Name: string = "";

        // Decodes Azure from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Azure {
            return Azure.decode(new DataView(buf));
        }

        // Decodes Azure from a DataView
        static decode(view: DataView): Azure {
            const decoder = new __proto.Decoder(view);
            const obj = new Azure();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Azure

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            return size;
        }

        // Encodes Azure to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Azure to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            return buf;
        } // encode Azure
    } // Azure

    // DatabaseTLS contains TLS configuration options.
    export class DatabaseTLS {
        // Mode is a TLS connection mode. See DatabaseTLSMode for details.
        public Mode: u32;
        /**
         * CACert is an optional user provided CA certificate used for verifying
         *  database TLS connection.
         */
        public CACert: string = "";
        /**
         * ServerName allows to provide custom hostname. This value will override the
         *  servername/hostname on a certificate during validation.
         */
        public ServerName: string = "";

        // Decodes DatabaseTLS from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseTLS {
            return DatabaseTLS.decode(new DataView(buf));
        }

        // Decodes DatabaseTLS from a DataView
        static decode(view: DataView): DatabaseTLS {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseTLS();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Mode = decoder.uint32();
                        break;
                    }
                    case 2: {
                        obj.CACert = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ServerName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseTLS

        public size(): u32 {
            let size: u32 = 0;

            size += this.Mode == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Mode);
            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;
            size +=
                this.ServerName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerName.length) +
                      this.ServerName.length
                    : 0;

            return size;
        }

        // Encodes DatabaseTLS to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseTLS to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Mode != 0) {
                encoder.uint32(0x8);
                encoder.uint32(this.Mode);
            }
            if (this.CACert.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.CACert.length);
                encoder.string(this.CACert);
            }
            if (this.ServerName.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ServerName.length);
                encoder.string(this.ServerName);
            }

            return buf;
        } // encode DatabaseTLS
    } // DatabaseTLS

    // ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.
    export class ServerV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a server spec
        public Spec: types.ServerSpecV2 = new types.ServerSpecV2();

        // Decodes ServerV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerV2 {
            return ServerV2.decode(new DataView(buf));
        }

        // Decodes ServerV2 from a DataView
        static decode(view: DataView): ServerV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ServerSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ServerSpecV2 = this.Spec as types.ServerSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ServerSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ServerV2
    } // ServerV2

    /**
     * ServerV2List is a list of servers.
     *  DELETE IN 8.0.0 only used in deprecated GetNodes rpc
     */
    export class ServerV2List {
        // Servers is a list of servers.
        public Servers: Array<types.ServerV2> = new Array<types.ServerV2>();

        // Decodes ServerV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerV2List {
            return ServerV2List.decode(new DataView(buf));
        }

        // Decodes ServerV2List from a DataView
        static decode(view: DataView): ServerV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Servers.push(
                            types.ServerV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Servers.length; n++) {
                const messageSize = this.Servers[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerV2List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerV2List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Servers.length; n++) {
                const messageSize = this.Servers[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Servers[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ServerV2List
    } // ServerV2List

    // ServerSpecV2 is a specification for V2 Server
    export class ServerSpecV2 {
        // Addr is server host:port address
        public Addr: string = "";
        // PublicAddr is the public address this cluster can be reached at.
        public PublicAddr: string = "";
        // Hostname is server hostname
        public Hostname: string = "";
        // CmdLabels is server dynamic labels
        public CmdLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        // Rotation specifies server rotation
        public Rotation: types.Rotation = new types.Rotation();
        /**
         * UseTunnel indicates that connections to this server should occur over a
         *  reverse tunnel.
         */
        public UseTunnel: bool;
        // TeleportVersion is the teleport version that the server is running on
        public Version: string = "";
        /**
         * Apps is a list of applications this server is proxying.
         *
         *  DELETE IN 9.0. Deprecated, moved to AppServerSpecV3.
         */
        public Apps: Array<types.App> = new Array<types.App>();
        /**
         * KubernetesClusters is a list of kubernetes clusters provided by this
         *  Proxy or KubeService server.
         *
         *  Important: jsontag must not be "kubernetes_clusters", because a
         *  different field with that jsontag existed in 4.4:
         *  https://github.com/gravitational/teleport/issues/4862
         */
        public KubernetesClusters: Array<types.KubernetesCluster> =
            new Array<types.KubernetesCluster>();

        // Decodes ServerSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerSpecV2 {
            return ServerSpecV2.decode(new DataView(buf));
        }

        // Decodes ServerSpecV2 from a DataView
        static decode(view: DataView): ServerSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.CmdLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.UseTunnel = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Apps.push(
                            types.App.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.KubernetesClusters.push(
                            types.KubernetesCluster.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;

            if (this.CmdLabels.size > 0) {
                const keys = this.CmdLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.CmdLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.UseTunnel == 0 ? 0 : 1 + 1;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {
                const messageSize = this.KubernetesClusters[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }

            if (this.CmdLabels.size > 0) {
                const keys = this.CmdLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.CmdLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UseTunnel != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.UseTunnel);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    this.Apps[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {
                const messageSize = this.KubernetesClusters[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.KubernetesClusters[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ServerSpecV2
    } // ServerSpecV2

    // AppServerV3 represents a single proxied web app.
    export class AppServerV3 {
        // Kind is the app server resource kind. Always "app_server".
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the app server metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the app server spec.
        public Spec: types.AppServerSpecV3 = new types.AppServerSpecV3();

        // Decodes AppServerV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppServerV3 {
            return AppServerV3.decode(new DataView(buf));
        }

        // Decodes AppServerV3 from a DataView
        static decode(view: DataView): AppServerV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppServerV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AppServerSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppServerV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AppServerSpecV3 = this
                    .Spec as types.AppServerSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppServerV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppServerV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AppServerSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppServerV3
    } // AppServerV3

    // AppServerSpecV3 is the app access server spec.
    export class AppServerSpecV3 {
        // Version is the Teleport version that the server is running.
        public Version: string = "";
        // Hostname is the app server hostname.
        public Hostname: string = "";
        // HostID is the app server host uuid.
        public HostID: string = "";
        // Rotation contains the app server CA rotation information.
        public Rotation: types.Rotation = new types.Rotation();
        // App is the app proxied by this app server.
        public App: types.AppV3 = new types.AppV3();

        // Decodes AppServerSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppServerSpecV3 {
            return AppServerSpecV3.decode(new DataView(buf));
        }

        // Decodes AppServerSpecV3 from a DataView
        static decode(view: DataView): AppServerSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppServerSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.App = types.AppV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppServerSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: types.AppV3 = this.App as types.AppV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppServerSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppServerSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Version.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as types.AppV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppServerSpecV3
    } // AppServerSpecV3

    // AppV3List represents a list of app resources.
    export class AppV3List {
        // Apps is a list of app resources.
        public Apps: Array<types.AppV3> = new Array<types.AppV3>();

        // Decodes AppV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppV3List {
            return AppV3List.decode(new DataView(buf));
        }

        // Decodes AppV3List from a DataView
        static decode(view: DataView): AppV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new AppV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Apps.push(
                            types.AppV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppV3List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppV3List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Apps[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppV3List
    } // AppV3List

    // AppV3 represents an app resource.
    export class AppV3 {
        // Kind is the app resource kind. Always "app".
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the app resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the app resource spec.
        public Spec: types.AppSpecV3 = new types.AppSpecV3();

        // Decodes AppV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppV3 {
            return AppV3.decode(new DataView(buf));
        }

        // Decodes AppV3 from a DataView
        static decode(view: DataView): AppV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AppSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AppSpecV3 = this.Spec as types.AppSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AppSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppV3
    } // AppV3

    // AppSpecV3 is the AppV3 resource spec.
    export class AppSpecV3 {
        // URI is the web app endpoint.
        public URI: string = "";
        // PublicAddr is the public address the application is accessible at.
        public PublicAddr: string = "";
        // DynamicLabels are the app's command labels.
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        // InsecureSkipVerify disables app's TLS certificate verification.
        public InsecureSkipVerify: bool;
        // Rewrite is a list of rewriting rules to apply to requests and responses.
        public Rewrite: types.Rewrite = new types.Rewrite();

        // Decodes AppSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSpecV3 {
            return AppSpecV3.decode(new DataView(buf));
        }

        // Decodes AppSpecV3 from a DataView
        static decode(view: DataView): AppSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.InsecureSkipVerify = decoder.bool();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Rewrite = types.Rewrite.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;

            if (this.Rewrite != null) {
                const f: types.Rewrite = this.Rewrite as types.Rewrite;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.URI.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            if (this.InsecureSkipVerify != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.InsecureSkipVerify);
            }

            if (this.Rewrite != null) {
                const f = this.Rewrite as types.Rewrite;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppSpecV3
    } // AppSpecV3

    /**
     * App is a specific application that a server proxies.
     *
     *  DELETE IN 9.0. Deprecated, use AppV3.
     */
    export class App {
        // Name is the name of the application.
        public Name: string = "";
        // URI is the internal address the application is available at.
        public URI: string = "";
        // PublicAddr is the public address the application is accessible at.
        public PublicAddr: string = "";
        /**
         * StaticLabels is map of static labels associated with an application.
         *  Used for RBAC.
         */
        public StaticLabels: Map<string, string> = new Map<string, string>();
        /**
         * DynamicLabels is map of dynamic labels associated with an application.
         *  Used for RBAC.
         */
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        // InsecureSkipVerify disables app's TLS certificate verification.
        public InsecureSkipVerify: bool;
        // Rewrite is a list of rewriting rules to apply to requests and responses.
        public Rewrite: types.Rewrite = new types.Rewrite();
        // Description is an optional free-form app description.
        public Description: string = "";

        // Decodes App from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): App {
            return App.decode(new DataView(buf));
        }

        // Decodes App from a DataView
        static decode(view: DataView): App {
            const decoder = new __proto.Decoder(view);
            const obj = new App();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.StaticLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.InsecureSkipVerify = decoder.bool();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Rewrite = types.Rewrite.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        obj.Description = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode App

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;

            if (this.Rewrite != null) {
                const f: types.Rewrite = this.Rewrite as types.Rewrite;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;

            return size;
        }

        // Encodes App to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes App to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            if (this.InsecureSkipVerify != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.InsecureSkipVerify);
            }

            if (this.Rewrite != null) {
                const f = this.Rewrite as types.Rewrite;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Description.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }

            return buf;
        } // encode App
    } // App

    // Rewrite is a list of rewriting rules to apply to requests and responses.
    export class Rewrite {
        /**
         * Redirect defines a list of hosts which will be rewritten to the public
         *  address of the application if they occur in the "Location" header.
         */
        public Redirect: Array<string> = new Array<string>();
        /**
         * Headers is a list of headers to inject when passing the request over
         *  to the application.
         */
        public Headers: Array<types.Header> = new Array<types.Header>();

        // Decodes Rewrite from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rewrite {
            return Rewrite.decode(new DataView(buf));
        }

        // Decodes Rewrite from a DataView
        static decode(view: DataView): Rewrite {
            const decoder = new __proto.Decoder(view);
            const obj = new Rewrite();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Redirect.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Headers.push(
                            types.Header.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rewrite

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Redirect);

            for (let n: i32 = 0; n < this.Headers.length; n++) {
                const messageSize = this.Headers[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Rewrite to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rewrite to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Redirect.length > 0) {
                for (let n: i32 = 0; n < this.Redirect.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Redirect[n].length);
                    encoder.string(this.Redirect[n]);
                }
            }

            for (let n: i32 = 0; n < this.Headers.length; n++) {
                const messageSize = this.Headers[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.Headers[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode Rewrite
    } // Rewrite

    // Header represents a single http header passed over to the proxied application.
    export class Header {
        // Name is the http header name.
        public Name: string = "";
        // Value is the http header value.
        public Value: string = "";

        // Decodes Header from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Header {
            return Header.decode(new DataView(buf));
        }

        // Decodes Header from a DataView
        static decode(view: DataView): Header {
            const decoder = new __proto.Decoder(view);
            const obj = new Header();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Header

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            return size;
        }

        // Encodes Header to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Header to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            return buf;
        } // encode Header
    } // Header

    /**
     * CommandLabelV2 is a label that has a value as a result of the
     *  output generated by running command, e.g. hostname
     */
    export class CommandLabelV2 {
        // Period is a time between command runs
        public Period: i64;
        // Command is a command to run
        public Command: Array<string> = new Array<string>();
        // Result captures standard output
        public Result: string = "";

        // Decodes CommandLabelV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CommandLabelV2 {
            return CommandLabelV2.decode(new DataView(buf));
        }

        // Decodes CommandLabelV2 from a DataView
        static decode(view: DataView): CommandLabelV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CommandLabelV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Period = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.Command.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Result = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CommandLabelV2

        public size(): u32 {
            let size: u32 = 0;

            size += this.Period == 0 ? 0 : 1 + __proto.Sizer.int64(this.Period);

            size += __size_string_repeated(this.Command);

            size +=
                this.Result.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Result.length) +
                      this.Result.length
                    : 0;

            return size;
        }

        // Encodes CommandLabelV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CommandLabelV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Period != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.Period);
            }

            if (this.Command.length > 0) {
                for (let n: i32 = 0; n < this.Command.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Command[n].length);
                    encoder.string(this.Command[n]);
                }
            }

            if (this.Result.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Result.length);
                encoder.string(this.Result);
            }

            return buf;
        } // encode CommandLabelV2
    } // CommandLabelV2

    // SSHKeyPair is an SSH CA key pair.
    export class SSHKeyPair {
        // PublicKey is the SSH public key.
        public PublicKey: Array<u8> = new Array<u8>();
        // PrivateKey is the SSH private key.
        public PrivateKey: Array<u8> = new Array<u8>();
        // PrivateKeyType is the type of the PrivateKey.
        public PrivateKeyType: u32;

        // Decodes SSHKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SSHKeyPair {
            return SSHKeyPair.decode(new DataView(buf));
        }

        // Decodes SSHKeyPair from a DataView
        static decode(view: DataView): SSHKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new SSHKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PublicKey = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.PrivateKey = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PrivateKeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SSHKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PublicKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicKey.length) +
                      this.PublicKey.length
                    : 0;
            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.PrivateKeyType == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.PrivateKeyType);

            return size;
        }

        // Encodes SSHKeyPair to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SSHKeyPair to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PublicKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PublicKey.length);
                encoder.bytes(this.PublicKey);
            }
            if (this.PrivateKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PrivateKey.length);
                encoder.bytes(this.PrivateKey);
            }
            if (this.PrivateKeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.PrivateKeyType);
            }

            return buf;
        } // encode SSHKeyPair
    } // SSHKeyPair

    // TLSKeyPair is a TLS key pair
    export class TLSKeyPair {
        // Cert is a PEM encoded TLS cert
        public Cert: Array<u8> = new Array<u8>();
        // Key is a PEM encoded TLS key
        public Key: Array<u8> = new Array<u8>();
        // KeyType is the type of the Key.
        public KeyType: u32;

        // Decodes TLSKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TLSKeyPair {
            return TLSKeyPair.decode(new DataView(buf));
        }

        // Decodes TLSKeyPair from a DataView
        static decode(view: DataView): TLSKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new TLSKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Cert = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.Key = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.KeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TLSKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;
            size +=
                this.Key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Key.length) +
                      this.Key.length
                    : 0;
            size +=
                this.KeyType == 0 ? 0 : 1 + __proto.Sizer.uint32(this.KeyType);

            return size;
        }

        // Encodes TLSKeyPair to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TLSKeyPair to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Cert.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Cert.length);
                encoder.bytes(this.Cert);
            }
            if (this.Key.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Key.length);
                encoder.bytes(this.Key);
            }
            if (this.KeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.KeyType);
            }

            return buf;
        } // encode TLSKeyPair
    } // TLSKeyPair

    // JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
    export class JWTKeyPair {
        // PublicKey is a PEM encoded public key.
        public PublicKey: Array<u8> = new Array<u8>();
        // PrivateKey is a PEM encoded private key.
        public PrivateKey: Array<u8> = new Array<u8>();
        // PrivateKeyType is the type of the PrivateKey.
        public PrivateKeyType: u32;

        // Decodes JWTKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): JWTKeyPair {
            return JWTKeyPair.decode(new DataView(buf));
        }

        // Decodes JWTKeyPair from a DataView
        static decode(view: DataView): JWTKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new JWTKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PublicKey = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.PrivateKey = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PrivateKeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode JWTKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PublicKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicKey.length) +
                      this.PublicKey.length
                    : 0;
            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.PrivateKeyType == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.PrivateKeyType);

            return size;
        }

        // Encodes JWTKeyPair to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes JWTKeyPair to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PublicKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PublicKey.length);
                encoder.bytes(this.PublicKey);
            }
            if (this.PrivateKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PrivateKey.length);
                encoder.bytes(this.PrivateKey);
            }
            if (this.PrivateKeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.PrivateKeyType);
            }

            return buf;
        } // encode JWTKeyPair
    } // JWTKeyPair

    // CertAuthorityV2 is version 2 resource spec for Cert Authority
    export class CertAuthorityV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is connector metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec contains cert authority specification
        public Spec: types.CertAuthoritySpecV2 =
            new types.CertAuthoritySpecV2();

        // Decodes CertAuthorityV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CertAuthorityV2 {
            return CertAuthorityV2.decode(new DataView(buf));
        }

        // Decodes CertAuthorityV2 from a DataView
        static decode(view: DataView): CertAuthorityV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CertAuthorityV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.CertAuthoritySpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CertAuthorityV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.CertAuthoritySpecV2 = this
                    .Spec as types.CertAuthoritySpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CertAuthorityV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CertAuthorityV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.CertAuthoritySpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode CertAuthorityV2
    } // CertAuthorityV2

    /**
     * CertAuthoritySpecV2 is a host or user certificate authority that
     *  can check and if it has private key stored as well, sign it too
     */
    export class CertAuthoritySpecV2 {
        // Type is either user or host certificate authority
        public Type: string = "";
        /**
         * DELETE IN(2.7.0) this field is deprecated,
         *  as resource name matches cluster name after migrations.
         *  and this property is enforced by the auth server code.
         *  ClusterName identifies cluster name this authority serves,
         *  for host authorities that means base hostname of all servers,
         *  for user authorities that means organization name
         */
        public ClusterName: string = "";
        /**
         * Checkers is a list of SSH public keys that can be used to check
         *  certificate signatures
         *
         *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.
         */
        public CheckingKeys: Array<Array<u8>> = new Array<Array<u8>>();
        /**
         * SigningKeys is a list of private keys used for signing
         *
         *  DEPRECATED: use ActiveKeys instead.
         */
        public SigningKeys: Array<Array<u8>> = new Array<Array<u8>>();
        // Roles is a list of roles assumed by users signed by this CA
        public Roles: Array<string> = new Array<string>();
        // RoleMap specifies role mappings to remote roles
        public RoleMap: Array<types.RoleMapping> =
            new Array<types.RoleMapping>();
        /**
         * TLS is a list of TLS key pairs
         *
         *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.
         */
        public TLSKeyPairs: Array<types.TLSKeyPair> =
            new Array<types.TLSKeyPair>();
        // Rotation is a status of the certificate authority rotation
        public Rotation: types.Rotation = new types.Rotation();
        public SigningAlg: u32;
        /**
         * JWTKeyPair is a list of JWT key pairs.
         *
         *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.
         */
        public JWTKeyPairs: Array<types.JWTKeyPair> =
            new Array<types.JWTKeyPair>();
        // ActiveKeys are the CA key sets used to sign any new certificates.
        public ActiveKeys: types.CAKeySet = new types.CAKeySet();
        /**
         * AdditionalTrustedKeys are additional CA key sets that can be used to
         *  verify certificates. Certificates should be verified with
         *  AdditionalTrustedKeys and ActiveKeys combined.
         */
        public AdditionalTrustedKeys: types.CAKeySet = new types.CAKeySet();

        // Decodes CertAuthoritySpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CertAuthoritySpecV2 {
            return CertAuthoritySpecV2.decode(new DataView(buf));
        }

        // Decodes CertAuthoritySpecV2 from a DataView
        static decode(view: DataView): CertAuthoritySpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CertAuthoritySpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.CheckingKeys.push(decoder.bytes());
                        break;
                    }
                    case 4: {
                        obj.SigningKeys.push(decoder.bytes());
                        break;
                    }
                    case 5: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.RoleMap.push(
                            types.RoleMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.TLSKeyPairs.push(
                            types.TLSKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.SigningAlg = decoder.uint32();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.JWTKeyPairs.push(
                            types.JWTKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.ActiveKeys = types.CAKeySet.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.AdditionalTrustedKeys = types.CAKeySet.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CertAuthoritySpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            size += __size_bytes_repeated(this.CheckingKeys);

            size += __size_bytes_repeated(this.SigningKeys);

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {
                const messageSize = this.TLSKeyPairs[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SigningAlg == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.SigningAlg);

            for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {
                const messageSize = this.JWTKeyPairs[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ActiveKeys != null) {
                const f: types.CAKeySet = this.ActiveKeys as types.CAKeySet;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AdditionalTrustedKeys != null) {
                const f: types.CAKeySet = this
                    .AdditionalTrustedKeys as types.CAKeySet;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CertAuthoritySpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CertAuthoritySpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ClusterName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            if (this.CheckingKeys.length > 0) {
                for (let n: i32 = 0; n < this.CheckingKeys.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.CheckingKeys[n].length);
                    encoder.bytes(this.CheckingKeys[n]);
                }
            }

            if (this.SigningKeys.length > 0) {
                for (let n: i32 = 0; n < this.SigningKeys.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.SigningKeys[n].length);
                    encoder.bytes(this.SigningKeys[n]);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    this.RoleMap[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {
                const messageSize = this.TLSKeyPairs[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    this.TLSKeyPairs[n].encodeU8Array(encoder);
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SigningAlg != 0) {
                encoder.uint32(0x48);
                encoder.uint32(this.SigningAlg);
            }

            for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {
                const messageSize = this.JWTKeyPairs[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.JWTKeyPairs[n].encodeU8Array(encoder);
                }
            }

            if (this.ActiveKeys != null) {
                const f = this.ActiveKeys as types.CAKeySet;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AdditionalTrustedKeys != null) {
                const f = this.AdditionalTrustedKeys as types.CAKeySet;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode CertAuthoritySpecV2
    } // CertAuthoritySpecV2

    /**
     * SigningAlg is the algorithm used for signing new SSH certificates using
     *  SigningKeys.
     */
    export enum CertAuthoritySpecV2_SigningAlgType {
        UNKNOWN = 0,
        RSA_SHA1 = 1,
        RSA_SHA2_256 = 2,
        RSA_SHA2_512 = 3,
    } // CertAuthoritySpecV2_SigningAlgType
    // CAKeySet is the set of CA keys.
    export class CAKeySet {
        // SSH contains SSH CA key pairs.
        public SSH: Array<types.SSHKeyPair> = new Array<types.SSHKeyPair>();
        // TLS contains TLS CA key/cert pairs.
        public TLS: Array<types.TLSKeyPair> = new Array<types.TLSKeyPair>();
        // JWT contains JWT signing key pairs.
        public JWT: Array<types.JWTKeyPair> = new Array<types.JWTKeyPair>();

        // Decodes CAKeySet from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CAKeySet {
            return CAKeySet.decode(new DataView(buf));
        }

        // Decodes CAKeySet from a DataView
        static decode(view: DataView): CAKeySet {
            const decoder = new __proto.Decoder(view);
            const obj = new CAKeySet();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.SSH.push(
                            types.SSHKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.TLS.push(
                            types.TLSKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.JWT.push(
                            types.JWTKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CAKeySet

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.SSH.length; n++) {
                const messageSize = this.SSH[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.TLS.length; n++) {
                const messageSize = this.TLS[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.JWT.length; n++) {
                const messageSize = this.JWT[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CAKeySet to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CAKeySet to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.SSH.length; n++) {
                const messageSize = this.SSH[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.SSH[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.TLS.length; n++) {
                const messageSize = this.TLS[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.TLS[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.JWT.length; n++) {
                const messageSize = this.JWT[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    this.JWT[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode CAKeySet
    } // CAKeySet

    /**
     * RoleMapping provides mapping of remote roles to local roles
     *  for trusted clusters
     */
    export class RoleMapping {
        // Remote specifies remote role name to map from
        public Remote: string = "";
        // Local specifies local roles to map to
        public Local: Array<string> = new Array<string>();

        // Decodes RoleMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleMapping {
            return RoleMapping.decode(new DataView(buf));
        }

        // Decodes RoleMapping from a DataView
        static decode(view: DataView): RoleMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Remote = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Local.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Remote.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Remote.length) +
                      this.Remote.length
                    : 0;

            size += __size_string_repeated(this.Local);

            return size;
        }

        // Encodes RoleMapping to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleMapping to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Remote.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Remote.length);
                encoder.string(this.Remote);
            }

            if (this.Local.length > 0) {
                for (let n: i32 = 0; n < this.Local.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Local[n].length);
                    encoder.string(this.Local[n]);
                }
            }

            return buf;
        } // encode RoleMapping
    } // RoleMapping

    // ProvisionTokenV1 is a provisioning token V1
    export class ProvisionTokenV1 {
        /**
         * Roles is a list of roles associated with the token,
         *  that will be converted to metadata in the SSH and X509
         *  certificates issued to the user of the token
         */
        public Roles: Array<string> = new Array<string>();
        /**
         * Expires is a global expiry time header can be set on any resource in the
         *  system.
         */
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Token is a token name
        public Token: string = "";

        // Decodes ProvisionTokenV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV1 {
            return ProvisionTokenV1.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV1 from a DataView
        static decode(view: DataView): ProvisionTokenV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV1

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes ProvisionTokenV1 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV1 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Token.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode ProvisionTokenV1
    } // ProvisionTokenV1

    // ProvisionTokenV2 specifies provisioning token
    export class ProvisionTokenV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a provisioning token V2 spec
        public Spec: types.ProvisionTokenSpecV2 =
            new types.ProvisionTokenSpecV2();

        // Decodes ProvisionTokenV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV2 {
            return ProvisionTokenV2.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV2 from a DataView
        static decode(view: DataView): ProvisionTokenV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ProvisionTokenSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ProvisionTokenSpecV2 = this
                    .Spec as types.ProvisionTokenSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ProvisionTokenV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ProvisionTokenSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ProvisionTokenV2
    } // ProvisionTokenV2

    // ProvisionTokenV2List is a list of provisioning tokens.
    export class ProvisionTokenV2List {
        // ProvisionTokens is a list of provisioning tokens.
        public ProvisionTokens: Array<types.ProvisionTokenV2> =
            new Array<types.ProvisionTokenV2>();

        // Decodes ProvisionTokenV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV2List {
            return ProvisionTokenV2List.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV2List from a DataView
        static decode(view: DataView): ProvisionTokenV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.ProvisionTokens.push(
                            types.ProvisionTokenV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {
                const messageSize = this.ProvisionTokens[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ProvisionTokenV2List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV2List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {
                const messageSize = this.ProvisionTokens[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.ProvisionTokens[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ProvisionTokenV2List
    } // ProvisionTokenV2List

    /**
     * TokenRule is a rule that a joining node must match in order to use the
     *  associated token.
     */
    export class TokenRule {
        // AWSAccount is the AWS account ID.
        public AWSAccount: string = "";
        /**
         * AWSRegions is used for the EC2 join method and is a list of AWS regions a
         *  node is allowed to join from.
         */
        public AWSRegions: Array<string> = new Array<string>();
        /**
         * AWSRole is used for the EC2 join method and is the the ARN of the AWS
         *  role that the auth server will assume in order to call the ec2 API.
         */
        public AWSRole: string = "";
        /**
         * AWSARN is used for the IAM join method, the AWS identity of joining nodes
         *  must match this ARN. Supports wildcards "*" and "?".
         */
        public AWSARN: string = "";

        // Decodes TokenRule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TokenRule {
            return TokenRule.decode(new DataView(buf));
        }

        // Decodes TokenRule from a DataView
        static decode(view: DataView): TokenRule {
            const decoder = new __proto.Decoder(view);
            const obj = new TokenRule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AWSAccount = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AWSRegions.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.AWSRole = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.AWSARN = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TokenRule

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AWSAccount.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSAccount.length) +
                      this.AWSAccount.length
                    : 0;

            size += __size_string_repeated(this.AWSRegions);

            size +=
                this.AWSRole.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSRole.length) +
                      this.AWSRole.length
                    : 0;
            size +=
                this.AWSARN.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSARN.length) +
                      this.AWSARN.length
                    : 0;

            return size;
        }

        // Encodes TokenRule to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TokenRule to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AWSAccount.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AWSAccount.length);
                encoder.string(this.AWSAccount);
            }

            if (this.AWSRegions.length > 0) {
                for (let n: i32 = 0; n < this.AWSRegions.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.AWSRegions[n].length);
                    encoder.string(this.AWSRegions[n]);
                }
            }

            if (this.AWSRole.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.AWSRole.length);
                encoder.string(this.AWSRole);
            }
            if (this.AWSARN.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AWSARN.length);
                encoder.string(this.AWSARN);
            }

            return buf;
        } // encode TokenRule
    } // TokenRule

    // ProvisionTokenSpecV2 is a specification for V2 token
    export class ProvisionTokenSpecV2 {
        /**
         * Roles is a list of roles associated with the token,
         *  that will be converted to metadata in the SSH and X509
         *  certificates issued to the user of the token
         */
        public Roles: Array<string> = new Array<string>();
        /**
         * Allow is a list of TokenRules, nodes using this token must match one
         *  allow rule to use this token.
         */
        public Allow: Array<types.TokenRule> = new Array<types.TokenRule>();
        /**
         * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
         *  to join the cluster with this token.
         */
        public AWSIIDTTL: i64;
        /**
         * JoinMethod is the joining method required in order to use this token.
         *  Supported joining methods include "token", "ec2", and "iam".
         */
        public JoinMethod: string = "";

        // Decodes ProvisionTokenSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenSpecV2 {
            return ProvisionTokenSpecV2.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenSpecV2 from a DataView
        static decode(view: DataView): ProvisionTokenSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Allow.push(
                            types.TokenRule.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.AWSIIDTTL = decoder.int64();
                        break;
                    }
                    case 4: {
                        obj.JoinMethod = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.AWSIIDTTL == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.AWSIIDTTL);
            size +=
                this.JoinMethod.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.JoinMethod.length) +
                      this.JoinMethod.length
                    : 0;

            return size;
        }

        // Encodes ProvisionTokenSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.Allow[n].encodeU8Array(encoder);
                }
            }

            if (this.AWSIIDTTL != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.AWSIIDTTL);
            }
            if (this.JoinMethod.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.JoinMethod.length);
                encoder.string(this.JoinMethod);
            }

            return buf;
        } // encode ProvisionTokenSpecV2
    } // ProvisionTokenSpecV2

    // StaticTokensV2 implements the StaticTokens interface.
    export class StaticTokensV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a provisioning token V2 spec
        public Spec: types.StaticTokensSpecV2 = new types.StaticTokensSpecV2();

        // Decodes StaticTokensV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StaticTokensV2 {
            return StaticTokensV2.decode(new DataView(buf));
        }

        // Decodes StaticTokensV2 from a DataView
        static decode(view: DataView): StaticTokensV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new StaticTokensV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.StaticTokensSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StaticTokensV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.StaticTokensSpecV2 = this
                    .Spec as types.StaticTokensSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StaticTokensV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StaticTokensV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.StaticTokensSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode StaticTokensV2
    } // StaticTokensV2

    // StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
    export class StaticTokensSpecV2 {
        /**
         * StaticTokens is a list of tokens that can be used to add nodes to the
         *  cluster.
         */
        public StaticTokens: Array<types.ProvisionTokenV1> =
            new Array<types.ProvisionTokenV1>();

        // Decodes StaticTokensSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StaticTokensSpecV2 {
            return StaticTokensSpecV2.decode(new DataView(buf));
        }

        // Decodes StaticTokensSpecV2 from a DataView
        static decode(view: DataView): StaticTokensSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new StaticTokensSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.StaticTokens.push(
                            types.ProvisionTokenV1.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StaticTokensSpecV2

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.StaticTokens.length; n++) {
                const messageSize = this.StaticTokens[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StaticTokensSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StaticTokensSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.StaticTokens.length; n++) {
                const messageSize = this.StaticTokens[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.StaticTokens[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode StaticTokensSpecV2
    } // StaticTokensSpecV2

    // ClusterNameV2 implements the ClusterName interface.
    export class ClusterNameV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a cluster name V2 spec
        public Spec: types.ClusterNameSpecV2 = new types.ClusterNameSpecV2();

        // Decodes ClusterNameV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNameV2 {
            return ClusterNameV2.decode(new DataView(buf));
        }

        // Decodes ClusterNameV2 from a DataView
        static decode(view: DataView): ClusterNameV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNameV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterNameSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNameV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterNameSpecV2 = this
                    .Spec as types.ClusterNameSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterNameV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNameV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterNameSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ClusterNameV2
    } // ClusterNameV2

    // ClusterNameSpecV2 is the actual data we care about for ClusterName.
    export class ClusterNameSpecV2 {
        /**
         * ClusterName is the name of the cluster. Changing this value once the
         *  cluster is setup can and will cause catastrophic problems.
         */
        public ClusterName: string = "";
        /**
         * ClusterID is the unique cluster ID that is set once during the first
         *  auth server startup.
         */
        public ClusterID: string = "";

        // Decodes ClusterNameSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNameSpecV2 {
            return ClusterNameSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterNameSpecV2 from a DataView
        static decode(view: DataView): ClusterNameSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNameSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNameSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;
            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;

            return size;
        }

        // Encodes ClusterNameSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNameSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }
            if (this.ClusterID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }

            return buf;
        } // encode ClusterNameSpecV2
    } // ClusterNameSpecV2

    // ClusterAuditConfigV2 represents audit log settings in the cluster.
    export class ClusterAuditConfigV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is a resource version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a ClusterAuditConfig specification
        public Spec: types.ClusterAuditConfigSpecV2 =
            new types.ClusterAuditConfigSpecV2();

        // Decodes ClusterAuditConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterAuditConfigV2 {
            return ClusterAuditConfigV2.decode(new DataView(buf));
        }

        // Decodes ClusterAuditConfigV2 from a DataView
        static decode(view: DataView): ClusterAuditConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterAuditConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterAuditConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterAuditConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterAuditConfigSpecV2 = this
                    .Spec as types.ClusterAuditConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterAuditConfigV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterAuditConfigV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterAuditConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ClusterAuditConfigV2
    } // ClusterAuditConfigV2

    /**
     * ClusterAuditConfigSpecV2 is the actual data we care about
     *  for ClusterAuditConfig.
     */
    export class ClusterAuditConfigSpecV2 {
        // Type is audit backend type
        public Type: string = "";
        // Region is a region setting for audit sessions used by cloud providers
        public Region: string = "";
        // AuditSessionsURI is a parameter where to upload sessions
        public AuditSessionsURI: string = "";
        /**
         * AuditEventsURI is a parameter with all supported outputs
         *  for audit events
         */
        public AuditEventsURI: wrappers.StringValues =
            new wrappers.StringValues();
        // EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
        public EnableContinuousBackups: bool;
        // EnableAutoScaling is used to enable (or disable) auto scaling policy.
        public EnableAutoScaling: bool;
        // ReadMaxCapacity is the maximum provisioned read capacity.
        public ReadMaxCapacity: i64;
        // ReadMinCapacity is the minimum provisioned read capacity.
        public ReadMinCapacity: i64;
        // ReadTargetValue is the ratio of consumed read to provisioned capacity.
        public ReadTargetValue: f64;
        // WriteMaxCapacity is the maximum provisioned write capacity.
        public WriteMaxCapacity: i64;
        // WriteMinCapacity is the minimum provisioned write capacity.
        public WriteMinCapacity: i64;
        // WriteTargetValue is the ratio of consumed write to provisioned capacity.
        public WriteTargetValue: f64;
        // RetentionPeriod is the retention period for audit events.
        public RetentionPeriod: i64;

        // Decodes ClusterAuditConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterAuditConfigSpecV2 {
            return ClusterAuditConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterAuditConfigSpecV2 from a DataView
        static decode(view: DataView): ClusterAuditConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterAuditConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Region = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.AuditSessionsURI = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.AuditEventsURI = wrappers.StringValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.EnableContinuousBackups = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.EnableAutoScaling = decoder.bool();
                        break;
                    }
                    case 8: {
                        obj.ReadMaxCapacity = decoder.int64();
                        break;
                    }
                    case 9: {
                        obj.ReadMinCapacity = decoder.int64();
                        break;
                    }
                    case 10: {
                        obj.ReadTargetValue = decoder.double();
                        break;
                    }
                    case 11: {
                        obj.WriteMaxCapacity = decoder.int64();
                        break;
                    }
                    case 12: {
                        obj.WriteMinCapacity = decoder.int64();
                        break;
                    }
                    case 13: {
                        obj.WriteTargetValue = decoder.double();
                        break;
                    }
                    case 14: {
                        obj.RetentionPeriod = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterAuditConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.Region.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Region.length) +
                      this.Region.length
                    : 0;
            size +=
                this.AuditSessionsURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AuditSessionsURI.length) +
                      this.AuditSessionsURI.length
                    : 0;

            if (this.AuditEventsURI != null) {
                const f: wrappers.StringValues = this
                    .AuditEventsURI as wrappers.StringValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.EnableContinuousBackups == 0 ? 0 : 1 + 1;
            size += this.EnableAutoScaling == 0 ? 0 : 1 + 1;
            size +=
                this.ReadMaxCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ReadMaxCapacity);
            size +=
                this.ReadMinCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ReadMinCapacity);
            size += this.ReadTargetValue == 0 ? 0 : 1 + 8;
            size +=
                this.WriteMaxCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WriteMaxCapacity);
            size +=
                this.WriteMinCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WriteMinCapacity);
            size += this.WriteTargetValue == 0 ? 0 : 1 + 8;
            size +=
                this.RetentionPeriod == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.RetentionPeriod);

            return size;
        }

        // Encodes ClusterAuditConfigSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterAuditConfigSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.Region.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Region.length);
                encoder.string(this.Region);
            }
            if (this.AuditSessionsURI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.AuditSessionsURI.length);
                encoder.string(this.AuditSessionsURI);
            }

            if (this.AuditEventsURI != null) {
                const f = this.AuditEventsURI as wrappers.StringValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.EnableContinuousBackups != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.EnableContinuousBackups);
            }
            if (this.EnableAutoScaling != 0) {
                encoder.uint32(0x38);
                encoder.bool(this.EnableAutoScaling);
            }
            if (this.ReadMaxCapacity != 0) {
                encoder.uint32(0x40);
                encoder.int64(this.ReadMaxCapacity);
            }
            if (this.ReadMinCapacity != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.ReadMinCapacity);
            }
            if (this.ReadTargetValue != 0) {
                encoder.uint32(0x51);
                encoder.double(this.ReadTargetValue);
            }
            if (this.WriteMaxCapacity != 0) {
                encoder.uint32(0x58);
                encoder.int64(this.WriteMaxCapacity);
            }
            if (this.WriteMinCapacity != 0) {
                encoder.uint32(0x60);
                encoder.int64(this.WriteMinCapacity);
            }
            if (this.WriteTargetValue != 0) {
                encoder.uint32(0x69);
                encoder.double(this.WriteTargetValue);
            }
            if (this.RetentionPeriod != 0) {
                encoder.uint32(0x70);
                encoder.int64(this.RetentionPeriod);
            }

            return buf;
        } // encode ClusterAuditConfigSpecV2
    } // ClusterAuditConfigSpecV2

    // ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
    export class ClusterNetworkingConfigV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is a resource version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a ClusterNetworkingConfig specification
        public Spec: types.ClusterNetworkingConfigSpecV2 =
            new types.ClusterNetworkingConfigSpecV2();

        // Decodes ClusterNetworkingConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNetworkingConfigV2 {
            return ClusterNetworkingConfigV2.decode(new DataView(buf));
        }

        // Decodes ClusterNetworkingConfigV2 from a DataView
        static decode(view: DataView): ClusterNetworkingConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNetworkingConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterNetworkingConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNetworkingConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterNetworkingConfigSpecV2 = this
                    .Spec as types.ClusterNetworkingConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterNetworkingConfigV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNetworkingConfigV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterNetworkingConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ClusterNetworkingConfigV2
    } // ClusterNetworkingConfigV2

    /**
     * ClusterNetworkingConfigSpecV2 is the actual data we care about
     *  for ClusterNetworkingConfig.
     */
    export class ClusterNetworkingConfigSpecV2 {
        /**
         * ClientIdleTimeout sets global cluster default setting for client idle
         *  timeouts.
         */
        public ClientIdleTimeout: i64;
        /**
         * KeepAliveInterval is the interval at which the server sends keep-alive messages
         *  to the client.
         */
        public KeepAliveInterval: i64;
        /**
         * KeepAliveCountMax is the number of keep-alive messages that can be
         *  missed before the server disconnects the connection to the client.
         */
        public KeepAliveCountMax: i64;
        /**
         * SessionControlTimeout is the session control lease expiry and defines
         *  the upper limit of how long a node may be out of contact with the auth
         *  server before it begins terminating controlled sessions.
         */
        public SessionControlTimeout: i64;
        // ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
        public ClientIdleTimeoutMessage: string = "";
        /**
         * WebIdleTimeout sets global cluster default setting for the web UI idle
         *  timeouts.
         */
        public WebIdleTimeout: i64;
        // ProxyListenerMode is proxy listener mode used by Teleport Proxies.
        public ProxyListenerMode: u32;
        // RoutingStrategy determines the strategy used to route to nodes.
        public RoutingStrategy: u32;

        // Decodes ClusterNetworkingConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ClusterNetworkingConfigSpecV2 {
            return ClusterNetworkingConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterNetworkingConfigSpecV2 from a DataView
        static decode(view: DataView): ClusterNetworkingConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNetworkingConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClientIdleTimeout = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.KeepAliveInterval = decoder.int64();
                        break;
                    }
                    case 3: {
                        obj.KeepAliveCountMax = decoder.int64();
                        break;
                    }
                    case 4: {
                        obj.SessionControlTimeout = decoder.int64();
                        break;
                    }
                    case 5: {
                        obj.ClientIdleTimeoutMessage = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.WebIdleTimeout = decoder.int64();
                        break;
                    }
                    case 7: {
                        obj.ProxyListenerMode = decoder.uint32();
                        break;
                    }
                    case 8: {
                        obj.RoutingStrategy = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNetworkingConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClientIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);
            size +=
                this.KeepAliveInterval == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.KeepAliveInterval);
            size +=
                this.KeepAliveCountMax == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.KeepAliveCountMax);
            size +=
                this.SessionControlTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.SessionControlTimeout);
            size +=
                this.ClientIdleTimeoutMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.ClientIdleTimeoutMessage.length
                      ) +
                      this.ClientIdleTimeoutMessage.length
                    : 0;
            size +=
                this.WebIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WebIdleTimeout);
            size +=
                this.ProxyListenerMode == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.ProxyListenerMode);
            size +=
                this.RoutingStrategy == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.RoutingStrategy);

            return size;
        }

        // Encodes ClusterNetworkingConfigSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNetworkingConfigSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClientIdleTimeout != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.ClientIdleTimeout);
            }
            if (this.KeepAliveInterval != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.KeepAliveInterval);
            }
            if (this.KeepAliveCountMax != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.KeepAliveCountMax);
            }
            if (this.SessionControlTimeout != 0) {
                encoder.uint32(0x20);
                encoder.int64(this.SessionControlTimeout);
            }
            if (this.ClientIdleTimeoutMessage.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ClientIdleTimeoutMessage.length);
                encoder.string(this.ClientIdleTimeoutMessage);
            }
            if (this.WebIdleTimeout != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.WebIdleTimeout);
            }
            if (this.ProxyListenerMode != 0) {
                encoder.uint32(0x38);
                encoder.uint32(this.ProxyListenerMode);
            }
            if (this.RoutingStrategy != 0) {
                encoder.uint32(0x40);
                encoder.uint32(this.RoutingStrategy);
            }

            return buf;
        } // encode ClusterNetworkingConfigSpecV2
    } // ClusterNetworkingConfigSpecV2

    // SessionRecordingConfigV2 contains session recording configuration.
    export class SessionRecordingConfigV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is a resource version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a SessionRecordingConfig specification
        public Spec: types.SessionRecordingConfigSpecV2 =
            new types.SessionRecordingConfigSpecV2();

        // Decodes SessionRecordingConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionRecordingConfigV2 {
            return SessionRecordingConfigV2.decode(new DataView(buf));
        }

        // Decodes SessionRecordingConfigV2 from a DataView
        static decode(view: DataView): SessionRecordingConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionRecordingConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SessionRecordingConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionRecordingConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SessionRecordingConfigSpecV2 = this
                    .Spec as types.SessionRecordingConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionRecordingConfigV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionRecordingConfigV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SessionRecordingConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SessionRecordingConfigV2
    } // SessionRecordingConfigV2

    /**
     * SessionRecordingConfigSpecV2 is the actual data we care about
     *  for SessionRecordingConfig.
     */
    export class SessionRecordingConfigSpecV2 {
        // Mode controls where (or if) the session is recorded.
        public Mode: string = "";
        /**
         * ProxyChecksHostKeys is used to control if the proxy will check host keys
         *  when in recording mode.
         */
        public ProxyChecksHostKeys: types.BoolValue = new types.BoolValue();

        // Decodes SessionRecordingConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): SessionRecordingConfigSpecV2 {
            return SessionRecordingConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes SessionRecordingConfigSpecV2 from a DataView
        static decode(view: DataView): SessionRecordingConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionRecordingConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Mode = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ProxyChecksHostKeys = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionRecordingConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Mode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Mode.length) +
                      this.Mode.length
                    : 0;

            if (this.ProxyChecksHostKeys != null) {
                const f: types.BoolValue = this
                    .ProxyChecksHostKeys as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionRecordingConfigSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionRecordingConfigSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Mode.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Mode.length);
                encoder.string(this.Mode);
            }

            if (this.ProxyChecksHostKeys != null) {
                const f = this.ProxyChecksHostKeys as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SessionRecordingConfigSpecV2
    } // SessionRecordingConfigSpecV2

    // AuthPreferenceV2 implements the AuthPreference interface.
    export class AuthPreferenceV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is a resource version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an AuthPreference specification
        public Spec: types.AuthPreferenceSpecV2 =
            new types.AuthPreferenceSpecV2();

        // Decodes AuthPreferenceV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthPreferenceV2 {
            return AuthPreferenceV2.decode(new DataView(buf));
        }

        // Decodes AuthPreferenceV2 from a DataView
        static decode(view: DataView): AuthPreferenceV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthPreferenceV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AuthPreferenceSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthPreferenceV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AuthPreferenceSpecV2 = this
                    .Spec as types.AuthPreferenceSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthPreferenceV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthPreferenceV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AuthPreferenceSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AuthPreferenceV2
    } // AuthPreferenceV2

    // AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
    export class AuthPreferenceSpecV2 {
        // Type is the type of authentication.
        public Type: string = "";
        // SecondFactor is the type of second factor.
        public SecondFactor: string = "";
        /**
         * ConnectorName is the name of the OIDC or SAML connector. If this value is
         *  not set the first connector in the backend will be used.
         */
        public ConnectorName: string = "";
        // U2F are the settings for the U2F device.
        public U2F: types.U2F = new types.U2F();
        /**
         * RequireSessionMFA causes all sessions in this cluster to require MFA
         *  checks.
         */
        public RequireSessionMFA: bool;
        /**
         * DisconnectExpiredCert provides disconnect expired certificate setting -
         *  if true, connections with expired client certificates will get disconnected
         */
        public DisconnectExpiredCert: types.BoolValue = new types.BoolValue();
        // AllowLocalAuth is true if local authentication is enabled.
        public AllowLocalAuth: types.BoolValue = new types.BoolValue();
        public MessageOfTheDay: string = "";
        // LockingMode is the cluster-wide locking mode default.
        public LockingMode: string = "";
        // Webauthn are the settings for server-side Web Authentication support.
        public Webauthn: types.Webauthn = new types.Webauthn();

        // Decodes AuthPreferenceSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthPreferenceSpecV2 {
            return AuthPreferenceSpecV2.decode(new DataView(buf));
        }

        // Decodes AuthPreferenceSpecV2 from a DataView
        static decode(view: DataView): AuthPreferenceSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthPreferenceSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SecondFactor = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ConnectorName = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.U2F = types.U2F.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.RequireSessionMFA = decoder.bool();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.DisconnectExpiredCert = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.AllowLocalAuth = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        obj.MessageOfTheDay = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.LockingMode = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Webauthn = types.Webauthn.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthPreferenceSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.SecondFactor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SecondFactor.length) +
                      this.SecondFactor.length
                    : 0;
            size +=
                this.ConnectorName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ConnectorName.length) +
                      this.ConnectorName.length
                    : 0;

            if (this.U2F != null) {
                const f: types.U2F = this.U2F as types.U2F;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;

            if (this.DisconnectExpiredCert != null) {
                const f: types.BoolValue = this
                    .DisconnectExpiredCert as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AllowLocalAuth != null) {
                const f: types.BoolValue = this
                    .AllowLocalAuth as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.MessageOfTheDay.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.MessageOfTheDay.length) +
                      this.MessageOfTheDay.length
                    : 0;
            size +=
                this.LockingMode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LockingMode.length) +
                      this.LockingMode.length
                    : 0;

            if (this.Webauthn != null) {
                const f: types.Webauthn = this.Webauthn as types.Webauthn;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthPreferenceSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthPreferenceSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.SecondFactor.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SecondFactor.length);
                encoder.string(this.SecondFactor);
            }
            if (this.ConnectorName.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ConnectorName.length);
                encoder.string(this.ConnectorName);
            }

            if (this.U2F != null) {
                const f = this.U2F as types.U2F;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RequireSessionMFA != 0) {
                encoder.uint32(0x28);
                encoder.bool(this.RequireSessionMFA);
            }

            if (this.DisconnectExpiredCert != null) {
                const f = this.DisconnectExpiredCert as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AllowLocalAuth != null) {
                const f = this.AllowLocalAuth as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.MessageOfTheDay.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.MessageOfTheDay.length);
                encoder.string(this.MessageOfTheDay);
            }
            if (this.LockingMode.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.LockingMode.length);
                encoder.string(this.LockingMode);
            }

            if (this.Webauthn != null) {
                const f = this.Webauthn as types.Webauthn;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AuthPreferenceSpecV2
    } // AuthPreferenceSpecV2

    // U2F defines settings for U2F device.
    export class U2F {
        // AppID returns the application ID for universal second factor.
        public AppID: string = "";
        // Facets returns the facets for universal second factor.
        public Facets: Array<string> = new Array<string>();
        /**
         * DeviceAttestationCAs contains the trusted attestation CAs for U2F
         *  devices.
         */
        public DeviceAttestationCAs: Array<string> = new Array<string>();

        // Decodes U2F from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2F {
            return U2F.decode(new DataView(buf));
        }

        // Decodes U2F from a DataView
        static decode(view: DataView): U2F {
            const decoder = new __proto.Decoder(view);
            const obj = new U2F();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AppID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Facets.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.DeviceAttestationCAs.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2F

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AppID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppID.length) +
                      this.AppID.length
                    : 0;

            size += __size_string_repeated(this.Facets);

            size += __size_string_repeated(this.DeviceAttestationCAs);

            return size;
        }

        // Encodes U2F to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2F to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AppID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AppID.length);
                encoder.string(this.AppID);
            }

            if (this.Facets.length > 0) {
                for (let n: i32 = 0; n < this.Facets.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Facets[n].length);
                    encoder.string(this.Facets[n]);
                }
            }

            if (this.DeviceAttestationCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.DeviceAttestationCAs.length;
                    n++
                ) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.DeviceAttestationCAs[n].length);
                    encoder.string(this.DeviceAttestationCAs[n]);
                }
            }

            return buf;
        } // encode U2F
    } // U2F

    /**
     * Webauthn defines user-visible settings for server-side Web Authentication
     *  support.
     */
    export class Webauthn {
        /**
         * RPID is the ID of the Relying Party.
         *  It should be set to the domain name of the Teleport installation.
         *
         *  IMPORTANT: RPID must never change in the lifetime of the cluster, because
         *  it's recorded in the registration data on the WebAuthn device. If the
         *  RPID changes, all existing WebAuthn key registrations will become invalid
         *  and all users who use WebAuthn as the second factor will need to
         *  re-register.
         */
        public RPID: string = "";
        /**
         * Allow list of device attestation CAs in PEM format.
         *  If present, only devices whose attestation certificates match the
         *  certificates specified here may be registered (existing registrations are
         *  unchanged).
         *  If supplied in conjunction with AttestationDeniedCAs, then both
         *  conditions need to be true for registration to be allowed (the device
         *  MUST match an allowed CA and MUST NOT match a denied CA).
         *  By default all devices are allowed.
         */
        public AttestationAllowedCAs: Array<string> = new Array<string>();
        /**
         * Deny list of device attestation CAs in PEM format.
         *  If present, only devices whose attestation certificates don't match the
         *  certificates specified here may be registered (existing registrations are
         *  unchanged).
         *  If supplied in conjunction with AttestationAllowedCAs, then both
         *  conditions need to be true for registration to be allowed (the device
         *  MUST match an allowed CA and MUST NOT match a denied CA).
         *  By default no devices are denied.
         */
        public AttestationDeniedCAs: Array<string> = new Array<string>();
        /**
         * Disables Webauthn, regardless of other cluster settings.
         *  Allows fallback to pure U2F in clusters with second_factor:on or
         *  second_factor:optional.
         *  Must not be set for clusters with second_factor:webauthn.
         *  Temporary safety switch for Webauthn, to be removed in future versions of
         *  Teleport.
         *  DELETE IN 9.x, fallback not possible without U2F (codingllama).
         */
        public Disabled: bool;

        // Decodes Webauthn from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Webauthn {
            return Webauthn.decode(new DataView(buf));
        }

        // Decodes Webauthn from a DataView
        static decode(view: DataView): Webauthn {
            const decoder = new __proto.Decoder(view);
            const obj = new Webauthn();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RPID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AttestationAllowedCAs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.AttestationDeniedCAs.push(decoder.string());
                        break;
                    }
                    case 4: {
                        obj.Disabled = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Webauthn

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.RPID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RPID.length) +
                      this.RPID.length
                    : 0;

            size += __size_string_repeated(this.AttestationAllowedCAs);

            size += __size_string_repeated(this.AttestationDeniedCAs);

            size += this.Disabled == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes Webauthn to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Webauthn to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RPID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.RPID.length);
                encoder.string(this.RPID);
            }

            if (this.AttestationAllowedCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AttestationAllowedCAs.length;
                    n++
                ) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.AttestationAllowedCAs[n].length);
                    encoder.string(this.AttestationAllowedCAs[n]);
                }
            }

            if (this.AttestationDeniedCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AttestationDeniedCAs.length;
                    n++
                ) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.AttestationDeniedCAs[n].length);
                    encoder.string(this.AttestationDeniedCAs[n]);
                }
            }

            if (this.Disabled != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.Disabled);
            }

            return buf;
        } // encode Webauthn
    } // Webauthn

    // Namespace represents namespace resource specification
    export class Namespace {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a namespace spec
        public Spec: types.NamespaceSpec = new types.NamespaceSpec();

        // Decodes Namespace from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Namespace {
            return Namespace.decode(new DataView(buf));
        }

        // Decodes Namespace from a DataView
        static decode(view: DataView): Namespace {
            const decoder = new __proto.Decoder(view);
            const obj = new Namespace();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.NamespaceSpec.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Namespace

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.NamespaceSpec = this.Spec as types.NamespaceSpec;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Namespace to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Namespace to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.NamespaceSpec;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode Namespace
    } // Namespace

    // NamespaceSpec is a namespace specificateion
    export class NamespaceSpec {
        // Decodes NamespaceSpec from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NamespaceSpec {
            return NamespaceSpec.decode(new DataView(buf));
        }

        // Decodes NamespaceSpec from a DataView
        static decode(view: DataView): NamespaceSpec {
            const decoder = new __proto.Decoder(view);
            const obj = new NamespaceSpec();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NamespaceSpec

        public size(): u32 {
            let size: u32 = 0;

            return size;
        }

        // Encodes NamespaceSpec to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NamespaceSpec to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            return buf;
        } // encode NamespaceSpec
    } // NamespaceSpec

    export class UserTokenV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is a resource sub kind, used to define the type of user token.
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an resource specification
        public Spec: types.UserTokenSpecV3 = new types.UserTokenSpecV3();

        // Decodes UserTokenV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenV3 {
            return UserTokenV3.decode(new DataView(buf));
        }

        // Decodes UserTokenV3 from a DataView
        static decode(view: DataView): UserTokenV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserTokenSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserTokenSpecV3 = this
                    .Spec as types.UserTokenSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserTokenSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserTokenV3
    } // UserTokenV3

    export class UserTokenSpecV3 {
        // User is user name associated with this token
        public User: string = "";
        // URL is this token URL
        public URL: string = "";
        // Usage is an optional field that provides more information about how this token will be used.
        public Usage: u32;
        // Created holds information about when the token was created
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes UserTokenSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSpecV3 {
            return UserTokenSpecV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSpecV3 from a DataView
        static decode(view: DataView): UserTokenSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URL = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Usage = decoder.uint32();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.URL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URL.length) +
                      this.URL.length
                    : 0;
            size += this.Usage == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Usage);

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.URL.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URL.length);
                encoder.string(this.URL);
            }
            if (this.Usage != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.Usage);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserTokenSpecV3
    } // UserTokenSpecV3

    export class UserTokenSecretsV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an resource specification
        public Spec: types.UserTokenSecretsSpecV3 =
            new types.UserTokenSecretsSpecV3();

        // Decodes UserTokenSecretsV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSecretsV3 {
            return UserTokenSecretsV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSecretsV3 from a DataView
        static decode(view: DataView): UserTokenSecretsV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSecretsV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserTokenSecretsSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSecretsV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserTokenSecretsSpecV3 = this
                    .Spec as types.UserTokenSecretsSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSecretsV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSecretsV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserTokenSecretsSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserTokenSecretsV3
    } // UserTokenSecretsV3

    export class UserTokenSecretsSpecV3 {
        // OTPKey is is a secret value of one time password secret generator
        public OTPKey: string = "";
        // OTPKey is is a secret value of one time password secret generator
        public QRCode: string = "";
        // Created holds information about when the token was created
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes UserTokenSecretsSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSecretsSpecV3 {
            return UserTokenSecretsSpecV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSecretsSpecV3 from a DataView
        static decode(view: DataView): UserTokenSecretsSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSecretsSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.OTPKey = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.QRCode = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSecretsSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.OTPKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.OTPKey.length) +
                      this.OTPKey.length
                    : 0;
            size +=
                this.QRCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.QRCode.length) +
                      this.QRCode.length
                    : 0;

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSecretsSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSecretsSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.OTPKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.OTPKey.length);
                encoder.string(this.OTPKey);
            }
            if (this.QRCode.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.QRCode.length);
                encoder.string(this.QRCode);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserTokenSecretsSpecV3
    } // UserTokenSecretsSpecV3

    // AccessRequest represents an access request resource specification
    export class AccessRequestV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is AccessRequest metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an AccessRequest specification
        public Spec: types.AccessRequestSpecV3 =
            new types.AccessRequestSpecV3();

        // Decodes AccessRequestV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestV3 {
            return AccessRequestV3.decode(new DataView(buf));
        }

        // Decodes AccessRequestV3 from a DataView
        static decode(view: DataView): AccessRequestV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AccessRequestSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AccessRequestSpecV3 = this
                    .Spec as types.AccessRequestSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AccessRequestV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AccessRequestSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AccessRequestV3
    } // AccessRequestV3

    /**
     * AccessReviewThreshold describes a filter used to match access reviews,
     *  as well as approval/denial counts which trigger state-transitions.  This type
     *  can be used to describe policies such as "can be approved by 2 admins"
     *  or "can be denied by any non-contractor".
     */
    export class AccessReviewThreshold {
        // Name is the optional human-readable name of the threshold.
        public Name: string = "";
        /**
         * Filter is an optional predicate used to determine which reviews
         *  count toward this threshold.
         */
        public Filter: string = "";
        // Approve is the number of matching approvals needed for state-transition.
        public Approve: u32;
        // Deny is the number of denials needed for state-transition.
        public Deny: u32;

        // Decodes AccessReviewThreshold from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewThreshold {
            return AccessReviewThreshold.decode(new DataView(buf));
        }

        // Decodes AccessReviewThreshold from a DataView
        static decode(view: DataView): AccessReviewThreshold {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewThreshold();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Filter = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Approve = decoder.uint32();
                        break;
                    }
                    case 4: {
                        obj.Deny = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewThreshold

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Filter.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Filter.length) +
                      this.Filter.length
                    : 0;
            size +=
                this.Approve == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Approve);
            size += this.Deny == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Deny);

            return size;
        }

        // Encodes AccessReviewThreshold to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewThreshold to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Filter.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Filter.length);
                encoder.string(this.Filter);
            }
            if (this.Approve != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.Approve);
            }
            if (this.Deny != 0) {
                encoder.uint32(0x20);
                encoder.uint32(this.Deny);
            }

            return buf;
        } // encode AccessReviewThreshold
    } // AccessReviewThreshold

    // AccessReview is a review to be applied to an access request.
    export class AccessReview {
        // Author is the teleport username of the review author.
        public Author: string = "";
        // Roles is a list used for role-subselection (not yet fully supported).
        public Roles: Array<string> = new Array<string>();
        // ProposedState is the proposed state (must be APPROVED or DENIED).
        public ProposedState: u32;
        /**
         * Reason is an optional human-readable reason for why the above state
         *  is being proposed.
         */
        public Reason: string = "";
        // Created is the time at which the review was created.
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Annotations is the proposed value of the request's resolve_annotations field.
        public Annotations: wrappers.LabelValues = new wrappers.LabelValues();
        /**
         * ThresholdIndexes stores the indexes of thresholds which this review matches
         *  (internal use only).
         */
        public ThresholdIndexes: Array<u32> = new Array<u32>();

        // Decodes AccessReview from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReview {
            return AccessReview.decode(new DataView(buf));
        }

        // Decodes AccessReview from a DataView
        static decode(view: DataView): AccessReview {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReview();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Author = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.ProposedState = decoder.uint32();
                        break;
                    }
                    case 4: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Annotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.ThresholdIndexes.push(decoder.uint32());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReview

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Author.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Author.length) +
                      this.Author.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            size +=
                this.ProposedState == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.ProposedState);
            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Annotations != null) {
                const f: wrappers.LabelValues = this
                    .Annotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_uint32_repeated(this.ThresholdIndexes);

            return size;
        }

        // Encodes AccessReview to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReview to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Author.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Author.length);
                encoder.string(this.Author);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.ProposedState != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.ProposedState);
            }
            if (this.Reason.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Annotations != null) {
                const f = this.Annotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ThresholdIndexes.length > 0) {
                for (let n: i32 = 0; n < this.ThresholdIndexes.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.ThresholdIndexes[n]);
                }
            }

            return buf;
        } // encode AccessReview
    } // AccessReview

    /**
     * AccessReviewSubmission encodes the necessary parameters for submitting
     *  a new access review.
     */
    export class AccessReviewSubmission {
        // RequestID is the unique ID of the request to be reviewed.
        public RequestID: string = "";
        // Review is the review to be applied.
        public Review: types.AccessReview = new types.AccessReview();

        // Decodes AccessReviewSubmission from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewSubmission {
            return AccessReviewSubmission.decode(new DataView(buf));
        }

        // Decodes AccessReviewSubmission from a DataView
        static decode(view: DataView): AccessReviewSubmission {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewSubmission();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RequestID = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Review = types.AccessReview.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewSubmission

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.RequestID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestID.length) +
                      this.RequestID.length
                    : 0;

            if (this.Review != null) {
                const f: types.AccessReview = this.Review as types.AccessReview;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AccessReviewSubmission to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewSubmission to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RequestID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.RequestID.length);
                encoder.string(this.RequestID);
            }

            if (this.Review != null) {
                const f = this.Review as types.AccessReview;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AccessReviewSubmission
    } // AccessReviewSubmission

    /**
     * ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
     *  must pass for the set to be considered to have passed (i.e. this is an `or` operator).
     */
    export class ThresholdIndexSet {
        // Indexes are the indexes of thresholds which relate to the role.
        public Indexes: Array<u32> = new Array<u32>();

        // Decodes ThresholdIndexSet from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ThresholdIndexSet {
            return ThresholdIndexSet.decode(new DataView(buf));
        }

        // Decodes ThresholdIndexSet from a DataView
        static decode(view: DataView): ThresholdIndexSet {
            const decoder = new __proto.Decoder(view);
            const obj = new ThresholdIndexSet();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Indexes.push(decoder.uint32());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ThresholdIndexSet

        public size(): u32 {
            let size: u32 = 0;

            size += __size_uint32_repeated(this.Indexes);

            return size;
        }

        // Encodes ThresholdIndexSet to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ThresholdIndexSet to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Indexes.length > 0) {
                for (let n: i32 = 0; n < this.Indexes.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Indexes[n]);
                }
            }

            return buf;
        } // encode ThresholdIndexSet
    } // ThresholdIndexSet

    /**
     * ThresholdIndexSets is a list of threshold index sets.  Each of the individual
     *  sets must pass (i.e. this is an `and` operator).
     */
    export class ThresholdIndexSets {
        // Sets are the sets that make up this group.
        public Sets: Array<types.ThresholdIndexSet> =
            new Array<types.ThresholdIndexSet>();

        // Decodes ThresholdIndexSets from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ThresholdIndexSets {
            return ThresholdIndexSets.decode(new DataView(buf));
        }

        // Decodes ThresholdIndexSets from a DataView
        static decode(view: DataView): ThresholdIndexSets {
            const decoder = new __proto.Decoder(view);
            const obj = new ThresholdIndexSets();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Sets.push(
                            types.ThresholdIndexSet.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ThresholdIndexSets

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Sets.length; n++) {
                const messageSize = this.Sets[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ThresholdIndexSets to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ThresholdIndexSets to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Sets.length; n++) {
                const messageSize = this.Sets[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Sets[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ThresholdIndexSets
    } // ThresholdIndexSets

    // AccessRequestSpec is the specification for AccessRequest
    export class AccessRequestSpecV3 {
        // User is the name of the user to whom the roles will be applied.
        public User: string = "";
        // Roles is the name of the roles being requested.
        public Roles: Array<string> = new Array<string>();
        // State is the current state of this access request.
        public State: u32;
        /**
         * Created encodes the time at which the request was registered with the auth
         *  server.
         */
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * Expires constrains the maximum lifetime of any login session for which this
         *  request is active.
         */
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // RequestReason is an optional message explaining the reason for the request.
        public RequestReason: string = "";
        /**
         * ResolveReason is an optional message explaining the reason for the resolution
         *  of the request (approval, denail, etc...).
         */
        public ResolveReason: string = "";
        /**
         * ResolveAnnotations is a set of arbitrary values received from plugins or other
         *  resolving parties during approval/denial.  Importantly, these annotations are
         *  included in the access_request.update event, allowing plugins to propagate
         *  arbitrary structured data to the audit log.
         */
        public ResolveAnnotations: wrappers.LabelValues =
            new wrappers.LabelValues();
        /**
         * SystemAnnotations is a set of programmatically generated annotations attached
         *  to pending access requests by teleport.  These annotations are generated by
         *  applying variable interpolation to the RoleConditions.Request.Annotations block
         *  of a user's role(s).  These annotations serve as a mechanism for administrators
         *  to pass extra information to plugins when they process pending access requests.
         */
        public SystemAnnotations: wrappers.LabelValues =
            new wrappers.LabelValues();
        /**
         * Thresholds is a list of review thresholds relevant to this request.  Order must be
         *  preserved, as thresholds are referenced by index (internal use only).
         */
        public Thresholds: Array<types.AccessReviewThreshold> =
            new Array<types.AccessReviewThreshold>();
        /**
         * RoleThresholdMapping encodes the relationship between the requested roles and
         *  the review threshold requirements for the given role (internal use only).
         *  By storing a representation of which thresholds must pass for each requested role, we
         *  both eliminate the need to cache the requestor's roles directly, and allow future
         *  versions of teleport to become smarter about calculating more granular requirements
         *  in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
         *  Storing this relationship on the request is necessary in order to avoid unexpected or
         *  inconsistent behavior due to review submission timing.
         */
        public RoleThresholdMapping: Map<string, types.ThresholdIndexSets> =
            new Map<string, types.ThresholdIndexSets>();
        // Reviews is a list of reviews applied to this request (internal use only).
        public Reviews: Array<types.AccessReview> =
            new Array<types.AccessReview>();
        /**
         * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
         *  that is not a requirement.
         */
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessRequestSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestSpecV3 {
            return AccessRequestSpecV3.decode(new DataView(buf));
        }

        // Decodes AccessRequestSpecV3 from a DataView
        static decode(view: DataView): AccessRequestSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.State = decoder.uint32();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.RequestReason = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ResolveReason = decoder.string();
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.ResolveAnnotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.SystemAnnotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Thresholds.push(
                            types.AccessReviewThreshold.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_ThresholdIndexSets(
                            decoder,
                            length,
                            obj.RoleThresholdMapping
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Reviews.push(
                            types.AccessReview.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RequestReason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestReason.length) +
                      this.RequestReason.length
                    : 0;
            size +=
                this.ResolveReason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResolveReason.length) +
                      this.ResolveReason.length
                    : 0;

            if (this.ResolveAnnotations != null) {
                const f: wrappers.LabelValues = this
                    .ResolveAnnotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SystemAnnotations != null) {
                const f: wrappers.LabelValues = this
                    .SystemAnnotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleThresholdMapping.size > 0) {
                const keys = this.RoleThresholdMapping.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.RoleThresholdMapping.get(key);
                    const itemSize =
                        __sizeMapEntry_string_types_ThresholdIndexSets(
                            key,
                            value
                        );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            for (let n: i32 = 0; n < this.Reviews.length; n++) {
                const messageSize = this.Reviews[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessRequestSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.State != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.State);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RequestReason.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.RequestReason.length);
                encoder.string(this.RequestReason);
            }
            if (this.ResolveReason.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ResolveReason.length);
                encoder.string(this.ResolveReason);
            }

            if (this.ResolveAnnotations != null) {
                const f = this.ResolveAnnotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SystemAnnotations != null) {
                const f = this.SystemAnnotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.Thresholds[n].encodeU8Array(encoder);
                }
            }

            if (this.RoleThresholdMapping.size > 0) {
                const keys = this.RoleThresholdMapping.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.RoleThresholdMapping.get(key);
                    const size = __sizeMapEntry_string_types_ThresholdIndexSets(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x5a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            for (let n: i32 = 0; n < this.Reviews.length; n++) {
                const messageSize = this.Reviews[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    this.Reviews[n].encodeU8Array(encoder);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessRequestSpecV3
    } // AccessRequestSpecV3

    // AccessRequestFilter encodes filter params for access requests.
    export class AccessRequestFilter {
        // ID specifies a request ID if set.
        public ID: string = "";
        // User specifies a username if set.
        public User: string = "";
        // RequestState filters for requests in a specific state.
        public State: u32;

        // Decodes AccessRequestFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestFilter {
            return AccessRequestFilter.decode(new DataView(buf));
        }

        // Decodes AccessRequestFilter from a DataView
        static decode(view: DataView): AccessRequestFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.State = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);

            return size;
        }

        // Encodes AccessRequestFilter to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestFilter to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.User.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.State != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.State);
            }

            return buf;
        } // encode AccessRequestFilter
    } // AccessRequestFilter

    /**
     * AccessCapabilities is a summary of capabilities that a user
     *  is granted via their dynamic access privileges which may not be
     *  calculable by directly examining the user's own static roles.
     */
    export class AccessCapabilities {
        // RequestableRoles is a list of existent roles which the user is allowed to request.
        public RequestableRoles: Array<string> = new Array<string>();
        // SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessCapabilities from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessCapabilities {
            return AccessCapabilities.decode(new DataView(buf));
        }

        // Decodes AccessCapabilities from a DataView
        static decode(view: DataView): AccessCapabilities {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessCapabilities();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RequestableRoles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessCapabilities

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.RequestableRoles);

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessCapabilities to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessCapabilities to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RequestableRoles.length > 0) {
                for (let n: i32 = 0; n < this.RequestableRoles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.RequestableRoles[n].length);
                    encoder.string(this.RequestableRoles[n]);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessCapabilities
    } // AccessCapabilities

    // AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
    export class AccessCapabilitiesRequest {
        /**
         * User is the name of the user whose capabilities we are interested in (defaults to
         *  the caller's own username).
         */
        public User: string = "";
        /**
         * RequestableRoles is a flag indicating that we would like to view the list of roles
         *  that the user is able to request.
         */
        public RequestableRoles: bool;
        /**
         * SuggestedReviewers is a flag indicating that we would like to view the list of all
         *  reviewers which are suggested by the user's roles.
         */
        public SuggestedReviewers: bool;

        // Decodes AccessCapabilitiesRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessCapabilitiesRequest {
            return AccessCapabilitiesRequest.decode(new DataView(buf));
        }

        // Decodes AccessCapabilitiesRequest from a DataView
        static decode(view: DataView): AccessCapabilitiesRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessCapabilitiesRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.RequestableRoles = decoder.bool();
                        break;
                    }
                    case 3: {
                        obj.SuggestedReviewers = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessCapabilitiesRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size += this.RequestableRoles == 0 ? 0 : 1 + 1;
            size += this.SuggestedReviewers == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes AccessCapabilitiesRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessCapabilitiesRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.RequestableRoles != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.RequestableRoles);
            }
            if (this.SuggestedReviewers != 0) {
                encoder.uint32(0x18);
                encoder.bool(this.SuggestedReviewers);
            }

            return buf;
        } // encode AccessCapabilitiesRequest
    } // AccessCapabilitiesRequest

    // PluginData stores a collection of values associated with a specific resource.
    export class PluginDataV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is PluginData metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a PluginData specification
        public Spec: types.PluginDataSpecV3 = new types.PluginDataSpecV3();

        // Decodes PluginDataV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataV3 {
            return PluginDataV3.decode(new DataView(buf));
        }

        // Decodes PluginDataV3 from a DataView
        static decode(view: DataView): PluginDataV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.PluginDataSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.PluginDataSpecV3 = this
                    .Spec as types.PluginDataSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes PluginDataV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.PluginDataSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode PluginDataV3
    } // PluginDataV3

    /**
     * PluginDataEntry wraps a mapping of arbitrary string values used by
     *  plugins to store per-resource information.
     */
    export class PluginDataEntry {
        // Data is a mapping of arbitrary string values.
        public Data: Map<string, string> = new Map<string, string>();

        // Decodes PluginDataEntry from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataEntry {
            return PluginDataEntry.decode(new DataView(buf));
        }

        // Decodes PluginDataEntry from a DataView
        static decode(view: DataView): PluginDataEntry {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataEntry();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Data);
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataEntry

        public size(): u32 {
            let size: u32 = 0;

            if (this.Data.size > 0) {
                const keys = this.Data.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Data.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataEntry to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataEntry to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Data.size > 0) {
                const keys = this.Data.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Data.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataEntry
    } // PluginDataEntry

    // PluginData stores a collection of values associated with a specific resource.
    export class PluginDataSpecV3 {
        // Entries is a collection of PluginData values organized by plugin name.
        public Entries: Map<string, types.PluginDataEntry> = new Map<
            string,
            types.PluginDataEntry
        >();

        // Decodes PluginDataSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataSpecV3 {
            return PluginDataSpecV3.decode(new DataView(buf));
        }

        // Decodes PluginDataSpecV3 from a DataView
        static decode(view: DataView): PluginDataSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_PluginDataEntry(
                            decoder,
                            length,
                            obj.Entries
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataSpecV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Entries.size > 0) {
                const keys = this.Entries.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Entries.get(key);
                    const itemSize =
                        __sizeMapEntry_string_types_PluginDataEntry(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Entries.size > 0) {
                const keys = this.Entries.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Entries.get(key);
                    const size = __sizeMapEntry_string_types_PluginDataEntry(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataSpecV3
    } // PluginDataSpecV3

    /**
     * NOTE: PluginDataFilter and PluginDataUpdateParams currently only target AccessRequest resources
     *  since those are the only resources currently managed via plugin.  Support for additional resource
     *  kinds may be added in a backwards-compatible manner by adding a `Kind` field which defaults
     *  to `access_request` if unspecified.
     *  PluginDataFilter encodes filter params for plugin data.
     */
    export class PluginDataFilter {
        /**
         * Kind is the kind of resource that the target plugin data
         *  is associated with.
         */
        public Kind: string = "";
        // Resource matches a specific resource name if set.
        public Resource: string = "";
        // Plugin matches a specific plugin name if set.
        public Plugin: string = "";

        // Decodes PluginDataFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataFilter {
            return PluginDataFilter.decode(new DataView(buf));
        }

        // Decodes PluginDataFilter from a DataView
        static decode(view: DataView): PluginDataFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Resource = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Plugin = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.Resource.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Resource.length) +
                      this.Resource.length
                    : 0;
            size +=
                this.Plugin.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Plugin.length) +
                      this.Plugin.length
                    : 0;

            return size;
        }

        // Encodes PluginDataFilter to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataFilter to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.Resource.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Resource.length);
                encoder.string(this.Resource);
            }
            if (this.Plugin.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Plugin.length);
                encoder.string(this.Plugin);
            }

            return buf;
        } // encode PluginDataFilter
    } // PluginDataFilter

    // PluginDataUpdateParams encodes paramers for updating a PluginData field.
    export class PluginDataUpdateParams {
        /**
         * Kind is the kind of resource that the target plugin data
         *  is associated with.
         */
        public Kind: string = "";
        // Resource indicates the name of the target resource.
        public Resource: string = "";
        // Plugin is the name of the plugin that owns the data.
        public Plugin: string = "";
        // Set indicates the fields which should be set by this operation.
        public Set: Map<string, string> = new Map<string, string>();
        // Expect optionally indicates the expected state of fields prior to this update.
        public Expect: Map<string, string> = new Map<string, string>();

        // Decodes PluginDataUpdateParams from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataUpdateParams {
            return PluginDataUpdateParams.decode(new DataView(buf));
        }

        // Decodes PluginDataUpdateParams from a DataView
        static decode(view: DataView): PluginDataUpdateParams {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataUpdateParams();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Resource = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Plugin = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Set);
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Expect);
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataUpdateParams

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.Resource.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Resource.length) +
                      this.Resource.length
                    : 0;
            size +=
                this.Plugin.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Plugin.length) +
                      this.Plugin.length
                    : 0;

            if (this.Set.size > 0) {
                const keys = this.Set.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Set.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Expect.size > 0) {
                const keys = this.Expect.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Expect.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataUpdateParams to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataUpdateParams to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.Resource.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Resource.length);
                encoder.string(this.Resource);
            }
            if (this.Plugin.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Plugin.length);
                encoder.string(this.Plugin);
            }

            if (this.Set.size > 0) {
                const keys = this.Set.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Set.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.Expect.size > 0) {
                const keys = this.Expect.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Expect.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataUpdateParams
    } // PluginDataUpdateParams

    // RoleV4 represents role resource specification
    export class RoleV4 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a role specification
        public Spec: types.RoleSpecV4 = new types.RoleSpecV4();

        // Decodes RoleV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleV4 {
            return RoleV4.decode(new DataView(buf));
        }

        // Decodes RoleV4 from a DataView
        static decode(view: DataView): RoleV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.RoleSpecV4.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleV4

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.RoleSpecV4 = this.Spec as types.RoleSpecV4;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleV4 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleV4 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.RoleSpecV4;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RoleV4
    } // RoleV4

    // RoleSpecV4 is role specification for RoleV4.
    export class RoleSpecV4 {
        // Options is for OpenSSH options like agent forwarding.
        public Options: types.RoleOptions = new types.RoleOptions();
        // Allow is the set of conditions evaluated to grant access.
        public Allow: types.RoleConditions = new types.RoleConditions();
        /**
         * Deny is the set of conditions evaluated to deny access. Deny takes priority
         *  over allow.
         */
        public Deny: types.RoleConditions = new types.RoleConditions();

        // Decodes RoleSpecV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleSpecV4 {
            return RoleSpecV4.decode(new DataView(buf));
        }

        // Decodes RoleSpecV4 from a DataView
        static decode(view: DataView): RoleSpecV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleSpecV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Options = types.RoleOptions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Allow = types.RoleConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Deny = types.RoleConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleSpecV4

        public size(): u32 {
            let size: u32 = 0;

            if (this.Options != null) {
                const f: types.RoleOptions = this.Options as types.RoleOptions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Allow != null) {
                const f: types.RoleConditions = this
                    .Allow as types.RoleConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Deny != null) {
                const f: types.RoleConditions = this
                    .Deny as types.RoleConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleSpecV4 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleSpecV4 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Options != null) {
                const f = this.Options as types.RoleOptions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Allow != null) {
                const f = this.Allow as types.RoleConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Deny != null) {
                const f = this.Deny as types.RoleConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RoleSpecV4
    } // RoleSpecV4

    // RoleOptions is a set of role options
    export class RoleOptions {
        // ForwardAgent is SSH agent forwarding.
        public ForwardAgent: bool;
        // MaxSessionTTL defines how long a SSH session can last for.
        public MaxSessionTTL: i64;
        /**
         * PortForwarding defines if the certificate will have
         *  "permit-port-forwarding"
         *  in the certificate. PortForwarding is "yes" if not set,
         *  that's why this is a pointer
         */
        public PortForwarding: types.BoolValue = new types.BoolValue();
        /**
         * CertificateFormat defines the format of the user certificate to allow
         *  compatibility with older versions of OpenSSH.
         */
        public CertificateFormat: string = "";
        /**
         * ClientIdleTimeout sets disconnect clients on idle timeout behavior,
         *  if set to 0 means do not disconnect, otherwise is set to the idle
         *  duration.
         */
        public ClientIdleTimeout: i64;
        // DisconnectExpiredCert sets disconnect clients on expired certificates.
        public DisconnectExpiredCert: bool;
        // BPF defines what events to record for the BPF-based session recorder.
        public BPF: Array<string> = new Array<string>();
        // PermitX11Forwarding authorizes use of X11 forwarding.
        public PermitX11Forwarding: bool;
        /**
         * MaxConnections defines the maximum number of
         *  concurrent connections a user may hold.
         */
        public MaxConnections: i64;
        /**
         * MaxSessions defines the maximum number of
         *  concurrent sessions per connection.
         */
        public MaxSessions: i64;
        /**
         * RequestAccess defines the access request stategy (optional|note|always)
         *  where optional is the default.
         */
        public RequestAccess: string = "";
        // RequestPrompt is an optional message which tells users what they aught to
        public RequestPrompt: string = "";
        /**
         * RequireSessionMFA specifies whether a user is required to do an MFA
         *  check for every session.
         */
        public RequireSessionMFA: bool;
        /**
         * Lock specifies the locking mode (strict|best_effort) to be applied with
         *  the role.
         */
        public Lock: string = "";

        // Decodes RoleOptions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleOptions {
            return RoleOptions.decode(new DataView(buf));
        }

        // Decodes RoleOptions from a DataView
        static decode(view: DataView): RoleOptions {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleOptions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ForwardAgent = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.MaxSessionTTL = decoder.int64();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.PortForwarding = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.CertificateFormat = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ClientIdleTimeout = decoder.int64();
                        break;
                    }
                    case 6: {
                        obj.DisconnectExpiredCert = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.BPF.push(decoder.string());
                        break;
                    }
                    case 8: {
                        obj.PermitX11Forwarding = decoder.bool();
                        break;
                    }
                    case 9: {
                        obj.MaxConnections = decoder.int64();
                        break;
                    }
                    case 10: {
                        obj.MaxSessions = decoder.int64();
                        break;
                    }
                    case 11: {
                        obj.RequestAccess = decoder.string();
                        break;
                    }
                    case 12: {
                        obj.RequestPrompt = decoder.string();
                        break;
                    }
                    case 13: {
                        obj.RequireSessionMFA = decoder.bool();
                        break;
                    }
                    case 14: {
                        obj.Lock = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleOptions

        public size(): u32 {
            let size: u32 = 0;

            size += this.ForwardAgent == 0 ? 0 : 1 + 1;
            size +=
                this.MaxSessionTTL == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxSessionTTL);

            if (this.PortForwarding != null) {
                const f: types.BoolValue = this
                    .PortForwarding as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.CertificateFormat.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CertificateFormat.length) +
                      this.CertificateFormat.length
                    : 0;
            size +=
                this.ClientIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);
            size += this.DisconnectExpiredCert == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.BPF);

            size += this.PermitX11Forwarding == 0 ? 0 : 1 + 1;
            size +=
                this.MaxConnections == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxConnections);
            size +=
                this.MaxSessions == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxSessions);
            size +=
                this.RequestAccess.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestAccess.length) +
                      this.RequestAccess.length
                    : 0;
            size +=
                this.RequestPrompt.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestPrompt.length) +
                      this.RequestPrompt.length
                    : 0;
            size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;
            size +=
                this.Lock.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Lock.length) +
                      this.Lock.length
                    : 0;

            return size;
        }

        // Encodes RoleOptions to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleOptions to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ForwardAgent != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.ForwardAgent);
            }
            if (this.MaxSessionTTL != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.MaxSessionTTL);
            }

            if (this.PortForwarding != null) {
                const f = this.PortForwarding as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.CertificateFormat.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CertificateFormat.length);
                encoder.string(this.CertificateFormat);
            }
            if (this.ClientIdleTimeout != 0) {
                encoder.uint32(0x28);
                encoder.int64(this.ClientIdleTimeout);
            }
            if (this.DisconnectExpiredCert != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.DisconnectExpiredCert);
            }

            if (this.BPF.length > 0) {
                for (let n: i32 = 0; n < this.BPF.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.BPF[n].length);
                    encoder.string(this.BPF[n]);
                }
            }

            if (this.PermitX11Forwarding != 0) {
                encoder.uint32(0x40);
                encoder.bool(this.PermitX11Forwarding);
            }
            if (this.MaxConnections != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.MaxConnections);
            }
            if (this.MaxSessions != 0) {
                encoder.uint32(0x50);
                encoder.int64(this.MaxSessions);
            }
            if (this.RequestAccess.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.RequestAccess.length);
                encoder.string(this.RequestAccess);
            }
            if (this.RequestPrompt.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.RequestPrompt.length);
                encoder.string(this.RequestPrompt);
            }
            if (this.RequireSessionMFA != 0) {
                encoder.uint32(0x68);
                encoder.bool(this.RequireSessionMFA);
            }
            if (this.Lock.length > 0) {
                encoder.uint32(0x72);
                encoder.uint32(this.Lock.length);
                encoder.string(this.Lock);
            }

            return buf;
        } // encode RoleOptions
    } // RoleOptions

    /**
     * RoleConditions is a set of conditions that must all match to be allowed or
     *  denied access.
     */
    export class RoleConditions {
        // Logins is a list of *nix system logins.
        public Logins: Array<string> = new Array<string>();
        /**
         * Namespaces is a list of namespaces (used to partition a cluster). The
         *  field should be called "namespaces" when it returns in Teleport 2.4.
         */
        public Namespaces: Array<string> = new Array<string>();
        /**
         * NodeLabels is a map of node labels (used to dynamically grant access to
         *  nodes).
         */
        public NodeLabels: wrappers.LabelValues = new wrappers.LabelValues();
        /**
         * Rules is a list of rules and their access levels. Rules are a high level
         *  construct used for access control.
         */
        public Rules: Array<types.Rule> = new Array<types.Rule>();
        // KubeGroups is a list of kubernetes groups
        public KubeGroups: Array<string> = new Array<string>();
        public Request: types.AccessRequestConditions =
            new types.AccessRequestConditions();
        // KubeUsers is an optional kubernetes users to impersonate
        public KubeUsers: Array<string> = new Array<string>();
        // AppLabels is a map of labels used as part of the RBAC system.
        public AppLabels: wrappers.LabelValues = new wrappers.LabelValues();
        /**
         * ClusterLabels is a map of node labels (used to dynamically grant access to
         *  clusters).
         */
        public ClusterLabels: wrappers.LabelValues = new wrappers.LabelValues();
        // KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
        public KubernetesLabels: wrappers.LabelValues =
            new wrappers.LabelValues();
        // DatabaseLabels are used in RBAC system to allow/deny access to databases.
        public DatabaseLabels: wrappers.LabelValues =
            new wrappers.LabelValues();
        // DatabaseNames is a list of database names this role is allowed to connect to.
        public DatabaseNames: Array<string> = new Array<string>();
        // DatabaseUsers is a list of databaes users this role is allowed to connect as.
        public DatabaseUsers: Array<string> = new Array<string>();
        /**
         * Impersonate specifies what users and roles this role is allowed to impersonate
         *  by issuing certificates or other possible means.
         */
        public Impersonate: types.ImpersonateConditions =
            new types.ImpersonateConditions();
        // ReviewRequests defines conditions for submitting access reviews.
        public ReviewRequests: types.AccessReviewConditions =
            new types.AccessReviewConditions();
        // AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
        public AWSRoleARNs: Array<string> = new Array<string>();
        // WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
        public WindowsDesktopLogins: Array<string> = new Array<string>();
        // WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
        public WindowsDesktopLabels: wrappers.LabelValues =
            new wrappers.LabelValues();

        // Decodes RoleConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleConditions {
            return RoleConditions.decode(new DataView(buf));
        }

        // Decodes RoleConditions from a DataView
        static decode(view: DataView): RoleConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Logins.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Namespaces.push(decoder.string());
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.NodeLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Rules.push(
                            types.Rule.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.KubeGroups.push(decoder.string());
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Request = types.AccessRequestConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.KubeUsers.push(decoder.string());
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.AppLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.ClusterLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.KubernetesLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.DatabaseLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        obj.DatabaseNames.push(decoder.string());
                        break;
                    }
                    case 13: {
                        obj.DatabaseUsers.push(decoder.string());
                        break;
                    }
                    case 14: {
                        const length = decoder.uint32();
                        obj.Impersonate = types.ImpersonateConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 15: {
                        const length = decoder.uint32();
                        obj.ReviewRequests =
                            types.AccessReviewConditions.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 16: {
                        obj.AWSRoleARNs.push(decoder.string());
                        break;
                    }
                    case 17: {
                        obj.WindowsDesktopLogins.push(decoder.string());
                        break;
                    }
                    case 18: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Logins);

            size += __size_string_repeated(this.Namespaces);

            if (this.NodeLabels != null) {
                const f: wrappers.LabelValues = this
                    .NodeLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Rules.length; n++) {
                const messageSize = this.Rules[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.KubeGroups);

            if (this.Request != null) {
                const f: types.AccessRequestConditions = this
                    .Request as types.AccessRequestConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.KubeUsers);

            if (this.AppLabels != null) {
                const f: wrappers.LabelValues = this
                    .AppLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ClusterLabels != null) {
                const f: wrappers.LabelValues = this
                    .ClusterLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesLabels != null) {
                const f: wrappers.LabelValues = this
                    .KubernetesLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseLabels != null) {
                const f: wrappers.LabelValues = this
                    .DatabaseLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.DatabaseNames);

            size += __size_string_repeated(this.DatabaseUsers);

            if (this.Impersonate != null) {
                const f: types.ImpersonateConditions = this
                    .Impersonate as types.ImpersonateConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ReviewRequests != null) {
                const f: types.AccessReviewConditions = this
                    .ReviewRequests as types.AccessReviewConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.AWSRoleARNs);

            size += __size_string_repeated(this.WindowsDesktopLogins);

            if (this.WindowsDesktopLabels != null) {
                const f: wrappers.LabelValues = this
                    .WindowsDesktopLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleConditions to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleConditions to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Logins.length > 0) {
                for (let n: i32 = 0; n < this.Logins.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Logins[n].length);
                    encoder.string(this.Logins[n]);
                }
            }

            if (this.Namespaces.length > 0) {
                for (let n: i32 = 0; n < this.Namespaces.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Namespaces[n].length);
                    encoder.string(this.Namespaces[n]);
                }
            }

            if (this.NodeLabels != null) {
                const f = this.NodeLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Rules.length; n++) {
                const messageSize = this.Rules[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.Rules[n].encodeU8Array(encoder);
                }
            }

            if (this.KubeGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubeGroups.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.KubeGroups[n].length);
                    encoder.string(this.KubeGroups[n]);
                }
            }

            if (this.Request != null) {
                const f = this.Request as types.AccessRequestConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubeUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubeUsers.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.KubeUsers[n].length);
                    encoder.string(this.KubeUsers[n]);
                }
            }

            if (this.AppLabels != null) {
                const f = this.AppLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ClusterLabels != null) {
                const f = this.ClusterLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesLabels != null) {
                const f = this.KubernetesLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseLabels != null) {
                const f = this.DatabaseLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseNames.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseNames.length; n++) {
                    encoder.uint32(0x62);
                    encoder.uint32(this.DatabaseNames[n].length);
                    encoder.string(this.DatabaseNames[n]);
                }
            }

            if (this.DatabaseUsers.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseUsers.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.DatabaseUsers[n].length);
                    encoder.string(this.DatabaseUsers[n]);
                }
            }

            if (this.Impersonate != null) {
                const f = this.Impersonate as types.ImpersonateConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x72);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ReviewRequests != null) {
                const f = this.ReviewRequests as types.AccessReviewConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x7a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AWSRoleARNs.length > 0) {
                for (let n: i32 = 0; n < this.AWSRoleARNs.length; n++) {
                    encoder.uint32(0x82);
                    encoder.uint32(this.AWSRoleARNs[n].length);
                    encoder.string(this.AWSRoleARNs[n]);
                }
            }

            if (this.WindowsDesktopLogins.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.WindowsDesktopLogins.length;
                    n++
                ) {
                    encoder.uint32(0x8a);
                    encoder.uint32(this.WindowsDesktopLogins[n].length);
                    encoder.string(this.WindowsDesktopLogins[n]);
                }
            }

            if (this.WindowsDesktopLabels != null) {
                const f = this.WindowsDesktopLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x92);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RoleConditions
    } // RoleConditions

    /**
     * AccessRequestConditions is a matcher for allow/deny restrictions on
     *  access-requests.
     */
    export class AccessRequestConditions {
        // Roles is the name of roles which will match the request rule.
        public Roles: Array<string> = new Array<string>();
        // ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        /**
         * Annotations is a collection of annotations to be programmatically
         *  appended to pending access requests at the time of their creation.
         *  These annotations serve as a mechanism to propagate extra information
         *  to plugins.  Since these annotations support variable interpolation
         *  syntax, they also offer a mechanism for forwarding claims from an
         *  external identity provider, to a plugin via `{{external.trait_name}}`
         *  style substitutions.
         */
        public Annotations: wrappers.LabelValues = new wrappers.LabelValues();
        /**
         * Thresholds is a list of thresholds, one of which must be met in order for reviews
         *  to trigger a state-transition.  If no thresholds are provided, a default threshold
         *  of 1 for approval and denial is used.
         */
        public Thresholds: Array<types.AccessReviewThreshold> =
            new Array<types.AccessReviewThreshold>();
        /**
         * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
         *  that is not a requirement.
         */
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessRequestConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestConditions {
            return AccessRequestConditions.decode(new DataView(buf));
        }

        // Decodes AccessRequestConditions from a DataView
        static decode(view: DataView): AccessRequestConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Annotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Thresholds.push(
                            types.AccessReviewThreshold.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Annotations != null) {
                const f: wrappers.LabelValues = this
                    .Annotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessRequestConditions to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestConditions to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encodeU8Array(encoder);
                }
            }

            if (this.Annotations != null) {
                const f = this.Annotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.Thresholds[n].encodeU8Array(encoder);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessRequestConditions
    } // AccessRequestConditions

    /**
     * AccessReviewConditions is a matcher for allow/deny restrictions on
     *  access reviews.
     */
    export class AccessReviewConditions {
        // Roles is the name of roles which may be reviewed.
        public Roles: Array<string> = new Array<string>();
        // ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        /**
         * Where is an optional predicate which further limits which requests are
         *  reviewable.
         */
        public Where: string = "";

        // Decodes AccessReviewConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewConditions {
            return AccessReviewConditions.decode(new DataView(buf));
        }

        // Decodes AccessReviewConditions from a DataView
        static decode(view: DataView): AccessReviewConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            return size;
        }

        // Encodes AccessReviewConditions to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewConditions to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encodeU8Array(encoder);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            return buf;
        } // encode AccessReviewConditions
    } // AccessReviewConditions

    // ClaimMapping maps a claim to teleport roles.
    export class ClaimMapping {
        // Claim is a claim name.
        public Claim: string = "";
        // Value is a claim value to match.
        public Value: string = "";
        // Roles is a list of static teleport roles to match.
        public Roles: Array<string> = new Array<string>();

        // Decodes ClaimMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClaimMapping {
            return ClaimMapping.decode(new DataView(buf));
        }

        // Decodes ClaimMapping from a DataView
        static decode(view: DataView): ClaimMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new ClaimMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Claim = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Roles.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClaimMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Claim.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Claim.length) +
                      this.Claim.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            return size;
        }

        // Encodes ClaimMapping to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClaimMapping to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Claim.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Claim.length);
                encoder.string(this.Claim);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            return buf;
        } // encode ClaimMapping
    } // ClaimMapping

    /**
     * Rule represents allow or deny rule that is executed to check
     *  if user or service have access to resource
     */
    export class Rule {
        // Resources is a list of resources
        public Resources: Array<string> = new Array<string>();
        // Verbs is a list of verbs
        public Verbs: Array<string> = new Array<string>();
        // Where specifies optional advanced matcher
        public Where: string = "";
        // Actions specifies optional actions taken when this rule matches
        public Actions: Array<string> = new Array<string>();

        // Decodes Rule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rule {
            return Rule.decode(new DataView(buf));
        }

        // Decodes Rule from a DataView
        static decode(view: DataView): Rule {
            const decoder = new __proto.Decoder(view);
            const obj = new Rule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Resources.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Verbs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Actions.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rule

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Resources);

            size += __size_string_repeated(this.Verbs);

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            size += __size_string_repeated(this.Actions);

            return size;
        }

        // Encodes Rule to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rule to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Resources.length > 0) {
                for (let n: i32 = 0; n < this.Resources.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Resources[n].length);
                    encoder.string(this.Resources[n]);
                }
            }

            if (this.Verbs.length > 0) {
                for (let n: i32 = 0; n < this.Verbs.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Verbs[n].length);
                    encoder.string(this.Verbs[n]);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            if (this.Actions.length > 0) {
                for (let n: i32 = 0; n < this.Actions.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Actions[n].length);
                    encoder.string(this.Actions[n]);
                }
            }

            return buf;
        } // encode Rule
    } // Rule

    /**
     * ImpersonateConditions specifies whether users are allowed
     *  to issue certificates for other users or groups.
     */
    export class ImpersonateConditions {
        /**
         * Users is a list of resources this role is allowed to impersonate,
         *  could be an empty list or a Wildcard pattern
         */
        public Users: Array<string> = new Array<string>();
        // Roles is a list of resources this role is allowed to impersonate
        public Roles: Array<string> = new Array<string>();
        // Where specifies optional advanced matcher
        public Where: string = "";

        // Decodes ImpersonateConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ImpersonateConditions {
            return ImpersonateConditions.decode(new DataView(buf));
        }

        // Decodes ImpersonateConditions from a DataView
        static decode(view: DataView): ImpersonateConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new ImpersonateConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Users.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ImpersonateConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Users);

            size += __size_string_repeated(this.Roles);

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            return size;
        }

        // Encodes ImpersonateConditions to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ImpersonateConditions to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Users.length > 0) {
                for (let n: i32 = 0; n < this.Users.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Users[n].length);
                    encoder.string(this.Users[n]);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            return buf;
        } // encode ImpersonateConditions
    } // ImpersonateConditions

    /**
     * BoolValue is a wrapper around bool, used in cases
     *  whenever bool value can have different default value when missing
     */
    export class BoolValue {
        public Value: bool;

        // Decodes BoolValue from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BoolValue {
            return BoolValue.decode(new DataView(buf));
        }

        // Decodes BoolValue from a DataView
        static decode(view: DataView): BoolValue {
            const decoder = new __proto.Decoder(view);
            const obj = new BoolValue();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Value = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BoolValue

        public size(): u32 {
            let size: u32 = 0;

            size += this.Value == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes BoolValue to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BoolValue to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Value != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Value);
            }

            return buf;
        } // encode BoolValue
    } // BoolValue

    // UserV2 is version 2 resource spec of the user
    export class UserV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a user specification
        public Spec: types.UserSpecV2 = new types.UserSpecV2();

        // Decodes UserV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserV2 {
            return UserV2.decode(new DataView(buf));
        }

        // Decodes UserV2 from a DataView
        static decode(view: DataView): UserV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserSpecV2 = this.Spec as types.UserSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserV2
    } // UserV2

    // UserSpecV2 is a specification for V2 user
    export class UserSpecV2 {
        /**
         * OIDCIdentities lists associated OpenID Connect identities
         *  that let user log in using externally verified identity
         */
        public OIDCIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        /**
         * SAMLIdentities lists associated SAML identities
         *  that let user log in using externally verified identity
         */
        public SAMLIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        /**
         * GithubIdentities list associated Github OAuth2 identities
         *  that let user log in using externally verified identity
         */
        public GithubIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        // Roles is a list of roles assigned to user
        public Roles: Array<string> = new Array<string>();
        /**
         * Traits are key/value pairs received from an identity provider (through
         *  OIDC claims or SAML assertions) or from a system administrator for local
         *  accounts. Traits are used to populate role variables.
         */
        public Traits: wrappers.LabelValues = new wrappers.LabelValues();
        // Status is a login status of the user
        public Status: types.LoginStatus = new types.LoginStatus();
        // Expires if set sets TTL on the user
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // CreatedBy holds information about agent or person created this user
        public CreatedBy: types.CreatedBy = new types.CreatedBy();
        /**
         * LocalAuths hold sensitive data necessary for performing local
         *  authentication
         */
        public LocalAuth: types.LocalAuthSecrets = new types.LocalAuthSecrets();

        // Decodes UserSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserSpecV2 {
            return UserSpecV2.decode(new DataView(buf));
        }

        // Decodes UserSpecV2 from a DataView
        static decode(view: DataView): UserSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.OIDCIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.SAMLIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.GithubIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Traits = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = types.LoginStatus.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.CreatedBy = types.CreatedBy.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.LocalAuth = types.LocalAuthSecrets.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserSpecV2

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {
                const messageSize = this.OIDCIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {
                const messageSize = this.SAMLIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {
                const messageSize = this.GithubIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            if (this.Traits != null) {
                const f: wrappers.LabelValues = this
                    .Traits as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.LoginStatus = this.Status as types.LoginStatus;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.CreatedBy != null) {
                const f: types.CreatedBy = this.CreatedBy as types.CreatedBy;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LocalAuth != null) {
                const f: types.LocalAuthSecrets = this
                    .LocalAuth as types.LocalAuthSecrets;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {
                const messageSize = this.OIDCIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.OIDCIdentities[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {
                const messageSize = this.SAMLIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.SAMLIdentities[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {
                const messageSize = this.GithubIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    this.GithubIdentities[n].encodeU8Array(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Traits != null) {
                const f = this.Traits as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.LoginStatus;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.CreatedBy != null) {
                const f = this.CreatedBy as types.CreatedBy;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.LocalAuth != null) {
                const f = this.LocalAuth as types.LocalAuthSecrets;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserSpecV2
    } // UserSpecV2

    /**
     * ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
     *  to particular user and connector and lets user to log in using external
     *  credentials, e.g. google
     */
    export class ExternalIdentity {
        // ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
        public ConnectorID: string = "";
        // Username is username supplied by external identity provider
        public Username: string = "";

        // Decodes ExternalIdentity from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ExternalIdentity {
            return ExternalIdentity.decode(new DataView(buf));
        }

        // Decodes ExternalIdentity from a DataView
        static decode(view: DataView): ExternalIdentity {
            const decoder = new __proto.Decoder(view);
            const obj = new ExternalIdentity();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ConnectorID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Username = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ExternalIdentity

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ConnectorID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ConnectorID.length) +
                      this.ConnectorID.length
                    : 0;
            size +=
                this.Username.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Username.length) +
                      this.Username.length
                    : 0;

            return size;
        }

        // Encodes ExternalIdentity to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ExternalIdentity to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ConnectorID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ConnectorID.length);
                encoder.string(this.ConnectorID);
            }
            if (this.Username.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Username.length);
                encoder.string(this.Username);
            }

            return buf;
        } // encode ExternalIdentity
    } // ExternalIdentity

    // LoginStatus is a login status of the user
    export class LoginStatus {
        // IsLocked tells us if user is locked
        public IsLocked: bool;
        // LockedMessage contains the message in case if user is locked
        public LockedMessage: string = "";
        // LockedTime contains time when user was locked
        public LockedTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // LockExpires contains time when this lock will expire
        public LockExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * RecoveryAttemptLockExpires contains the time when this lock will expire
         *  from reaching MaxAccountRecoveryAttempts. This field is used to determine
         *  if a user got locked from recovery attempts.
         */
        public RecoveryAttemptLockExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes LoginStatus from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LoginStatus {
            return LoginStatus.decode(new DataView(buf));
        }

        // Decodes LoginStatus from a DataView
        static decode(view: DataView): LoginStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new LoginStatus();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.IsLocked = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.LockedMessage = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LockedTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.LockExpires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.RecoveryAttemptLockExpires =
                            google.protobuf.Timestamp.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LoginStatus

        public size(): u32 {
            let size: u32 = 0;

            size += this.IsLocked == 0 ? 0 : 1 + 1;
            size +=
                this.LockedMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LockedMessage.length) +
                      this.LockedMessage.length
                    : 0;

            if (this.LockedTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LockedTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .LockExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryAttemptLockExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .RecoveryAttemptLockExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LoginStatus to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LoginStatus to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.IsLocked != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.IsLocked);
            }
            if (this.LockedMessage.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.LockedMessage.length);
                encoder.string(this.LockedMessage);
            }

            if (this.LockedTime != null) {
                const f = this.LockedTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.LockExpires != null) {
                const f = this.LockExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RecoveryAttemptLockExpires != null) {
                const f = this
                    .RecoveryAttemptLockExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LoginStatus
    } // LoginStatus

    // CreatedBy holds information about the person or agent who created the user
    export class CreatedBy {
        // Identity if present means that user was automatically created by identity
        public Connector: types.ConnectorRef = new types.ConnectorRef();
        // Time specifies when user was created
        public Time: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // User holds information about user
        public User: types.UserRef = new types.UserRef();

        // Decodes CreatedBy from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CreatedBy {
            return CreatedBy.decode(new DataView(buf));
        }

        // Decodes CreatedBy from a DataView
        static decode(view: DataView): CreatedBy {
            const decoder = new __proto.Decoder(view);
            const obj = new CreatedBy();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Connector = types.ConnectorRef.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Time = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = types.UserRef.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CreatedBy

        public size(): u32 {
            let size: u32 = 0;

            if (this.Connector != null) {
                const f: types.ConnectorRef = this
                    .Connector as types.ConnectorRef;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Time != null) {
                const f: google.protobuf.Timestamp = this
                    .Time as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: types.UserRef = this.User as types.UserRef;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CreatedBy to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CreatedBy to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Connector != null) {
                const f = this.Connector as types.ConnectorRef;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Time != null) {
                const f = this.Time as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as types.UserRef;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode CreatedBy
    } // CreatedBy

    // U2FRegistrationData encodes the universal second factor registration payload.
    export class U2FRegistrationData {
        // Raw is the serialized registration data as received from the token
        public Raw: Array<u8> = new Array<u8>();
        // KeyHandle uniquely identifies a key on a device
        public KeyHandle: Array<u8> = new Array<u8>();
        // PubKey is an DER encoded ecdsa public key
        public PubKey: Array<u8> = new Array<u8>();

        // Decodes U2FRegistrationData from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2FRegistrationData {
            return U2FRegistrationData.decode(new DataView(buf));
        }

        // Decodes U2FRegistrationData from a DataView
        static decode(view: DataView): U2FRegistrationData {
            const decoder = new __proto.Decoder(view);
            const obj = new U2FRegistrationData();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Raw = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.KeyHandle = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PubKey = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2FRegistrationData

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Raw.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Raw.length) +
                      this.Raw.length
                    : 0;
            size +=
                this.KeyHandle.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KeyHandle.length) +
                      this.KeyHandle.length
                    : 0;
            size +=
                this.PubKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PubKey.length) +
                      this.PubKey.length
                    : 0;

            return size;
        }

        // Encodes U2FRegistrationData to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2FRegistrationData to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Raw.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Raw.length);
                encoder.bytes(this.Raw);
            }
            if (this.KeyHandle.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.KeyHandle.length);
                encoder.bytes(this.KeyHandle);
            }
            if (this.PubKey.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.PubKey.length);
                encoder.bytes(this.PubKey);
            }

            return buf;
        } // encode U2FRegistrationData
    } // U2FRegistrationData

    // LocalAuthSecrets holds sensitive data used to authenticate a local user.
    export class LocalAuthSecrets {
        // PasswordHash encodes a combined salt & hash for password verification.
        public PasswordHash: Array<u8> = new Array<u8>();
        // Deprecated 2nd factor fields, use MFA below instead.
        public TOTPKey: string = "";
        public U2FRegistration: types.U2FRegistrationData =
            new types.U2FRegistrationData();
        public U2FCounter: u32;
        public MFA: Array<types.MFADevice> = new Array<types.MFADevice>();
        /**
         * Webauthn holds settings necessary for webauthn local auth.
         *  May be null for legacy users or users that haven't yet used webauthn as
         *  their second factor.
         */
        public Webauthn: types.WebauthnLocalAuth =
            new types.WebauthnLocalAuth();

        // Decodes LocalAuthSecrets from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LocalAuthSecrets {
            return LocalAuthSecrets.decode(new DataView(buf));
        }

        // Decodes LocalAuthSecrets from a DataView
        static decode(view: DataView): LocalAuthSecrets {
            const decoder = new __proto.Decoder(view);
            const obj = new LocalAuthSecrets();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PasswordHash = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.TOTPKey = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.U2FRegistration = types.U2FRegistrationData.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.U2FCounter = decoder.uint32();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.MFA.push(
                            types.MFADevice.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Webauthn = types.WebauthnLocalAuth.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LocalAuthSecrets

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PasswordHash.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PasswordHash.length) +
                      this.PasswordHash.length
                    : 0;
            size +=
                this.TOTPKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TOTPKey.length) +
                      this.TOTPKey.length
                    : 0;

            if (this.U2FRegistration != null) {
                const f: types.U2FRegistrationData = this
                    .U2FRegistration as types.U2FRegistrationData;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.U2FCounter == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.U2FCounter);

            for (let n: i32 = 0; n < this.MFA.length; n++) {
                const messageSize = this.MFA[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Webauthn != null) {
                const f: types.WebauthnLocalAuth = this
                    .Webauthn as types.WebauthnLocalAuth;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LocalAuthSecrets to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LocalAuthSecrets to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PasswordHash.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PasswordHash.length);
                encoder.bytes(this.PasswordHash);
            }
            if (this.TOTPKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.TOTPKey.length);
                encoder.string(this.TOTPKey);
            }

            if (this.U2FRegistration != null) {
                const f = this.U2FRegistration as types.U2FRegistrationData;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.U2FCounter != 0) {
                encoder.uint32(0x20);
                encoder.uint32(this.U2FCounter);
            }

            for (let n: i32 = 0; n < this.MFA.length; n++) {
                const messageSize = this.MFA[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    this.MFA[n].encodeU8Array(encoder);
                }
            }

            if (this.Webauthn != null) {
                const f = this.Webauthn as types.WebauthnLocalAuth;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LocalAuthSecrets
    } // LocalAuthSecrets

    /**
     * MFADevice is a multi-factor authentication device, such as a security key or
     *  an OTP app.
     */
    export class MFADevice {
        public __oneOf_device: string = "";
        // Boilerplate for implementing the Resource interface.
        public kind: string = "";
        public sub_kind: string = "";
        public version: string = "";
        public metadata: types.Metadata = new types.Metadata();
        // ID is a UUID of this device.
        public id: string = "";
        public added_at: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public last_used: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public totp: types.TOTPDevice | null;
        public u2f: types.U2FDevice | null;
        public webauthn: types.WebauthnDevice | null;

        // Decodes MFADevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADevice {
            return MFADevice.decode(new DataView(buf));
        }

        // Decodes MFADevice from a DataView
        static decode(view: DataView): MFADevice {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.sub_kind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.id = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.added_at = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.last_used = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.totp = types.TOTPDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_device = "totp";
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.u2f = types.U2FDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_device = "u2f";
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.webauthn = types.WebauthnDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_device = "webauthn";
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.kind.length) +
                      this.kind.length
                    : 0;
            size +=
                this.sub_kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.sub_kind.length) +
                      this.sub_kind.length
                    : 0;
            size +=
                this.version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.version.length) +
                      this.version.length
                    : 0;

            if (this.metadata != null) {
                const f: types.Metadata = this.metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.id.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.id.length) +
                      this.id.length
                    : 0;

            if (this.added_at != null) {
                const f: google.protobuf.Timestamp = this
                    .added_at as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.last_used != null) {
                const f: google.protobuf.Timestamp = this
                    .last_used as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.totp != null) {
                const f: types.TOTPDevice = this.totp as types.TOTPDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.u2f != null) {
                const f: types.U2FDevice = this.u2f as types.U2FDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.webauthn != null) {
                const f: types.WebauthnDevice = this
                    .webauthn as types.WebauthnDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADevice to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADevice to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.kind.length);
                encoder.string(this.kind);
            }
            if (this.sub_kind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.sub_kind.length);
                encoder.string(this.sub_kind);
            }
            if (this.version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.version.length);
                encoder.string(this.version);
            }

            if (this.metadata != null) {
                const f = this.metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.id.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.id.length);
                encoder.string(this.id);
            }

            if (this.added_at != null) {
                const f = this.added_at as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.last_used != null) {
                const f = this.last_used as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.totp != null) {
                const f = this.totp as types.TOTPDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.u2f != null) {
                const f = this.u2f as types.U2FDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.webauthn != null) {
                const f = this.webauthn as types.WebauthnDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode MFADevice
    } // MFADevice

    // TOTPDevice holds the TOTP-specific fields of MFADevice.
    export class TOTPDevice {
        public key: string = "";

        // Decodes TOTPDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TOTPDevice {
            return TOTPDevice.decode(new DataView(buf));
        }

        // Decodes TOTPDevice from a DataView
        static decode(view: DataView): TOTPDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new TOTPDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.key = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TOTPDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.key.length) +
                      this.key.length
                    : 0;

            return size;
        }

        // Encodes TOTPDevice to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TOTPDevice to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.key.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.key.length);
                encoder.string(this.key);
            }

            return buf;
        } // encode TOTPDevice
    } // TOTPDevice

    // U2FDevice holds the U2F-specific fields of MFADevice.
    export class U2FDevice {
        // KeyHandle uniquely identifies a key on a device
        public key_handle: Array<u8> = new Array<u8>();
        // PubKey is an DER encoded ecdsa public key
        public pub_key: Array<u8> = new Array<u8>();
        // Counter is the latest seen value of the U2F usage counter.
        public counter: u32;

        // Decodes U2FDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2FDevice {
            return U2FDevice.decode(new DataView(buf));
        }

        // Decodes U2FDevice from a DataView
        static decode(view: DataView): U2FDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new U2FDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.key_handle = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.pub_key = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.counter = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2FDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.key_handle.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.key_handle.length) +
                      this.key_handle.length
                    : 0;
            size +=
                this.pub_key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.pub_key.length) +
                      this.pub_key.length
                    : 0;
            size +=
                this.counter == 0 ? 0 : 1 + __proto.Sizer.uint32(this.counter);

            return size;
        }

        // Encodes U2FDevice to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2FDevice to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.key_handle.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.key_handle.length);
                encoder.bytes(this.key_handle);
            }
            if (this.pub_key.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.pub_key.length);
                encoder.bytes(this.pub_key);
            }
            if (this.counter != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.counter);
            }

            return buf;
        } // encode U2FDevice
    } // U2FDevice

    // WebauthnDevice holds Webauthn-specific fields of MFADevice.
    export class WebauthnDevice {
        // Credential ID for the authenticator.
        public credential_id: Array<u8> = new Array<u8>();
        /**
         * Public key encoded in CBOR format.
         *  Webauthn support various key algorithms; CBOR encoding is used to reflect
         *  those choices.
         *  See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
         *  reference.
         */
        public public_key_cbor: Array<u8> = new Array<u8>();
        // Attestation format used by the authenticator, if any.
        public attestation_type: string = "";
        /**
         * AAGUID is the globally unique identifier of the authenticator model.
         *  Zeroed for U2F devices.
         */
        public aaguid: Array<u8> = new Array<u8>();
        /**
         * Signature counter for login operations.
         *  Actual counter values received from the authenticator are expected to be
         *  higher than the previously-stored value.
         */
        public signature_counter: u32;

        // Decodes WebauthnDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebauthnDevice {
            return WebauthnDevice.decode(new DataView(buf));
        }

        // Decodes WebauthnDevice from a DataView
        static decode(view: DataView): WebauthnDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new WebauthnDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.credential_id = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.public_key_cbor = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.attestation_type = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.aaguid = decoder.bytes();
                        break;
                    }
                    case 5: {
                        obj.signature_counter = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebauthnDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.credential_id.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.credential_id.length) +
                      this.credential_id.length
                    : 0;
            size +=
                this.public_key_cbor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.public_key_cbor.length) +
                      this.public_key_cbor.length
                    : 0;
            size +=
                this.attestation_type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.attestation_type.length) +
                      this.attestation_type.length
                    : 0;
            size +=
                this.aaguid.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.aaguid.length) +
                      this.aaguid.length
                    : 0;
            size +=
                this.signature_counter == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.signature_counter);

            return size;
        }

        // Encodes WebauthnDevice to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebauthnDevice to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.credential_id.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.credential_id.length);
                encoder.bytes(this.credential_id);
            }
            if (this.public_key_cbor.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.public_key_cbor.length);
                encoder.bytes(this.public_key_cbor);
            }
            if (this.attestation_type.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.attestation_type.length);
                encoder.string(this.attestation_type);
            }
            if (this.aaguid.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.aaguid.length);
                encoder.bytes(this.aaguid);
            }
            if (this.signature_counter != 0) {
                encoder.uint32(0x28);
                encoder.uint32(this.signature_counter);
            }

            return buf;
        } // encode WebauthnDevice
    } // WebauthnDevice

    // WebauthnLocalAuth holds settings necessary for local webauthn use.
    export class WebauthnLocalAuth {
        /**
         * UserID is the random user handle generated for the user.
         *  See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
         */
        public UserID: Array<u8> = new Array<u8>();

        // Decodes WebauthnLocalAuth from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebauthnLocalAuth {
            return WebauthnLocalAuth.decode(new DataView(buf));
        }

        // Decodes WebauthnLocalAuth from a DataView
        static decode(view: DataView): WebauthnLocalAuth {
            const decoder = new __proto.Decoder(view);
            const obj = new WebauthnLocalAuth();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.UserID = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebauthnLocalAuth

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.UserID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UserID.length) +
                      this.UserID.length
                    : 0;

            return size;
        }

        // Encodes WebauthnLocalAuth to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebauthnLocalAuth to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UserID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.UserID.length);
                encoder.bytes(this.UserID);
            }

            return buf;
        } // encode WebauthnLocalAuth
    } // WebauthnLocalAuth

    // ConnectorRef holds information about OIDC connector
    export class ConnectorRef {
        // Type is connector type
        public Type: string = "";
        // ID is connector ID
        public ID: string = "";
        // Identity is external identity of the user
        public Identity: string = "";

        // Decodes ConnectorRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ConnectorRef {
            return ConnectorRef.decode(new DataView(buf));
        }

        // Decodes ConnectorRef from a DataView
        static decode(view: DataView): ConnectorRef {
            const decoder = new __proto.Decoder(view);
            const obj = new ConnectorRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Identity = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ConnectorRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.Identity.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Identity.length) +
                      this.Identity.length
                    : 0;

            return size;
        }

        // Encodes ConnectorRef to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ConnectorRef to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.Identity.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Identity.length);
                encoder.string(this.Identity);
            }

            return buf;
        } // encode ConnectorRef
    } // ConnectorRef

    // UserRef holds references to user
    export class UserRef {
        // Name is name of the user
        public Name: string = "";

        // Decodes UserRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserRef {
            return UserRef.decode(new DataView(buf));
        }

        // Decodes UserRef from a DataView
        static decode(view: DataView): UserRef {
            const decoder = new __proto.Decoder(view);
            const obj = new UserRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            return size;
        }

        // Encodes UserRef to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserRef to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            return buf;
        } // encode UserRef
    } // UserRef

    // ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
    export class ReverseTunnelV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is a resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a reverse tunnel specification
        public Spec: types.ReverseTunnelSpecV2 =
            new types.ReverseTunnelSpecV2();

        // Decodes ReverseTunnelV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ReverseTunnelV2 {
            return ReverseTunnelV2.decode(new DataView(buf));
        }

        // Decodes ReverseTunnelV2 from a DataView
        static decode(view: DataView): ReverseTunnelV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ReverseTunnelV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ReverseTunnelSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ReverseTunnelV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ReverseTunnelSpecV2 = this
                    .Spec as types.ReverseTunnelSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ReverseTunnelV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ReverseTunnelV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ReverseTunnelSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode ReverseTunnelV2
    } // ReverseTunnelV2

    // ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
    export class ReverseTunnelSpecV2 {
        // ClusterName is a domain name of remote cluster we are connecting to
        public ClusterName: string = "";
        /**
         * DialAddrs is a list of remote address to establish a connection to
         *  it's always SSH over TCP
         */
        public DialAddrs: Array<string> = new Array<string>();
        // Type is the type of reverse tunnel, either proxy or node.
        public Type: string = "";

        // Decodes ReverseTunnelSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ReverseTunnelSpecV2 {
            return ReverseTunnelSpecV2.decode(new DataView(buf));
        }

        // Decodes ReverseTunnelSpecV2 from a DataView
        static decode(view: DataView): ReverseTunnelSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ReverseTunnelSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DialAddrs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Type = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ReverseTunnelSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            size += __size_string_repeated(this.DialAddrs);

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;

            return size;
        }

        // Encodes ReverseTunnelSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ReverseTunnelSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            if (this.DialAddrs.length > 0) {
                for (let n: i32 = 0; n < this.DialAddrs.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.DialAddrs[n].length);
                    encoder.string(this.DialAddrs[n]);
                }
            }

            if (this.Type.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }

            return buf;
        } // encode ReverseTunnelSpecV2
    } // ReverseTunnelSpecV2

    // TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
    export class TunnelConnectionV2 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is a resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a tunnel specification
        public Spec: types.TunnelConnectionSpecV2 =
            new types.TunnelConnectionSpecV2();

        // Decodes TunnelConnectionV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TunnelConnectionV2 {
            return TunnelConnectionV2.decode(new DataView(buf));
        }

        // Decodes TunnelConnectionV2 from a DataView
        static decode(view: DataView): TunnelConnectionV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TunnelConnectionV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.TunnelConnectionSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TunnelConnectionV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.TunnelConnectionSpecV2 = this
                    .Spec as types.TunnelConnectionSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TunnelConnectionV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TunnelConnectionV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.TunnelConnectionSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TunnelConnectionV2
    } // TunnelConnectionV2

    // TunnelConnectionSpecV2 is a specification for V2 tunnel connection
    export class TunnelConnectionSpecV2 {
        // ClusterName is a name of the cluster
        public ClusterName: string = "";
        // ProxyName is the name of the proxy server
        public ProxyName: string = "";
        // LastHeartbeat is a time of the last heartbeat
        public LastHeartbeat: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Type is the type of reverse tunnel, either proxy or node.
        public Type: string = "";

        // Decodes TunnelConnectionSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TunnelConnectionSpecV2 {
            return TunnelConnectionSpecV2.decode(new DataView(buf));
        }

        // Decodes TunnelConnectionSpecV2 from a DataView
        static decode(view: DataView): TunnelConnectionSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TunnelConnectionSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ProxyName = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LastHeartbeat = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Type = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TunnelConnectionSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;
            size +=
                this.ProxyName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProxyName.length) +
                      this.ProxyName.length
                    : 0;

            if (this.LastHeartbeat != null) {
                const f: google.protobuf.Timestamp = this
                    .LastHeartbeat as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;

            return size;
        }

        // Encodes TunnelConnectionSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TunnelConnectionSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }
            if (this.ProxyName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ProxyName.length);
                encoder.string(this.ProxyName);
            }

            if (this.LastHeartbeat != null) {
                const f = this.LastHeartbeat as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Type.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }

            return buf;
        } // encode TunnelConnectionSpecV2
    } // TunnelConnectionSpecV2

    /**
     * SemaphoreFilter encodes semaphore filtering params.
     *  A semaphore filter matches a semaphore if all nonzero fields
     *  match the corresponding semaphore fileds (e.g. a filter which
     *  specifies only `kind=foo` would match all semaphores of
     *  kind `foo`).
     */
    export class SemaphoreFilter {
        // SemaphoreKind is the kind of the semaphore.
        public SemaphoreKind: string = "";
        // SemaphoreName is the name of the semaphore.
        public SemaphoreName: string = "";

        // Decodes SemaphoreFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreFilter {
            return SemaphoreFilter.decode(new DataView(buf));
        }

        // Decodes SemaphoreFilter from a DataView
        static decode(view: DataView): SemaphoreFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;

            return size;
        }

        // Encodes SemaphoreFilter to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreFilter to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }

            return buf;
        } // encode SemaphoreFilter
    } // SemaphoreFilter

    // AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
    export class AcquireSemaphoreRequest {
        // SemaphoreKind is the kind of the semaphore.
        public SemaphoreKind: string = "";
        // SemaphoreName is the name of the semaphore.
        public SemaphoreName: string = "";
        /**
         * MaxLeases is the maximum number of concurrent leases.  If acquisition
         *  would cause more than MaxLeases to exist, acquisition must fail.
         */
        public MaxLeases: i64;
        // Expires is the time at which this lease expires.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Holder identifies the entitiy holding the lease.
        public Holder: string = "";

        // Decodes AcquireSemaphoreRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AcquireSemaphoreRequest {
            return AcquireSemaphoreRequest.decode(new DataView(buf));
        }

        // Decodes AcquireSemaphoreRequest from a DataView
        static decode(view: DataView): AcquireSemaphoreRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AcquireSemaphoreRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.MaxLeases = decoder.int64();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Holder = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AcquireSemaphoreRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;
            size +=
                this.MaxLeases == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxLeases);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Holder.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Holder.length) +
                      this.Holder.length
                    : 0;

            return size;
        }

        // Encodes AcquireSemaphoreRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AcquireSemaphoreRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }
            if (this.MaxLeases != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.MaxLeases);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Holder.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Holder.length);
                encoder.string(this.Holder);
            }

            return buf;
        } // encode AcquireSemaphoreRequest
    } // AcquireSemaphoreRequest

    // SemaphoreLease represents lease acquired for semaphore
    export class SemaphoreLease {
        // SemaphoreKind is the kind of the semaphore.
        public SemaphoreKind: string = "";
        // SemaphoreName is the name of the semaphore.
        public SemaphoreName: string = "";
        // LeaseID uniquely identifies this lease.
        public LeaseID: string = "";
        // Expires is the time at which this lease expires.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes SemaphoreLease from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreLease {
            return SemaphoreLease.decode(new DataView(buf));
        }

        // Decodes SemaphoreLease from a DataView
        static decode(view: DataView): SemaphoreLease {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreLease();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.LeaseID = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreLease

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;
            size +=
                this.LeaseID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LeaseID.length) +
                      this.LeaseID.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreLease to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreLease to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }
            if (this.LeaseID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.LeaseID.length);
                encoder.string(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SemaphoreLease
    } // SemaphoreLease

    // SemaphoreLeaseRef identifies an existent lease.
    export class SemaphoreLeaseRef {
        // LeaseID is the unique ID of the lease.
        public LeaseID: string = "";
        // Expires is the time at which the lease expires.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Holder identifies the lease holder.
        public Holder: string = "";

        // Decodes SemaphoreLeaseRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreLeaseRef {
            return SemaphoreLeaseRef.decode(new DataView(buf));
        }

        // Decodes SemaphoreLeaseRef from a DataView
        static decode(view: DataView): SemaphoreLeaseRef {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreLeaseRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.LeaseID = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Holder = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreLeaseRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.LeaseID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LeaseID.length) +
                      this.LeaseID.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Holder.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Holder.length) +
                      this.Holder.length
                    : 0;

            return size;
        }

        // Encodes SemaphoreLeaseRef to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreLeaseRef to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.LeaseID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.LeaseID.length);
                encoder.string(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Holder.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Holder.length);
                encoder.string(this.Holder);
            }

            return buf;
        } // encode SemaphoreLeaseRef
    } // SemaphoreLeaseRef

    // SemaphoreV3 implements Semaphore interface
    export class SemaphoreV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is version
        public Version: string = "";
        // Metadata is Semaphore metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a lease V3 spec
        public Spec: types.SemaphoreSpecV3 = new types.SemaphoreSpecV3();

        // Decodes SemaphoreV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreV3 {
            return SemaphoreV3.decode(new DataView(buf));
        }

        // Decodes SemaphoreV3 from a DataView
        static decode(view: DataView): SemaphoreV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SemaphoreSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SemaphoreSpecV3 = this
                    .Spec as types.SemaphoreSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SemaphoreSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SemaphoreV3
    } // SemaphoreV3

    // SemaphoreSpecV3 contains the data about lease
    export class SemaphoreSpecV3 {
        // Leases is a list of all currently acquired leases.
        public Leases: Array<types.SemaphoreLeaseRef> =
            new Array<types.SemaphoreLeaseRef>();

        // Decodes SemaphoreSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreSpecV3 {
            return SemaphoreSpecV3.decode(new DataView(buf));
        }

        // Decodes SemaphoreSpecV3 from a DataView
        static decode(view: DataView): SemaphoreSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Leases.push(
                            types.SemaphoreLeaseRef.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreSpecV3

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Leases.length; n++) {
                const messageSize = this.Leases[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Leases.length; n++) {
                const messageSize = this.Leases[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Leases[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SemaphoreSpecV3
    } // SemaphoreSpecV3

    // WebSessionV2 represents an application or UI web session.
    export class WebSessionV2 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is version.
        public Version: string = "";
        // Metadata is a resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a tunnel specification.
        public Spec: types.WebSessionSpecV2 = new types.WebSessionSpecV2();

        // Decodes WebSessionV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionV2 {
            return WebSessionV2.decode(new DataView(buf));
        }

        // Decodes WebSessionV2 from a DataView
        static decode(view: DataView): WebSessionV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.WebSessionSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WebSessionSpecV2 = this
                    .Spec as types.WebSessionSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WebSessionV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WebSessionSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode WebSessionV2
    } // WebSessionV2

    // WebSessionSpecV2 is a specification for web session.
    export class WebSessionSpecV2 {
        // User is the identity of the user to which the web session belongs.
        public User: string = "";
        // Pub is the SSH certificate for the user.
        public Pub: Array<u8> = new Array<u8>();
        // Priv is the SSH private key for the user.
        public Priv: Array<u8> = new Array<u8>();
        // TLSCert is the TLS certificate for the user.
        public TLSCert: Array<u8> = new Array<u8>();
        /**
         * BearerToken is a token that is paired with the session cookie for
         *  authentication. It is periodically rotated so a stolen cookie itself
         *  is not enough to steal a session. In addition it is used for CSRF
         *  mitigation.
         */
        public BearerToken: string = "";
        // BearerTokenExpires is the absolute time when the token expires.
        public BearerTokenExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // Expires is the absolute time when the session expires.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // LoginTime is the time this user recently logged in.
        public LoginTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // IdleTimeout is the max time a user can be inactive in a session.
        public IdleTimeout: i64;

        // Decodes WebSessionSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionSpecV2 {
            return WebSessionSpecV2.decode(new DataView(buf));
        }

        // Decodes WebSessionSpecV2 from a DataView
        static decode(view: DataView): WebSessionSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Pub = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.Priv = decoder.bytes();
                        break;
                    }
                    case 4: {
                        obj.TLSCert = decoder.bytes();
                        break;
                    }
                    case 5: {
                        obj.BearerToken = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.BearerTokenExpires =
                            google.protobuf.Timestamp.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.LoginTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.IdleTimeout = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Pub.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Pub.length) +
                      this.Pub.length
                    : 0;
            size +=
                this.Priv.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Priv.length) +
                      this.Priv.length
                    : 0;
            size +=
                this.TLSCert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TLSCert.length) +
                      this.TLSCert.length
                    : 0;
            size +=
                this.BearerToken.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.BearerToken.length) +
                      this.BearerToken.length
                    : 0;

            if (this.BearerTokenExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .BearerTokenExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LoginTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LoginTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.IdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.IdleTimeout);

            return size;
        }

        // Encodes WebSessionSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Pub.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Pub.length);
                encoder.bytes(this.Pub);
            }
            if (this.Priv.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Priv.length);
                encoder.bytes(this.Priv);
            }
            if (this.TLSCert.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.TLSCert.length);
                encoder.bytes(this.TLSCert);
            }
            if (this.BearerToken.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.BearerToken.length);
                encoder.string(this.BearerToken);
            }

            if (this.BearerTokenExpires != null) {
                const f = this.BearerTokenExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.LoginTime != null) {
                const f = this.LoginTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.IdleTimeout != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.IdleTimeout);
            }

            return buf;
        } // encode WebSessionSpecV2
    } // WebSessionSpecV2

    // WebSessionFilter encodes cache watch parameters for filtering web sessions.
    export class WebSessionFilter {
        // User is the username to filter web sessions for.
        public User: string = "";

        // Decodes WebSessionFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionFilter {
            return WebSessionFilter.decode(new DataView(buf));
        }

        // Decodes WebSessionFilter from a DataView
        static decode(view: DataView): WebSessionFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;

            return size;
        }

        // Encodes WebSessionFilter to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionFilter to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }

            return buf;
        } // encode WebSessionFilter
    } // WebSessionFilter

    // RemoteClusterV3 represents remote cluster resource specification
    export class RemoteClusterV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources
        public SubKind: string = "";
        // Version is resource API version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Status is a remote cluster status
        public Status: types.RemoteClusterStatusV3 =
            new types.RemoteClusterStatusV3();

        // Decodes RemoteClusterV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RemoteClusterV3 {
            return RemoteClusterV3.decode(new DataView(buf));
        }

        // Decodes RemoteClusterV3 from a DataView
        static decode(view: DataView): RemoteClusterV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new RemoteClusterV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Status = types.RemoteClusterStatusV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RemoteClusterV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.RemoteClusterStatusV3 = this
                    .Status as types.RemoteClusterStatusV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RemoteClusterV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RemoteClusterV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.RemoteClusterStatusV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RemoteClusterV3
    } // RemoteClusterV3

    // RemoteClusterStatusV3 represents status of the remote cluster
    export class RemoteClusterStatusV3 {
        // Connection represents connection status, online or offline
        public Connection: string = "";
        // LastHeartbeat records last heartbeat of the cluster
        public LastHeartbeat: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RemoteClusterStatusV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RemoteClusterStatusV3 {
            return RemoteClusterStatusV3.decode(new DataView(buf));
        }

        // Decodes RemoteClusterStatusV3 from a DataView
        static decode(view: DataView): RemoteClusterStatusV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new RemoteClusterStatusV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Connection = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.LastHeartbeat = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RemoteClusterStatusV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Connection.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Connection.length) +
                      this.Connection.length
                    : 0;

            if (this.LastHeartbeat != null) {
                const f: google.protobuf.Timestamp = this
                    .LastHeartbeat as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RemoteClusterStatusV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RemoteClusterStatusV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Connection.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Connection.length);
                encoder.string(this.Connection);
            }

            if (this.LastHeartbeat != null) {
                const f = this.LastHeartbeat as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RemoteClusterStatusV3
    } // RemoteClusterStatusV3

    /**
     * KubernetesCluster is a named kubernetes API endpoint handled by a Server.
     *
     *  TODO: deprecate and convert all usage to KubernetesClusterV3
     */
    export class KubernetesCluster {
        // Name is the name of this kubernetes cluster.
        public Name: string = "";
        /**
         * StaticLabels is map of static labels associated with this cluster.
         *  Used for RBAC.
         */
        public StaticLabels: Map<string, string> = new Map<string, string>();
        /**
         * DynamicLabels is map of dynamic labels associated with this cluster.
         *  Used for RBAC.
         */
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();

        // Decodes KubernetesCluster from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesCluster {
            return KubernetesCluster.decode(new DataView(buf));
        }

        // Decodes KubernetesCluster from a DataView
        static decode(view: DataView): KubernetesCluster {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesCluster();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.StaticLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesCluster

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes KubernetesCluster to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesCluster to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x12);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode KubernetesCluster
    } // KubernetesCluster

    // KubernetesClusterV3 represents a named kubernetes API endpoint.
    export class KubernetesClusterV3 {
        // Kind is the cluster resource kind.
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the resource spec.
        public Spec: types.KubernetesClusterSpecV3 =
            new types.KubernetesClusterSpecV3();

        // Decodes KubernetesClusterV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterV3 {
            return KubernetesClusterV3.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterV3 from a DataView
        static decode(view: DataView): KubernetesClusterV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.KubernetesClusterSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.KubernetesClusterSpecV3 = this
                    .Spec as types.KubernetesClusterSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes KubernetesClusterV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.KubernetesClusterSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode KubernetesClusterV3
    } // KubernetesClusterV3

    // KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
    export class KubernetesClusterSpecV3 {
        // DynamicLabels are the cluster's dynamic labels.
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();

        // Decodes KubernetesClusterSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterSpecV3 {
            return KubernetesClusterSpecV3.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterSpecV3 from a DataView
        static decode(view: DataView): KubernetesClusterSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterSpecV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes KubernetesClusterSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encodeU8Array(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode KubernetesClusterSpecV3
    } // KubernetesClusterSpecV3

    /**
     * WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
     *  to the client.
     *  Initially bound to a web session, these have been factored out into a separate resource to
     *  enable separate lifecycle management.
     */
    export class WebTokenV3 {
        // Kind is a resource kind
        public Kind: string = "";
        // SubKind is an optional resource sub kind
        public SubKind: string = "";
        // Version is the resource version
        public Version: string = "";
        // Metadata is resource metadata
        public Metadata: types.Metadata = new types.Metadata();
        // Spec defines the web token
        public Spec: types.WebTokenSpecV3 = new types.WebTokenSpecV3();

        // Decodes WebTokenV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebTokenV3 {
            return WebTokenV3.decode(new DataView(buf));
        }

        // Decodes WebTokenV3 from a DataView
        static decode(view: DataView): WebTokenV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebTokenV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.WebTokenSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebTokenV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WebTokenSpecV3 = this
                    .Spec as types.WebTokenSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WebTokenV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebTokenV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WebTokenSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode WebTokenV3
    } // WebTokenV3

    // WebTokenSpecV3 is a unique time-limited token bound to a user's web session
    export class WebTokenSpecV3 {
        // User specifies the user the token is bound to.
        public User: string = "";
        // Token specifies the token's value.
        public Token: string = "";

        // Decodes WebTokenSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebTokenSpecV3 {
            return WebTokenSpecV3.decode(new DataView(buf));
        }

        // Decodes WebTokenSpecV3 from a DataView
        static decode(view: DataView): WebTokenSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebTokenSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebTokenSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes WebTokenSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebTokenSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode WebTokenSpecV3
    } // WebTokenSpecV3

    // GetWebSessionRequest describes a request to query a web session
    export class GetWebSessionRequest {
        // User specifies the user the web session is for.
        public User: string = "";
        // SessionID specifies the web session ID.
        public SessionID: string = "";

        // Decodes GetWebSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GetWebSessionRequest {
            return GetWebSessionRequest.decode(new DataView(buf));
        }

        // Decodes GetWebSessionRequest from a DataView
        static decode(view: DataView): GetWebSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new GetWebSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SessionID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GetWebSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;

            return size;
        }

        // Encodes GetWebSessionRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GetWebSessionRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.SessionID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }

            return buf;
        } // encode GetWebSessionRequest
    } // GetWebSessionRequest

    // DeleteWebSessionRequest describes a request to delete a web session
    export class DeleteWebSessionRequest {
        // User specifies the user the session is bound to
        public User: string = "";
        // SessionID specifies the web session ID to delete.
        public SessionID: string = "";

        // Decodes DeleteWebSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DeleteWebSessionRequest {
            return DeleteWebSessionRequest.decode(new DataView(buf));
        }

        // Decodes DeleteWebSessionRequest from a DataView
        static decode(view: DataView): DeleteWebSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteWebSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SessionID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DeleteWebSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;

            return size;
        }

        // Encodes DeleteWebSessionRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DeleteWebSessionRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.SessionID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }

            return buf;
        } // encode DeleteWebSessionRequest
    } // DeleteWebSessionRequest

    // GetWebTokenRequest describes a request to query a web token
    export class GetWebTokenRequest {
        // User specifies the user the token is for.
        public User: string = "";
        // Token specifies the token to get.
        public Token: string = "";

        // Decodes GetWebTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GetWebTokenRequest {
            return GetWebTokenRequest.decode(new DataView(buf));
        }

        // Decodes GetWebTokenRequest from a DataView
        static decode(view: DataView): GetWebTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new GetWebTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GetWebTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes GetWebTokenRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GetWebTokenRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode GetWebTokenRequest
    } // GetWebTokenRequest

    // DeleteWebTokenRequest describes a request to delete a web token
    export class DeleteWebTokenRequest {
        // User specifies the user the token is for.
        public User: string = "";
        // Token specifies the token to delete.
        public Token: string = "";

        // Decodes DeleteWebTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DeleteWebTokenRequest {
            return DeleteWebTokenRequest.decode(new DataView(buf));
        }

        // Decodes DeleteWebTokenRequest from a DataView
        static decode(view: DataView): DeleteWebTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteWebTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DeleteWebTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes DeleteWebTokenRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DeleteWebTokenRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode DeleteWebTokenRequest
    } // DeleteWebTokenRequest

    // ResourceRequest is a request relating to a named resource.
    export class ResourceRequest {
        // Name is the name of the resource.
        public Name: string = "";

        // Decodes ResourceRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceRequest {
            return ResourceRequest.decode(new DataView(buf));
        }

        // Decodes ResourceRequest from a DataView
        static decode(view: DataView): ResourceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            return size;
        }

        // Encodes ResourceRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            return buf;
        } // encode ResourceRequest
    } // ResourceRequest

    // ResourceWithSecretsRequest is a request relating to a named resource with secrets.
    export class ResourceWithSecretsRequest {
        // Name is the name of the resource.
        public Name: string = "";
        // WithSecrets specifies whether to load associated secrets.
        public WithSecrets: bool;

        // Decodes ResourceWithSecretsRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceWithSecretsRequest {
            return ResourceWithSecretsRequest.decode(new DataView(buf));
        }

        // Decodes ResourceWithSecretsRequest from a DataView
        static decode(view: DataView): ResourceWithSecretsRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceWithSecretsRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.WithSecrets = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceWithSecretsRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size += this.WithSecrets == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes ResourceWithSecretsRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceWithSecretsRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.WithSecrets != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.WithSecrets);
            }

            return buf;
        } // encode ResourceWithSecretsRequest
    } // ResourceWithSecretsRequest

    // ResourcesWithSecretsRequest is a request relating to resources with secrets.
    export class ResourcesWithSecretsRequest {
        // WithSecrets specifies whether to load associated secrets.
        public WithSecrets: bool;

        // Decodes ResourcesWithSecretsRequest from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ResourcesWithSecretsRequest {
            return ResourcesWithSecretsRequest.decode(new DataView(buf));
        }

        // Decodes ResourcesWithSecretsRequest from a DataView
        static decode(view: DataView): ResourcesWithSecretsRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourcesWithSecretsRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.WithSecrets = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourcesWithSecretsRequest

        public size(): u32 {
            let size: u32 = 0;

            size += this.WithSecrets == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes ResourcesWithSecretsRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourcesWithSecretsRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.WithSecrets != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.WithSecrets);
            }

            return buf;
        } // encode ResourcesWithSecretsRequest
    } // ResourcesWithSecretsRequest

    // ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
    export class ResourceInNamespaceRequest {
        // Name is the name of the resource.
        public Name: string = "";
        // Namespace is the namespace of resources.
        public Namespace: string = "";

        // Decodes ResourceInNamespaceRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceInNamespaceRequest {
            return ResourceInNamespaceRequest.decode(new DataView(buf));
        }

        // Decodes ResourceInNamespaceRequest from a DataView
        static decode(view: DataView): ResourceInNamespaceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceInNamespaceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceInNamespaceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;

            return size;
        }

        // Encodes ResourceInNamespaceRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceInNamespaceRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }

            return buf;
        } // encode ResourceInNamespaceRequest
    } // ResourceInNamespaceRequest

    // ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
    export class ResourcesInNamespaceRequest {
        // Namespace is the namespace of resources.
        public Namespace: string = "";

        // Decodes ResourcesInNamespaceRequest from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ResourcesInNamespaceRequest {
            return ResourcesInNamespaceRequest.decode(new DataView(buf));
        }

        // Decodes ResourcesInNamespaceRequest from a DataView
        static decode(view: DataView): ResourcesInNamespaceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourcesInNamespaceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Namespace = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourcesInNamespaceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;

            return size;
        }

        // Encodes ResourcesInNamespaceRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourcesInNamespaceRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Namespace.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }

            return buf;
        } // encode ResourcesInNamespaceRequest
    } // ResourcesInNamespaceRequest

    // OIDCConnectorV3 represents an OIDC connector.
    export class OIDCConnectorV3 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is a resource version.
        public Version: string = "";
        // Metadata holds resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an OIDC connector specification.
        public Spec: types.OIDCConnectorSpecV3 =
            new types.OIDCConnectorSpecV3();

        // Decodes OIDCConnectorV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorV3 {
            return OIDCConnectorV3.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorV3 from a DataView
        static decode(view: DataView): OIDCConnectorV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.OIDCConnectorSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.OIDCConnectorSpecV3 = this
                    .Spec as types.OIDCConnectorSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.OIDCConnectorSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorV3
    } // OIDCConnectorV3

    // OIDCConnectorV3List is a list of OIDC connectors.
    export class OIDCConnectorV3List {
        // OIDCConnectors is a list of OIDC connectors.
        public OIDCConnectors: Array<types.OIDCConnectorV3> =
            new Array<types.OIDCConnectorV3>();

        // Decodes OIDCConnectorV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorV3List {
            return OIDCConnectorV3List.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorV3List from a DataView
        static decode(view: DataView): OIDCConnectorV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.OIDCConnectors.push(
                            types.OIDCConnectorV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {
                const messageSize = this.OIDCConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorV3List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorV3List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {
                const messageSize = this.OIDCConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.OIDCConnectors[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorV3List
    } // OIDCConnectorV3List

    /**
     * OIDCConnectorSpecV3 is an OIDC connector specification.
     *
     *  It specifies configuration for Open ID Connect compatible external
     *  identity provider: https://openid.net/specs/openid-connect-core-1_0.html
     */
    export class OIDCConnectorSpecV3 {
        // IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
        public IssuerURL: string = "";
        // ClientID is the id of the authentication client (Teleport Auth server).
        public ClientID: string = "";
        // ClientSecret is used to authenticate the client.
        public ClientSecret: string = "";
        /**
         * RedirectURL is a URL that will redirect the client's browser
         *  back to the identity provider after successful authentication.
         *  This should match the URL on the Provider's side.
         */
        public RedirectURL: string = "";
        /**
         * ACR is an Authentication Context Class Reference value. The meaning of the ACR
         *  value is context-specific and varies for identity providers.
         */
        public ACR: string = "";
        // Provider is the external identity provider.
        public Provider: string = "";
        // Display is the friendly name for this provider.
        public Display: string = "";
        // Scope specifies additional scopes set by provider.
        public Scope: Array<string> = new Array<string>();
        /**
         * Prompt is an optional OIDC prompt. An empty string omits prompt.
         *  If not specified, it defaults to select_account for backwards compatibility.
         */
        public Prompt: string = "";
        // ClaimsToRoles specifies a dynamic mapping from claims to roles.
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        // GoogleServiceAccountURI is a path to a google service account uri.
        public GoogleServiceAccountURI: string = "";
        // GoogleServiceAccount is a string containing google service account credentials.
        public GoogleServiceAccount: string = "";
        // GoogleAdminEmail is the email of a google admin to impersonate.
        public GoogleAdminEmail: string = "";

        // Decodes OIDCConnectorSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorSpecV3 {
            return OIDCConnectorSpecV3.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorSpecV3 from a DataView
        static decode(view: DataView): OIDCConnectorSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.IssuerURL = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClientID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ClientSecret = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.RedirectURL = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ACR = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Provider = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Display = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Scope.push(decoder.string());
                        break;
                    }
                    case 9: {
                        obj.Prompt = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        obj.GoogleServiceAccountURI = decoder.string();
                        break;
                    }
                    case 12: {
                        obj.GoogleServiceAccount = decoder.string();
                        break;
                    }
                    case 13: {
                        obj.GoogleAdminEmail = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.IssuerURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.IssuerURL.length) +
                      this.IssuerURL.length
                    : 0;
            size +=
                this.ClientID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientID.length) +
                      this.ClientID.length
                    : 0;
            size +=
                this.ClientSecret.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientSecret.length) +
                      this.ClientSecret.length
                    : 0;
            size +=
                this.RedirectURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RedirectURL.length) +
                      this.RedirectURL.length
                    : 0;
            size +=
                this.ACR.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ACR.length) +
                      this.ACR.length
                    : 0;
            size +=
                this.Provider.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Provider.length) +
                      this.Provider.length
                    : 0;
            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;

            size += __size_string_repeated(this.Scope);

            size +=
                this.Prompt.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Prompt.length) +
                      this.Prompt.length
                    : 0;

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.GoogleServiceAccountURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.GoogleServiceAccountURI.length
                      ) +
                      this.GoogleServiceAccountURI.length
                    : 0;
            size +=
                this.GoogleServiceAccount.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.GoogleServiceAccount.length) +
                      this.GoogleServiceAccount.length
                    : 0;
            size +=
                this.GoogleAdminEmail.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.GoogleAdminEmail.length) +
                      this.GoogleAdminEmail.length
                    : 0;

            return size;
        }

        // Encodes OIDCConnectorSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.IssuerURL.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.IssuerURL.length);
                encoder.string(this.IssuerURL);
            }
            if (this.ClientID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClientID.length);
                encoder.string(this.ClientID);
            }
            if (this.ClientSecret.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ClientSecret.length);
                encoder.string(this.ClientSecret);
            }
            if (this.RedirectURL.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.RedirectURL.length);
                encoder.string(this.RedirectURL);
            }
            if (this.ACR.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ACR.length);
                encoder.string(this.ACR);
            }
            if (this.Provider.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Provider.length);
                encoder.string(this.Provider);
            }
            if (this.Display.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }

            if (this.Scope.length > 0) {
                for (let n: i32 = 0; n < this.Scope.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Scope[n].length);
                    encoder.string(this.Scope[n]);
                }
            }

            if (this.Prompt.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.Prompt.length);
                encoder.string(this.Prompt);
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encodeU8Array(encoder);
                }
            }

            if (this.GoogleServiceAccountURI.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.GoogleServiceAccountURI.length);
                encoder.string(this.GoogleServiceAccountURI);
            }
            if (this.GoogleServiceAccount.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.GoogleServiceAccount.length);
                encoder.string(this.GoogleServiceAccount);
            }
            if (this.GoogleAdminEmail.length > 0) {
                encoder.uint32(0x6a);
                encoder.uint32(this.GoogleAdminEmail.length);
                encoder.string(this.GoogleAdminEmail);
            }

            return buf;
        } // encode OIDCConnectorSpecV3
    } // OIDCConnectorSpecV3

    // SAMLConnectorV2 represents a SAML connector.
    export class SAMLConnectorV2 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is a resource version.
        public Version: string = "";
        // Metadata holds resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an SAML connector specification.
        public Spec: types.SAMLConnectorSpecV2 =
            new types.SAMLConnectorSpecV2();

        // Decodes SAMLConnectorV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorV2 {
            return SAMLConnectorV2.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorV2 from a DataView
        static decode(view: DataView): SAMLConnectorV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SAMLConnectorSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SAMLConnectorSpecV2 = this
                    .Spec as types.SAMLConnectorSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SAMLConnectorSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorV2
    } // SAMLConnectorV2

    // SAMLConnectorV2List is a list of SAML connectors.
    export class SAMLConnectorV2List {
        // SAMLConnectors is a list of SAML connectors.
        public SAMLConnectors: Array<types.SAMLConnectorV2> =
            new Array<types.SAMLConnectorV2>();

        // Decodes SAMLConnectorV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorV2List {
            return SAMLConnectorV2List.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorV2List from a DataView
        static decode(view: DataView): SAMLConnectorV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.SAMLConnectors.push(
                            types.SAMLConnectorV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {
                const messageSize = this.SAMLConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorV2List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorV2List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {
                const messageSize = this.SAMLConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.SAMLConnectors[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorV2List
    } // SAMLConnectorV2List

    // SAMLConnectorSpecV2 is a SAML connector specification.
    export class SAMLConnectorSpecV2 {
        // Issuer is the identity provider issuer.
        public Issuer: string = "";
        // SSO is the URL of the identity provider's SSO service.
        public SSO: string = "";
        /**
         * Cert is the identity provider certificate PEM.
         *  IDP signs <Response> responses using this certificate.
         */
        public Cert: string = "";
        // Display controls how this connector is displayed.
        public Display: string = "";
        /**
         * AssertionConsumerService is a URL for assertion consumer service
         *  on the service provider (Teleport's side).
         */
        public AssertionConsumerService: string = "";
        // Audience uniquely identifies our service provider.
        public Audience: string = "";
        // ServiceProviderIssuer is the issuer of the service provider (Teleport).
        public ServiceProviderIssuer: string = "";
        /**
         * EntityDescriptor is XML with descriptor. It can be used to supply configuration
         *  parameters in one XML file rather than supplying them in the individual elements.
         */
        public EntityDescriptor: string = "";
        // EntityDescriptorURL is a URL that supplies a configuration XML.
        public EntityDescriptorURL: string = "";
        // AttributesToRoles is a list of mappings of attribute statements to roles.
        public AttributesToRoles: Array<types.AttributeMapping> =
            new Array<types.AttributeMapping>();
        // SigningKeyPair is an x509 key pair used to sign AuthnRequest.
        public SigningKeyPair: types.AsymmetricKeyPair =
            new types.AsymmetricKeyPair();
        // Provider is the external identity provider.
        public Provider: string = "";
        // EncryptionKeyPair is a key pair used for decrypting SAML assertions.
        public EncryptionKeyPair: types.AsymmetricKeyPair =
            new types.AsymmetricKeyPair();

        // Decodes SAMLConnectorSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorSpecV2 {
            return SAMLConnectorSpecV2.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorSpecV2 from a DataView
        static decode(view: DataView): SAMLConnectorSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Issuer = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SSO = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Cert = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Display = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AssertionConsumerService = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Audience = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ServiceProviderIssuer = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.EntityDescriptor = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.EntityDescriptorURL = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.AttributesToRoles.push(
                            types.AttributeMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.SigningKeyPair = types.AsymmetricKeyPair.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        obj.Provider = decoder.string();
                        break;
                    }
                    case 13: {
                        const length = decoder.uint32();
                        obj.EncryptionKeyPair = types.AsymmetricKeyPair.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Issuer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Issuer.length) +
                      this.Issuer.length
                    : 0;
            size +=
                this.SSO.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SSO.length) +
                      this.SSO.length
                    : 0;
            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;
            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;
            size +=
                this.AssertionConsumerService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.AssertionConsumerService.length
                      ) +
                      this.AssertionConsumerService.length
                    : 0;
            size +=
                this.Audience.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Audience.length) +
                      this.Audience.length
                    : 0;
            size +=
                this.ServiceProviderIssuer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.ServiceProviderIssuer.length
                      ) +
                      this.ServiceProviderIssuer.length
                    : 0;
            size +=
                this.EntityDescriptor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EntityDescriptor.length) +
                      this.EntityDescriptor.length
                    : 0;
            size +=
                this.EntityDescriptorURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EntityDescriptorURL.length) +
                      this.EntityDescriptorURL.length
                    : 0;

            for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {
                const messageSize = this.AttributesToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SigningKeyPair != null) {
                const f: types.AsymmetricKeyPair = this
                    .SigningKeyPair as types.AsymmetricKeyPair;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Provider.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Provider.length) +
                      this.Provider.length
                    : 0;

            if (this.EncryptionKeyPair != null) {
                const f: types.AsymmetricKeyPair = this
                    .EncryptionKeyPair as types.AsymmetricKeyPair;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Issuer.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Issuer.length);
                encoder.string(this.Issuer);
            }
            if (this.SSO.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SSO.length);
                encoder.string(this.SSO);
            }
            if (this.Cert.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Cert.length);
                encoder.string(this.Cert);
            }
            if (this.Display.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }
            if (this.AssertionConsumerService.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.AssertionConsumerService.length);
                encoder.string(this.AssertionConsumerService);
            }
            if (this.Audience.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Audience.length);
                encoder.string(this.Audience);
            }
            if (this.ServiceProviderIssuer.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ServiceProviderIssuer.length);
                encoder.string(this.ServiceProviderIssuer);
            }
            if (this.EntityDescriptor.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.EntityDescriptor.length);
                encoder.string(this.EntityDescriptor);
            }
            if (this.EntityDescriptorURL.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.EntityDescriptorURL.length);
                encoder.string(this.EntityDescriptorURL);
            }

            for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {
                const messageSize = this.AttributesToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.AttributesToRoles[n].encodeU8Array(encoder);
                }
            }

            if (this.SigningKeyPair != null) {
                const f = this.SigningKeyPair as types.AsymmetricKeyPair;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Provider.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.Provider.length);
                encoder.string(this.Provider);
            }

            if (this.EncryptionKeyPair != null) {
                const f = this.EncryptionKeyPair as types.AsymmetricKeyPair;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x6a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorSpecV2
    } // SAMLConnectorSpecV2

    // AttributeMapping maps a SAML attribute statement to teleport roles.
    export class AttributeMapping {
        // Name is an attribute statement name.
        public Name: string = "";
        // Value is an attribute statement value to match.
        public Value: string = "";
        // Roles is a list of static teleport roles to map to.
        public Roles: Array<string> = new Array<string>();

        // Decodes AttributeMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AttributeMapping {
            return AttributeMapping.decode(new DataView(buf));
        }

        // Decodes AttributeMapping from a DataView
        static decode(view: DataView): AttributeMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new AttributeMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Roles.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AttributeMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            return size;
        }

        // Encodes AttributeMapping to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AttributeMapping to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            return buf;
        } // encode AttributeMapping
    } // AttributeMapping

    /**
     * AsymmetricKeyPair is a combination of a public certificate and
     *  private key that can be used for encryption and signing.
     */
    export class AsymmetricKeyPair {
        // PrivateKey is a PEM encoded x509 private key.
        public PrivateKey: string = "";
        // Cert is a PEM-encoded x509 certificate.
        public Cert: string = "";

        // Decodes AsymmetricKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AsymmetricKeyPair {
            return AsymmetricKeyPair.decode(new DataView(buf));
        }

        // Decodes AsymmetricKeyPair from a DataView
        static decode(view: DataView): AsymmetricKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new AsymmetricKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PrivateKey = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Cert = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AsymmetricKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;

            return size;
        }

        // Encodes AsymmetricKeyPair to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AsymmetricKeyPair to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PrivateKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PrivateKey.length);
                encoder.string(this.PrivateKey);
            }
            if (this.Cert.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Cert.length);
                encoder.string(this.Cert);
            }

            return buf;
        } // encode AsymmetricKeyPair
    } // AsymmetricKeyPair

    // GithubConnectorV3 represents a Github connector.
    export class GithubConnectorV3 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is a resource version.
        public Version: string = "";
        // Metadata holds resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is an Github connector specification.
        public Spec: types.GithubConnectorSpecV3 =
            new types.GithubConnectorSpecV3();

        // Decodes GithubConnectorV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorV3 {
            return GithubConnectorV3.decode(new DataView(buf));
        }

        // Decodes GithubConnectorV3 from a DataView
        static decode(view: DataView): GithubConnectorV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.GithubConnectorSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.GithubConnectorSpecV3 = this
                    .Spec as types.GithubConnectorSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.GithubConnectorSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorV3
    } // GithubConnectorV3

    // GithubConnectorV3List is a list of Github connectors.
    export class GithubConnectorV3List {
        // GithubConnectors is a list of Github connectors.
        public GithubConnectors: Array<types.GithubConnectorV3> =
            new Array<types.GithubConnectorV3>();

        // Decodes GithubConnectorV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorV3List {
            return GithubConnectorV3List.decode(new DataView(buf));
        }

        // Decodes GithubConnectorV3List from a DataView
        static decode(view: DataView): GithubConnectorV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.GithubConnectors.push(
                            types.GithubConnectorV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {
                const messageSize = this.GithubConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorV3List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorV3List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {
                const messageSize = this.GithubConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.GithubConnectors[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorV3List
    } // GithubConnectorV3List

    // GithubConnectorSpecV3 is a Github connector specification.
    export class GithubConnectorSpecV3 {
        // ClientID is the Github OAuth app client ID.
        public ClientID: string = "";
        // ClientSecret is the Github OAuth app client secret.
        public ClientSecret: string = "";
        // RedirectURL is the authorization callback URL.
        public RedirectURL: string = "";
        // TeamsToLogins maps Github team memberships onto allowed logins/roles.
        public TeamsToLogins: Array<types.TeamMapping> =
            new Array<types.TeamMapping>();
        // Display is the connector display name.
        public Display: string = "";

        // Decodes GithubConnectorSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorSpecV3 {
            return GithubConnectorSpecV3.decode(new DataView(buf));
        }

        // Decodes GithubConnectorSpecV3 from a DataView
        static decode(view: DataView): GithubConnectorSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClientID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClientSecret = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.RedirectURL = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.TeamsToLogins.push(
                            types.TeamMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Display = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClientID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientID.length) +
                      this.ClientID.length
                    : 0;
            size +=
                this.ClientSecret.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientSecret.length) +
                      this.ClientSecret.length
                    : 0;
            size +=
                this.RedirectURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RedirectURL.length) +
                      this.RedirectURL.length
                    : 0;

            for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {
                const messageSize = this.TeamsToLogins[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;

            return size;
        }

        // Encodes GithubConnectorSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClientID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClientID.length);
                encoder.string(this.ClientID);
            }
            if (this.ClientSecret.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClientSecret.length);
                encoder.string(this.ClientSecret);
            }
            if (this.RedirectURL.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.RedirectURL.length);
                encoder.string(this.RedirectURL);
            }

            for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {
                const messageSize = this.TeamsToLogins[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.TeamsToLogins[n].encodeU8Array(encoder);
                }
            }

            if (this.Display.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }

            return buf;
        } // encode GithubConnectorSpecV3
    } // GithubConnectorSpecV3

    // TeamMapping represents a single team membership mapping.
    export class TeamMapping {
        // Organization is a Github organization a user belongs to.
        public Organization: string = "";
        // Team is a team within the organization a user belongs to.
        public Team: string = "";
        // Logins is a list of allowed logins for this org/team.
        public Logins: Array<string> = new Array<string>();
        // KubeGroups is a list of allowed kubernetes groups for this org/team.
        public KubeGroups: Array<string> = new Array<string>();
        // KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
        public KubeUsers: Array<string> = new Array<string>();

        // Decodes TeamMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TeamMapping {
            return TeamMapping.decode(new DataView(buf));
        }

        // Decodes TeamMapping from a DataView
        static decode(view: DataView): TeamMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new TeamMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Organization = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Team = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Logins.push(decoder.string());
                        break;
                    }
                    case 4: {
                        obj.KubeGroups.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.KubeUsers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TeamMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Organization.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Organization.length) +
                      this.Organization.length
                    : 0;
            size +=
                this.Team.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Team.length) +
                      this.Team.length
                    : 0;

            size += __size_string_repeated(this.Logins);

            size += __size_string_repeated(this.KubeGroups);

            size += __size_string_repeated(this.KubeUsers);

            return size;
        }

        // Encodes TeamMapping to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TeamMapping to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Organization.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Organization.length);
                encoder.string(this.Organization);
            }
            if (this.Team.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Team.length);
                encoder.string(this.Team);
            }

            if (this.Logins.length > 0) {
                for (let n: i32 = 0; n < this.Logins.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Logins[n].length);
                    encoder.string(this.Logins[n]);
                }
            }

            if (this.KubeGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubeGroups.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.KubeGroups[n].length);
                    encoder.string(this.KubeGroups[n]);
                }
            }

            if (this.KubeUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubeUsers.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.KubeUsers[n].length);
                    encoder.string(this.KubeUsers[n]);
                }
            }

            return buf;
        } // encode TeamMapping
    } // TeamMapping

    // TrustedClusterV2 represents a Trusted Cluster.
    export class TrustedClusterV2 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is a resource version.
        public Version: string = "";
        // Metadata holds resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a Trusted Cluster specification.
        public Spec: types.TrustedClusterSpecV2 =
            new types.TrustedClusterSpecV2();

        // Decodes TrustedClusterV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterV2 {
            return TrustedClusterV2.decode(new DataView(buf));
        }

        // Decodes TrustedClusterV2 from a DataView
        static decode(view: DataView): TrustedClusterV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.TrustedClusterSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.TrustedClusterSpecV2 = this
                    .Spec as types.TrustedClusterSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.TrustedClusterSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterV2
    } // TrustedClusterV2

    // TrustedClusterV2List is a list of trusted cluster.
    export class TrustedClusterV2List {
        // TrustedClusters is a list of trusted cluster.
        public TrustedClusters: Array<types.TrustedClusterV2> =
            new Array<types.TrustedClusterV2>();

        // Decodes TrustedClusterV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterV2List {
            return TrustedClusterV2List.decode(new DataView(buf));
        }

        // Decodes TrustedClusterV2List from a DataView
        static decode(view: DataView): TrustedClusterV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.TrustedClusters.push(
                            types.TrustedClusterV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {
                const messageSize = this.TrustedClusters[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterV2List to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterV2List to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {
                const messageSize = this.TrustedClusters[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.TrustedClusters[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterV2List
    } // TrustedClusterV2List

    // TrustedClusterSpecV2 is a Trusted Cluster specification.
    export class TrustedClusterSpecV2 {
        /**
         * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
         *  Setting Enabled to false has a side effect of deleting the user and host certificate
         *  authority (CA).
         */
        public Enabled: bool;
        // Roles is a list of roles that users will be assuming when connecting to this cluster.
        public Roles: Array<string> = new Array<string>();
        // Token is the authorization token provided by another cluster needed by this cluster to join.
        public Token: string = "";
        /**
         * ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
         *  it is derived from <metadata.name>:<default web proxy server port>.
         */
        public ProxyAddress: string = "";
        /**
         * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
         *  not set, it is derived from <metadata.name>:<default reverse tunnel port>.
         */
        public ReverseTunnelAddress: string = "";
        // RoleMap specifies role mappings to remote roles.
        public RoleMap: Array<types.RoleMapping> =
            new Array<types.RoleMapping>();

        // Decodes TrustedClusterSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterSpecV2 {
            return TrustedClusterSpecV2.decode(new DataView(buf));
        }

        // Decodes TrustedClusterSpecV2 from a DataView
        static decode(view: DataView): TrustedClusterSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Enabled = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Token = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.ProxyAddress = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ReverseTunnelAddress = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.RoleMap.push(
                            types.RoleMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size += this.Enabled == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.Roles);

            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;
            size +=
                this.ProxyAddress.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProxyAddress.length) +
                      this.ProxyAddress.length
                    : 0;
            size +=
                this.ReverseTunnelAddress.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ReverseTunnelAddress.length) +
                      this.ReverseTunnelAddress.length
                    : 0;

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Enabled != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Enabled);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Token.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }
            if (this.ProxyAddress.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.ProxyAddress.length);
                encoder.string(this.ProxyAddress);
            }
            if (this.ReverseTunnelAddress.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ReverseTunnelAddress.length);
                encoder.string(this.ReverseTunnelAddress);
            }

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    this.RoleMap[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterSpecV2
    } // TrustedClusterSpecV2

    /**
     * LockV2 represents a lock.
     *  Locks are used to restrict access to a Teleport environment by disabling
     *  interactions involving a user, an RBAC role, a node, etc.
     *  See rfd/0009-locking.md for more details.
     */
    export class LockV2 {
        // Kind is a resource kind.
        public Kind: string = "";
        // SubKind is an optional resource sub kind, used in some resources.
        public SubKind: string = "";
        // Version is a resource version.
        public Version: string = "";
        // Metadata holds resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is a Lock specification.
        public Spec: types.LockSpecV2 = new types.LockSpecV2();

        // Decodes LockV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockV2 {
            return LockV2.decode(new DataView(buf));
        }

        // Decodes LockV2 from a DataView
        static decode(view: DataView): LockV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new LockV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.LockSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.LockSpecV2 = this.Spec as types.LockSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.LockSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LockV2
    } // LockV2

    // LockSpecV2 is a Lock specification.
    export class LockSpecV2 {
        // Target describes the set of interactions that the lock applies to.
        public Target: types.LockTarget = new types.LockTarget();
        // Message is the message displayed to locked-out users.
        public Message: string = "";
        // Expires if set specifies when the lock ceases to be in force.
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes LockSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockSpecV2 {
            return LockSpecV2.decode(new DataView(buf));
        }

        // Decodes LockSpecV2 from a DataView
        static decode(view: DataView): LockSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new LockSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Target = types.LockTarget.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.Message = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockSpecV2

        public size(): u32 {
            let size: u32 = 0;

            if (this.Target != null) {
                const f: types.LockTarget = this.Target as types.LockTarget;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Message.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Message.length) +
                      this.Message.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockSpecV2 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockSpecV2 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Target != null) {
                const f = this.Target as types.LockTarget;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Message.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Message.length);
                encoder.string(this.Message);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LockSpecV2
    } // LockSpecV2

    // LockTarget lists the attributes of interactions to be disabled.
    export class LockTarget {
        // User specifies the name of a Teleport user.
        public User: string = "";
        /**
         * Role specifies the name of an RBAC role known to the root cluster.
         *  In remote clusters, this constraint is evaluated before translating to local roles.
         */
        public Role: string = "";
        // Login specifies the name of a local UNIX user.
        public Login: string = "";
        /**
         * Node specifies the UUID of a Teleport node.
         *  A matching node is also prevented from heartbeating to the auth server.
         */
        public Node: string = "";
        // MFADevice specifies the UUID of a user MFA device.
        public MFADevice: string = "";
        // WindowsDesktop specifies the name of a Windows desktop.
        public WindowsDesktop: string = "";
        // AccessRequest specifies the UUID of an access request.
        public AccessRequest: string = "";

        // Decodes LockTarget from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockTarget {
            return LockTarget.decode(new DataView(buf));
        }

        // Decodes LockTarget from a DataView
        static decode(view: DataView): LockTarget {
            const decoder = new __proto.Decoder(view);
            const obj = new LockTarget();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Role = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Login = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Node = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.MFADevice = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.WindowsDesktop = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.AccessRequest = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockTarget

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Role.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Role.length) +
                      this.Role.length
                    : 0;
            size +=
                this.Login.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Login.length) +
                      this.Login.length
                    : 0;
            size +=
                this.Node.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Node.length) +
                      this.Node.length
                    : 0;
            size +=
                this.MFADevice.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.MFADevice.length) +
                      this.MFADevice.length
                    : 0;
            size +=
                this.WindowsDesktop.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WindowsDesktop.length) +
                      this.WindowsDesktop.length
                    : 0;
            size +=
                this.AccessRequest.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AccessRequest.length) +
                      this.AccessRequest.length
                    : 0;

            return size;
        }

        // Encodes LockTarget to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockTarget to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Role.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Role.length);
                encoder.string(this.Role);
            }
            if (this.Login.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Login.length);
                encoder.string(this.Login);
            }
            if (this.Node.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Node.length);
                encoder.string(this.Node);
            }
            if (this.MFADevice.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.MFADevice.length);
                encoder.string(this.MFADevice);
            }
            if (this.WindowsDesktop.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.WindowsDesktop.length);
                encoder.string(this.WindowsDesktop);
            }
            if (this.AccessRequest.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.AccessRequest.length);
                encoder.string(this.AccessRequest);
            }

            return buf;
        } // encode LockTarget
    } // LockTarget

    /**
     * AddressCondition represents a set of addresses. Presently the addresses are specfied
     *  exclusively in terms of IPv4/IPv6 ranges.
     */
    export class AddressCondition {
        /**
         * CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
         *  "fe::/8") or a single IP address (e.g "10.1.2.3")
         */
        public CIDR: string = "";

        // Decodes AddressCondition from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AddressCondition {
            return AddressCondition.decode(new DataView(buf));
        }

        // Decodes AddressCondition from a DataView
        static decode(view: DataView): AddressCondition {
            const decoder = new __proto.Decoder(view);
            const obj = new AddressCondition();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.CIDR = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AddressCondition

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.CIDR.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CIDR.length) +
                      this.CIDR.length
                    : 0;

            return size;
        }

        // Encodes AddressCondition to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AddressCondition to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.CIDR.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.CIDR.length);
                encoder.string(this.CIDR);
            }

            return buf;
        } // encode AddressCondition
    } // AddressCondition

    export class NetworkRestrictionsSpecV4 {
        // Allow lists the addresses that should be allowed.
        public Allow: Array<types.AddressCondition> =
            new Array<types.AddressCondition>();
        // Deny lists the addresses that should be denied even if they're allowed by Allow condition.
        public Deny: Array<types.AddressCondition> =
            new Array<types.AddressCondition>();

        // Decodes NetworkRestrictionsSpecV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NetworkRestrictionsSpecV4 {
            return NetworkRestrictionsSpecV4.decode(new DataView(buf));
        }

        // Decodes NetworkRestrictionsSpecV4 from a DataView
        static decode(view: DataView): NetworkRestrictionsSpecV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new NetworkRestrictionsSpecV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Allow.push(
                            types.AddressCondition.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Deny.push(
                            types.AddressCondition.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NetworkRestrictionsSpecV4

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Deny.length; n++) {
                const messageSize = this.Deny[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes NetworkRestrictionsSpecV4 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NetworkRestrictionsSpecV4 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Allow[n].encodeU8Array(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Deny.length; n++) {
                const messageSize = this.Deny[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.Deny[n].encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode NetworkRestrictionsSpecV4
    } // NetworkRestrictionsSpecV4

    /**
     * NetworkRestrictions specifies a list of addresses to restrict (block). The deny
     *  list is checked first and the allow lists overrides it. Thus an empty allow
     *  list does not mean that no addresses will be allowed, that will only be the
     *  case if the deny list covers the whole address range.
     */
    export class NetworkRestrictionsV4 {
        // Kind is the network restrictions resource kind.
        public Kind: string = "";
        // SubKind is an optional resource subkind.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the network restrictions metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec contains the network restrictions data
        public Spec: types.NetworkRestrictionsSpecV4 =
            new types.NetworkRestrictionsSpecV4();

        // Decodes NetworkRestrictionsV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NetworkRestrictionsV4 {
            return NetworkRestrictionsV4.decode(new DataView(buf));
        }

        // Decodes NetworkRestrictionsV4 from a DataView
        static decode(view: DataView): NetworkRestrictionsV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new NetworkRestrictionsV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.NetworkRestrictionsSpecV4.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NetworkRestrictionsV4

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.NetworkRestrictionsSpecV4 = this
                    .Spec as types.NetworkRestrictionsSpecV4;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes NetworkRestrictionsV4 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NetworkRestrictionsV4 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.NetworkRestrictionsSpecV4;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode NetworkRestrictionsV4
    } // NetworkRestrictionsV4

    // WindowsDesktopServiceV3 represents a windows desktop access service.
    export class WindowsDesktopServiceV3 {
        // Header is the common resource header.
        public Header: types.ResourceHeader = new types.ResourceHeader();
        // Spec is the windows desktop service spec.
        public Spec: types.WindowsDesktopServiceSpecV3 =
            new types.WindowsDesktopServiceSpecV3();

        // Decodes WindowsDesktopServiceV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopServiceV3 {
            return WindowsDesktopServiceV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopServiceV3 from a DataView
        static decode(view: DataView): WindowsDesktopServiceV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopServiceV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Header = types.ResourceHeader.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Spec = types.WindowsDesktopServiceSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopServiceV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Header != null) {
                const f: types.ResourceHeader = this
                    .Header as types.ResourceHeader;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WindowsDesktopServiceSpecV3 = this
                    .Spec as types.WindowsDesktopServiceSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WindowsDesktopServiceV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopServiceV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Header != null) {
                const f = this.Header as types.ResourceHeader;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WindowsDesktopServiceSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode WindowsDesktopServiceV3
    } // WindowsDesktopServiceV3

    // WindowsDesktopServiceSpecV3 is the windows desktop service spec.
    export class WindowsDesktopServiceSpecV3 {
        // Addr is the address that this service can be reached at.
        public Addr: string = "";
        // TeleportVersion is teleport binary version running this service.
        public TeleportVersion: string = "";

        // Decodes WindowsDesktopServiceSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): WindowsDesktopServiceSpecV3 {
            return WindowsDesktopServiceSpecV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopServiceSpecV3 from a DataView
        static decode(view: DataView): WindowsDesktopServiceSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopServiceSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.TeleportVersion = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopServiceSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.TeleportVersion.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TeleportVersion.length) +
                      this.TeleportVersion.length
                    : 0;

            return size;
        }

        // Encodes WindowsDesktopServiceSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopServiceSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.TeleportVersion.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.TeleportVersion.length);
                encoder.string(this.TeleportVersion);
            }

            return buf;
        } // encode WindowsDesktopServiceSpecV3
    } // WindowsDesktopServiceSpecV3

    // WindowsDesktopV3 represents a Windows host for desktop access.
    export class WindowsDesktopV3 {
        // Header is the common resource header.
        public Header: types.ResourceHeader = new types.ResourceHeader();
        // Spec is the Windows host spec.
        public Spec: types.WindowsDesktopSpecV3 =
            new types.WindowsDesktopSpecV3();

        // Decodes WindowsDesktopV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopV3 {
            return WindowsDesktopV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopV3 from a DataView
        static decode(view: DataView): WindowsDesktopV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Header = types.ResourceHeader.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Spec = types.WindowsDesktopSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Header != null) {
                const f: types.ResourceHeader = this
                    .Header as types.ResourceHeader;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WindowsDesktopSpecV3 = this
                    .Spec as types.WindowsDesktopSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WindowsDesktopV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Header != null) {
                const f = this.Header as types.ResourceHeader;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WindowsDesktopSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode WindowsDesktopV3
    } // WindowsDesktopV3

    // WindowsDesktopSpecV3 is the Windows host spec.
    export class WindowsDesktopSpecV3 {
        // Addr is the address that this host can be reached at.
        public Addr: string = "";
        // Domain is the ActiveDirectory domain that this host belongs to.
        public Domain: string = "";

        // Decodes WindowsDesktopSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSpecV3 {
            return WindowsDesktopSpecV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSpecV3 from a DataView
        static decode(view: DataView): WindowsDesktopSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Domain = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;

            return size;
        }

        // Encodes WindowsDesktopSpecV3 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSpecV3 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }

            return buf;
        } // encode WindowsDesktopSpecV3
    } // WindowsDesktopSpecV3

    /**
     * RegisterUsingTokenRequest is a request to register with the auth server using
     *  an authentication token
     */
    export class RegisterUsingTokenRequest {
        // HostID is a unique host ID, usually a UUID
        public HostID: string = "";
        // NodeName is a node name
        public NodeName: string = "";
        // Role is a system role, e.g. Proxy
        public Role: string = "";
        // Token is the name of an authentication token
        public Token: string = "";
        // AdditionalPrincipals is a list of additional principals
        public AdditionalPrincipals: Array<string> = new Array<string>();
        // DNSNames is a list of DNS names to include in the x509 client certificate
        public DNSNames: Array<string> = new Array<string>();
        /**
         * PublicTLSKey is a PEM encoded public key
         *  used for TLS setup
         */
        public PublicTLSKey: Array<u8> = new Array<u8>();
        /**
         * PublicSSHKey is a SSH encoded public key,
         *  if present will be signed as a return value
         *  otherwise, new public/private key pair will be generated
         */
        public PublicSSHKey: Array<u8> = new Array<u8>();
        /**
         * RemoteAddr is the remote address of the host requesting a host certificate.
         *  It is used to replace 0.0.0.0 in the list of additional principals.
         */
        public RemoteAddr: string = "";
        /**
         * EC2IdentityDocument is used for the EC2 join method to prove the identity
         *  of a joining EC2 instance.
         */
        public EC2IdentityDocument: Array<u8> = new Array<u8>();

        // Decodes RegisterUsingTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RegisterUsingTokenRequest {
            return RegisterUsingTokenRequest.decode(new DataView(buf));
        }

        // Decodes RegisterUsingTokenRequest from a DataView
        static decode(view: DataView): RegisterUsingTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new RegisterUsingTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.NodeName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Role = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Token = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AdditionalPrincipals.push(decoder.string());
                        break;
                    }
                    case 6: {
                        obj.DNSNames.push(decoder.string());
                        break;
                    }
                    case 7: {
                        obj.PublicTLSKey = decoder.bytes();
                        break;
                    }
                    case 8: {
                        obj.PublicSSHKey = decoder.bytes();
                        break;
                    }
                    case 9: {
                        obj.RemoteAddr = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.EC2IdentityDocument = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RegisterUsingTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;
            size +=
                this.NodeName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.NodeName.length) +
                      this.NodeName.length
                    : 0;
            size +=
                this.Role.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Role.length) +
                      this.Role.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            size += __size_string_repeated(this.AdditionalPrincipals);

            size += __size_string_repeated(this.DNSNames);

            size +=
                this.PublicTLSKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicTLSKey.length) +
                      this.PublicTLSKey.length
                    : 0;
            size +=
                this.PublicSSHKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicSSHKey.length) +
                      this.PublicSSHKey.length
                    : 0;
            size +=
                this.RemoteAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RemoteAddr.length) +
                      this.RemoteAddr.length
                    : 0;
            size +=
                this.EC2IdentityDocument.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EC2IdentityDocument.length) +
                      this.EC2IdentityDocument.length
                    : 0;

            return size;
        }

        // Encodes RegisterUsingTokenRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RegisterUsingTokenRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.HostID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }
            if (this.NodeName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.NodeName.length);
                encoder.string(this.NodeName);
            }
            if (this.Role.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Role.length);
                encoder.string(this.Role);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            if (this.AdditionalPrincipals.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AdditionalPrincipals.length;
                    n++
                ) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.AdditionalPrincipals[n].length);
                    encoder.string(this.AdditionalPrincipals[n]);
                }
            }

            if (this.DNSNames.length > 0) {
                for (let n: i32 = 0; n < this.DNSNames.length; n++) {
                    encoder.uint32(0x32);
                    encoder.uint32(this.DNSNames[n].length);
                    encoder.string(this.DNSNames[n]);
                }
            }

            if (this.PublicTLSKey.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.PublicTLSKey.length);
                encoder.bytes(this.PublicTLSKey);
            }
            if (this.PublicSSHKey.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.PublicSSHKey.length);
                encoder.bytes(this.PublicSSHKey);
            }
            if (this.RemoteAddr.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.RemoteAddr.length);
                encoder.string(this.RemoteAddr);
            }
            if (this.EC2IdentityDocument.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.EC2IdentityDocument.length);
                encoder.bytes(this.EC2IdentityDocument);
            }

            return buf;
        } // encode RegisterUsingTokenRequest
    } // RegisterUsingTokenRequest

    /**
     * RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
     *  access to their account by restoring their lost password or second factor. Once a recovery code
     *  is successfully verified, the code is mark used (which invalidates it), and lets the user begin
     *  the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
     *  of codes that will replace all the previous ones.
     */
    export class RecoveryCodesV1 {
        // Kind is the resource kind.
        public Kind: string = "";
        // SubKind is an optional resource subkind. Currently unused for this resource.
        public SubKind: string = "";
        // Version is the resource version.
        public Version: string = "";
        // Metadata is the resource metadata.
        public Metadata: types.Metadata = new types.Metadata();
        // Spec is the resource spec.
        public Spec: types.RecoveryCodesSpecV1 =
            new types.RecoveryCodesSpecV1();

        // Decodes RecoveryCodesV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodesV1 {
            return RecoveryCodesV1.decode(new DataView(buf));
        }

        // Decodes RecoveryCodesV1 from a DataView
        static decode(view: DataView): RecoveryCodesV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodesV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.RecoveryCodesSpecV1.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodesV1

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.RecoveryCodesSpecV1 = this
                    .Spec as types.RecoveryCodesSpecV1;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodesV1 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodesV1 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.RecoveryCodesSpecV1;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodesV1
    } // RecoveryCodesV1

    // RecoveryCodesSpecV1 is the recovery codes spec.
    export class RecoveryCodesSpecV1 {
        // Codes hold a list of numOfRecoveryCodes.
        public Codes: Array<types.RecoveryCode> =
            new Array<types.RecoveryCode>();
        /**
         * Created is when the set of recovery codes were generated. Updated when a new set of recovery
         *  codes are inserted.
         */
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RecoveryCodesSpecV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodesSpecV1 {
            return RecoveryCodesSpecV1.decode(new DataView(buf));
        }

        // Decodes RecoveryCodesSpecV1 from a DataView
        static decode(view: DataView): RecoveryCodesSpecV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodesSpecV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Codes.push(
                            types.RecoveryCode.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodesSpecV1

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Codes.length; n++) {
                const messageSize = this.Codes[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodesSpecV1 to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodesSpecV1 to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Codes.length; n++) {
                const messageSize = this.Codes[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Codes[n].encodeU8Array(encoder);
                }
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodesSpecV1
    } // RecoveryCodesSpecV1

    // RecoveryCode describes a recovery code.
    export class RecoveryCode {
        // HashedCode is a bcrypt hash of this recovery code.
        public HashedCode: Array<u8> = new Array<u8>();
        // IsUsed determines if this recovery code was used.
        public IsUsed: bool;

        // Decodes RecoveryCode from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCode {
            return RecoveryCode.decode(new DataView(buf));
        }

        // Decodes RecoveryCode from a DataView
        static decode(view: DataView): RecoveryCode {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCode();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.HashedCode = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.IsUsed = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCode

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.HashedCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HashedCode.length) +
                      this.HashedCode.length
                    : 0;
            size += this.IsUsed == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes RecoveryCode to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCode to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.HashedCode.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.HashedCode.length);
                encoder.bytes(this.HashedCode);
            }
            if (this.IsUsed != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.IsUsed);
            }

            return buf;
        } // encode RecoveryCode
    } // RecoveryCode
} // types
export namespace events {
    // Action communicates what was done in response to the event
    export enum EventAction {
        OBSERVED = 0,
        DENIED = 1,
    } // EventAction
    // Metadata is a common event metadata
    export class Metadata {
        // Index is a monotonicaly incremented index in the event sequence
        public Index: i64;
        // Type is the event type
        public Type: string = "";
        // ID is a unique event identifier
        public ID: string = "";
        // Code is a unique event code
        public Code: string = "";
        // Time is event time
        public Time: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // ClusterName identifies the originating teleport cluster
        public ClusterName: string = "";

        // Decodes Metadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Metadata {
            return Metadata.decode(new DataView(buf));
        }

        // Decodes Metadata from a DataView
        static decode(view: DataView): Metadata {
            const decoder = new __proto.Decoder(view);
            const obj = new Metadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Index = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Code = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Time = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.ClusterName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Metadata

        public size(): u32 {
            let size: u32 = 0;

            size += this.Index == 0 ? 0 : 1 + __proto.Sizer.int64(this.Index);
            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.Code.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Code.length) +
                      this.Code.length
                    : 0;

            if (this.Time != null) {
                const f: google.protobuf.Timestamp = this
                    .Time as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            return size;
        }

        // Encodes Metadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Metadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Index != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.Index);
            }
            if (this.Type.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.Code.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Code.length);
                encoder.string(this.Code);
            }

            if (this.Time != null) {
                const f = this.Time as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ClusterName.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            return buf;
        } // encode Metadata
    } // Metadata

    // SessionData is emitted to report session data usage.
    export class SessionMetadata {
        // SessionID is a unique UUID of the session.
        public SessionID: string = "";
        // WithMFA is a UUID of an MFA device used to start this session.
        public WithMFA: string = "";

        // Decodes SessionMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionMetadata {
            return SessionMetadata.decode(new DataView(buf));
        }

        // Decodes SessionMetadata from a DataView
        static decode(view: DataView): SessionMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SessionID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.WithMFA = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;
            size +=
                this.WithMFA.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WithMFA.length) +
                      this.WithMFA.length
                    : 0;

            return size;
        }

        // Encodes SessionMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SessionID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }
            if (this.WithMFA.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.WithMFA.length);
                encoder.string(this.WithMFA);
            }

            return buf;
        } // encode SessionMetadata
    } // SessionMetadata

    // X11Forward is emitted when a user requests X11 protocol forwarding
    export class UserMetadata {
        // User is teleport user name
        public User: string = "";
        // Login is OS login
        public Login: string = "";
        // Impersonator is a user acting on behalf of another user
        public Impersonator: string = "";
        // AWSRoleARN is AWS IAM role user assumes when accessing AWS console.
        public AWSRoleARN: string = "";
        // AccessRequests are the IDs of access requests created by the user
        public AccessRequests: Array<string> = new Array<string>();

        // Decodes UserMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserMetadata {
            return UserMetadata.decode(new DataView(buf));
        }

        // Decodes UserMetadata from a DataView
        static decode(view: DataView): UserMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new UserMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Login = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Impersonator = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.AWSRoleARN = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AccessRequests.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Login.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Login.length) +
                      this.Login.length
                    : 0;
            size +=
                this.Impersonator.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Impersonator.length) +
                      this.Impersonator.length
                    : 0;
            size +=
                this.AWSRoleARN.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSRoleARN.length) +
                      this.AWSRoleARN.length
                    : 0;

            size += __size_string_repeated(this.AccessRequests);

            return size;
        }

        // Encodes UserMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Login.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Login.length);
                encoder.string(this.Login);
            }
            if (this.Impersonator.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Impersonator.length);
                encoder.string(this.Impersonator);
            }
            if (this.AWSRoleARN.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AWSRoleARN.length);
                encoder.string(this.AWSRoleARN);
            }

            if (this.AccessRequests.length > 0) {
                for (let n: i32 = 0; n < this.AccessRequests.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.AccessRequests[n].length);
                    encoder.string(this.AccessRequests[n]);
                }
            }

            return buf;
        } // encode UserMetadata
    } // UserMetadata

    // TrustedClusterCreate is the event for creating a trusted cluster.
    export class ServerMetadata {
        // ServerNamespace is a namespace of the server event
        public ServerNamespace: string = "";
        // ServerID is the UUID of the server the session occurred on.
        public ServerID: string = "";
        // ServerHostname is the hostname of the server the session occurred on.
        public ServerHostname: string = "";
        // ServerAddr is the address of the server the session occurred on.
        public ServerAddr: string = "";
        /**
         * ServerLabels are the labels (static and dynamic) of the server the
         *  session occurred on.
         */
        public ServerLabels: Map<string, string> = new Map<string, string>();

        // Decodes ServerMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerMetadata {
            return ServerMetadata.decode(new DataView(buf));
        }

        // Decodes ServerMetadata from a DataView
        static decode(view: DataView): ServerMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ServerNamespace = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ServerID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ServerHostname = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.ServerAddr = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.ServerLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ServerNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerNamespace.length) +
                      this.ServerNamespace.length
                    : 0;
            size +=
                this.ServerID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerID.length) +
                      this.ServerID.length
                    : 0;
            size +=
                this.ServerHostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerHostname.length) +
                      this.ServerHostname.length
                    : 0;
            size +=
                this.ServerAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerAddr.length) +
                      this.ServerAddr.length
                    : 0;

            if (this.ServerLabels.size > 0) {
                const keys = this.ServerLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.ServerLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes ServerMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ServerNamespace.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ServerNamespace.length);
                encoder.string(this.ServerNamespace);
            }
            if (this.ServerID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ServerID.length);
                encoder.string(this.ServerID);
            }
            if (this.ServerHostname.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ServerHostname.length);
                encoder.string(this.ServerHostname);
            }
            if (this.ServerAddr.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.ServerAddr.length);
                encoder.string(this.ServerAddr);
            }

            if (this.ServerLabels.size > 0) {
                const keys = this.ServerLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.ServerLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode ServerMetadata
    } // ServerMetadata

    // AppMetadata contains common application information.
    export class ConnectionMetadata {
        // LocalAddr is a target address on the host
        public LocalAddr: string = "";
        // RemoteAddr is a client (user's) address
        public RemoteAddr: string = "";
        // Protocol specifies protocol that was captured
        public Protocol: string = "";

        // Decodes ConnectionMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ConnectionMetadata {
            return ConnectionMetadata.decode(new DataView(buf));
        }

        // Decodes ConnectionMetadata from a DataView
        static decode(view: DataView): ConnectionMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ConnectionMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.LocalAddr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.RemoteAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Protocol = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ConnectionMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.LocalAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LocalAddr.length) +
                      this.LocalAddr.length
                    : 0;
            size +=
                this.RemoteAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RemoteAddr.length) +
                      this.RemoteAddr.length
                    : 0;
            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;

            return size;
        }

        // Encodes ConnectionMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ConnectionMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.LocalAddr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.LocalAddr.length);
                encoder.string(this.LocalAddr);
            }
            if (this.RemoteAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.RemoteAddr.length);
                encoder.string(this.RemoteAddr);
            }
            if (this.Protocol.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }

            return buf;
        } // encode ConnectionMetadata
    } // ConnectionMetadata

    // DatabaseDelete is emitted when a database resource is deleted.
    export class KubernetesClusterMetadata {
        // KubernetesCluster is a kubernetes cluster name.
        public KubernetesCluster: string = "";
        // KubernetesUsers is a list of kubernetes usernames for the user.
        public KubernetesUsers: Array<string> = new Array<string>();
        // KubernetesGroups is a list of kubernetes groups for the user.
        public KubernetesGroups: Array<string> = new Array<string>();

        // Decodes KubernetesClusterMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterMetadata {
            return KubernetesClusterMetadata.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterMetadata from a DataView
        static decode(view: DataView): KubernetesClusterMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.KubernetesCluster = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.KubernetesUsers.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.KubernetesGroups.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.KubernetesCluster.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesCluster.length) +
                      this.KubernetesCluster.length
                    : 0;

            size += __size_string_repeated(this.KubernetesUsers);

            size += __size_string_repeated(this.KubernetesGroups);

            return size;
        }

        // Encodes KubernetesClusterMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.KubernetesCluster.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.KubernetesCluster.length);
                encoder.string(this.KubernetesCluster);
            }

            if (this.KubernetesUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesUsers.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.KubernetesUsers[n].length);
                    encoder.string(this.KubernetesUsers[n]);
                }
            }

            if (this.KubernetesGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesGroups.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.KubernetesGroups[n].length);
                    encoder.string(this.KubernetesGroups[n]);
                }
            }

            return buf;
        } // encode KubernetesClusterMetadata
    } // KubernetesClusterMetadata

    // BillingCardDelete is emitted when a user deletes a credit card.
    export class KubernetesPodMetadata {
        // KubernetesPodName is the name of the pod.
        public KubernetesPodName: string = "";
        // KubernetesPodNamespace is the namespace of the pod.
        public KubernetesPodNamespace: string = "";
        // KubernetesContainerName is the name of the container within the pod.
        public KubernetesContainerName: string = "";
        // KubernetesContainerImage is the image of the container within the pod.
        public KubernetesContainerImage: string = "";
        // KubernetesNodeName is the node that runs the pod.
        public KubernetesNodeName: string = "";

        // Decodes KubernetesPodMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesPodMetadata {
            return KubernetesPodMetadata.decode(new DataView(buf));
        }

        // Decodes KubernetesPodMetadata from a DataView
        static decode(view: DataView): KubernetesPodMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesPodMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.KubernetesPodName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.KubernetesPodNamespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.KubernetesContainerName = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.KubernetesContainerImage = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.KubernetesNodeName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesPodMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.KubernetesPodName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesPodName.length) +
                      this.KubernetesPodName.length
                    : 0;
            size +=
                this.KubernetesPodNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesPodNamespace.length
                      ) +
                      this.KubernetesPodNamespace.length
                    : 0;
            size +=
                this.KubernetesContainerName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesContainerName.length
                      ) +
                      this.KubernetesContainerName.length
                    : 0;
            size +=
                this.KubernetesContainerImage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesContainerImage.length
                      ) +
                      this.KubernetesContainerImage.length
                    : 0;
            size +=
                this.KubernetesNodeName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesNodeName.length) +
                      this.KubernetesNodeName.length
                    : 0;

            return size;
        }

        // Encodes KubernetesPodMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesPodMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.KubernetesPodName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.KubernetesPodName.length);
                encoder.string(this.KubernetesPodName);
            }
            if (this.KubernetesPodNamespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.KubernetesPodNamespace.length);
                encoder.string(this.KubernetesPodNamespace);
            }
            if (this.KubernetesContainerName.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.KubernetesContainerName.length);
                encoder.string(this.KubernetesContainerName);
            }
            if (this.KubernetesContainerImage.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.KubernetesContainerImage.length);
                encoder.string(this.KubernetesContainerImage);
            }
            if (this.KubernetesNodeName.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.KubernetesNodeName.length);
                encoder.string(this.KubernetesNodeName);
            }

            return buf;
        } // encode KubernetesPodMetadata
    } // KubernetesPodMetadata

    /**
     * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except
     *  for RouteToApp and RouteToDatabase which are nullable and Traits which is
     *  represented as a google.protobuf.Struct (still containing a map from string
     *  to strings). Field names match other names already used in other events
     *  rather than the field names in tlsca.Identity.
     */
    export class SessionStart {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // TerminalSize is expressed as 'W:H'
        public TerminalSize: string = "";
        /**
         * KubernetesCluster has information about a kubernetes cluster, if
         *  applicable.
         */
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        // KubernetesPod has information about a kubernetes pod, if applicable.
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();
        // InitialCommand is the command used to start this session.
        public InitialCommand: Array<string> = new Array<string>();
        // SessionRecording is the type of session recording.
        public SessionRecording: string = "";

        // Decodes SessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionStart {
            return SessionStart.decode(new DataView(buf));
        }

        // Decodes SessionStart from a DataView
        static decode(view: DataView): SessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.TerminalSize = decoder.string();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.InitialCommand.push(decoder.string());
                        break;
                    }
                    case 10: {
                        obj.SessionRecording = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.TerminalSize.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TerminalSize.length) +
                      this.TerminalSize.length
                    : 0;

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.InitialCommand);

            size +=
                this.SessionRecording.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionRecording.length) +
                      this.SessionRecording.length
                    : 0;

            return size;
        }

        // Encodes SessionStart to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionStart to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TerminalSize.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.TerminalSize.length);
                encoder.string(this.TerminalSize);
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.InitialCommand.length > 0) {
                for (let n: i32 = 0; n < this.InitialCommand.length; n++) {
                    encoder.uint32(0x4a);
                    encoder.uint32(this.InitialCommand[n].length);
                    encoder.string(this.InitialCommand[n]);
                }
            }

            if (this.SessionRecording.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.SessionRecording.length);
                encoder.string(this.SessionRecording);
            }

            return buf;
        } // encode SessionStart
    } // SessionStart

    // RouteToDatabase combines parameters for database service routing information.
    export class SessionJoin {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        /**
         * KubernetesCluster has information about a kubernetes cluster, if
         *  applicable.
         */
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();

        // Decodes SessionJoin from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionJoin {
            return SessionJoin.decode(new DataView(buf));
        }

        // Decodes SessionJoin from a DataView
        static decode(view: DataView): SessionJoin {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionJoin();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionJoin

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionJoin to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionJoin to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SessionJoin
    } // SessionJoin

    /**
     * SessionPrint event happens every time a write occurs to
     *  temirnal I/O during a session
     */
    export class SessionPrint {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ChunkIndex is a monotonicaly incremented index for ordering print events
        public ChunkIndex: i64;
        // Data is data transferred, it is not marshaled to JSON format
        public Data: Array<u8> = new Array<u8>();
        /**
         * Bytes says how many bytes have been written into the session
         *  during "print" event
         */
        public Bytes: i64;
        // DelayMilliseconds is the delay in milliseconds from the start of the session
        public DelayMilliseconds: i64;
        // Offset is the offset in bytes in the session file
        public Offset: i64;

        // Decodes SessionPrint from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionPrint {
            return SessionPrint.decode(new DataView(buf));
        }

        // Decodes SessionPrint from a DataView
        static decode(view: DataView): SessionPrint {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionPrint();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.ChunkIndex = decoder.int64();
                        break;
                    }
                    case 3: {
                        obj.Data = decoder.bytes();
                        break;
                    }
                    case 4: {
                        obj.Bytes = decoder.int64();
                        break;
                    }
                    case 5: {
                        obj.DelayMilliseconds = decoder.int64();
                        break;
                    }
                    case 6: {
                        obj.Offset = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionPrint

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.ChunkIndex == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ChunkIndex);
            size +=
                this.Data.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Data.length) +
                      this.Data.length
                    : 0;
            size += this.Bytes == 0 ? 0 : 1 + __proto.Sizer.int64(this.Bytes);
            size +=
                this.DelayMilliseconds == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.DelayMilliseconds);
            size += this.Offset == 0 ? 0 : 1 + __proto.Sizer.int64(this.Offset);

            return size;
        }

        // Encodes SessionPrint to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionPrint to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ChunkIndex != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.ChunkIndex);
            }
            if (this.Data.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Data.length);
                encoder.bytes(this.Data);
            }
            if (this.Bytes != 0) {
                encoder.uint32(0x20);
                encoder.int64(this.Bytes);
            }
            if (this.DelayMilliseconds != 0) {
                encoder.uint32(0x28);
                encoder.int64(this.DelayMilliseconds);
            }
            if (this.Offset != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.Offset);
            }

            return buf;
        } // encode SessionPrint
    } // SessionPrint

    // SessionReject event happens when a user hits a session control restriction.
    export class SessionReject {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        /**
         * Reason is a field that specifies reason for event, e.g. in disconnect
         *  event it explains why server disconnected the client
         */
        public Reason: string = "";
        /**
         * Maximum is an event field specifying a maximal value (e.g. the value
         *  of `max_connections` for a `session.rejected` event).
         */
        public Maximum: i64;

        // Decodes SessionReject from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionReject {
            return SessionReject.decode(new DataView(buf));
        }

        // Decodes SessionReject from a DataView
        static decode(view: DataView): SessionReject {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionReject();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Maximum = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionReject

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;
            size +=
                this.Maximum == 0 ? 0 : 1 + __proto.Sizer.int64(this.Maximum);

            return size;
        }

        // Encodes SessionReject to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionReject to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Reason.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }
            if (this.Maximum != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.Maximum);
            }

            return buf;
        } // encode SessionReject
    } // SessionReject

    // SessionConnect is emitted when a non-Teleport connection is made over net.Dial.
    export class SessionConnect {
        public Metadata: events.Metadata = new events.Metadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();

        // Decodes SessionConnect from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionConnect {
            return SessionConnect.decode(new DataView(buf));
        }

        // Decodes SessionConnect from a DataView
        static decode(view: DataView): SessionConnect {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionConnect();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionConnect

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionConnect to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionConnect to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SessionConnect
    } // SessionConnect

    // Resize means that some user resized PTY on the client
    export class Resize {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // TerminalSize is expressed as 'W:H'
        public TerminalSize: string = "";
        /**
         * KubernetesCluster has information about a kubernetes cluster, if
         *  applicable.
         */
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        // KubernetesPod has information about a kubernetes pod, if applicable.
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();

        // Decodes Resize from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Resize {
            return Resize.decode(new DataView(buf));
        }

        // Decodes Resize from a DataView
        static decode(view: DataView): Resize {
            const decoder = new __proto.Decoder(view);
            const obj = new Resize();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.TerminalSize = decoder.string();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Resize

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.TerminalSize.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TerminalSize.length) +
                      this.TerminalSize.length
                    : 0;

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Resize to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Resize to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TerminalSize.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.TerminalSize.length);
                encoder.string(this.TerminalSize);
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode Resize
    } // Resize

    // SessionEnd is a session end event
    export class SessionEnd {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        /**
         * EnhancedRecording is used to indicate if the recording was an
         *  enhanced recording or not.
         */
        public EnhancedRecording: bool;
        /**
         * Interactive is used to indicate if the session was interactive
         *  (has PTY attached) or not (exec session).
         */
        public Interactive: bool;
        // Participants is a list of participants in the session.
        public Participants: Array<string> = new Array<string>();
        // StartTime is the timestamp at which the session began.
        public StartTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // EndTime is the timestamp at which the session ended.
        public EndTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * KubernetesCluster has information about a kubernetes cluster, if
         *  applicable.
         */
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        // KubernetesPod has information about a kubernetes pod, if applicable.
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();
        // InitialCommand is the command used to start this session.
        public InitialCommand: Array<string> = new Array<string>();
        // SessionRecording is the type of session recording.
        public SessionRecording: string = "";

        // Decodes SessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionEnd {
            return SessionEnd.decode(new DataView(buf));
        }

        // Decodes SessionEnd from a DataView
        static decode(view: DataView): SessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.EnhancedRecording = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.Interactive = decoder.bool();
                        break;
                    }
                    case 8: {
                        obj.Participants.push(decoder.string());
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.StartTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.EndTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        obj.InitialCommand.push(decoder.string());
                        break;
                    }
                    case 14: {
                        obj.SessionRecording = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.EnhancedRecording == 0 ? 0 : 1 + 1;
            size += this.Interactive == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.Participants);

            if (this.StartTime != null) {
                const f: google.protobuf.Timestamp = this
                    .StartTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.EndTime != null) {
                const f: google.protobuf.Timestamp = this
                    .EndTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.InitialCommand);

            size +=
                this.SessionRecording.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionRecording.length) +
                      this.SessionRecording.length
                    : 0;

            return size;
        }

        // Encodes SessionEnd to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionEnd to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.EnhancedRecording != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.EnhancedRecording);
            }
            if (this.Interactive != 0) {
                encoder.uint32(0x38);
                encoder.bool(this.Interactive);
            }

            if (this.Participants.length > 0) {
                for (let n: i32 = 0; n < this.Participants.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Participants[n].length);
                    encoder.string(this.Participants[n]);
                }
            }

            if (this.StartTime != null) {
                const f = this.StartTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.EndTime != null) {
                const f = this.EndTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.InitialCommand.length > 0) {
                for (let n: i32 = 0; n < this.InitialCommand.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.InitialCommand[n].length);
                    encoder.string(this.InitialCommand[n]);
                }
            }

            if (this.SessionRecording.length > 0) {
                encoder.uint32(0x72);
                encoder.uint32(this.SessionRecording.length);
                encoder.string(this.SessionRecording);
            }

            return buf;
        } // encode SessionEnd
    } // SessionEnd

    // BPFMetadata is a common BPF process metadata
    export class BPFMetadata {
        // PID is the ID of the process.
        public PID: u64;
        // CgroupID is the internal cgroupv2 ID of the event.
        public CgroupID: u64;
        // Program is name of the executable.
        public Program: string = "";

        // Decodes BPFMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BPFMetadata {
            return BPFMetadata.decode(new DataView(buf));
        }

        // Decodes BPFMetadata from a DataView
        static decode(view: DataView): BPFMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new BPFMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PID = decoder.uint64();
                        break;
                    }
                    case 2: {
                        obj.CgroupID = decoder.uint64();
                        break;
                    }
                    case 3: {
                        obj.Program = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BPFMetadata

        public size(): u32 {
            let size: u32 = 0;

            size += this.PID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PID);
            size +=
                this.CgroupID == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.CgroupID);
            size +=
                this.Program.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Program.length) +
                      this.Program.length
                    : 0;

            return size;
        }

        // Encodes BPFMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BPFMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PID != 0) {
                encoder.uint32(0x8);
                encoder.uint64(this.PID);
            }
            if (this.CgroupID != 0) {
                encoder.uint32(0x10);
                encoder.uint64(this.CgroupID);
            }
            if (this.Program.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Program.length);
                encoder.string(this.Program);
            }

            return buf;
        } // encode BPFMetadata
    } // BPFMetadata

    // Status contains common command or operation status fields
    export class Status {
        // Success indicates the success or failure of the operation
        public Success: bool;
        // Error includes system error message for the failed attempt
        public Error: string = "";
        // UserMessage is a user-friendly message for successfull or unsuccessfull auth attempt
        public UserMessage: string = "";

        // Decodes Status from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Status {
            return Status.decode(new DataView(buf));
        }

        // Decodes Status from a DataView
        static decode(view: DataView): Status {
            const decoder = new __proto.Decoder(view);
            const obj = new Status();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Success = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.Error = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.UserMessage = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Status

        public size(): u32 {
            let size: u32 = 0;

            size += this.Success == 0 ? 0 : 1 + 1;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;
            size +=
                this.UserMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UserMessage.length) +
                      this.UserMessage.length
                    : 0;

            return size;
        }

        // Encodes Status to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Status to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Success != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Success);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }
            if (this.UserMessage.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.UserMessage.length);
                encoder.string(this.UserMessage);
            }

            return buf;
        } // encode Status
    } // Status

    // SessionCommand is a session command event
    export class SessionCommand {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // BPFMetadata is a common BPF subsystem metadata
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        // PPID is the PID of the parent process.
        public PPID: u64;
        // Path is the full path to the executable.
        public Path: string = "";
        /**
         * Argv is the list of arguments to the program. Note, the first element does
         *  not contain the name of the process.
         */
        public Argv: Array<string> = new Array<string>();
        // ReturnCode is the return code of execve.
        public ReturnCode: i32;

        // Decodes SessionCommand from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionCommand {
            return SessionCommand.decode(new DataView(buf));
        }

        // Decodes SessionCommand from a DataView
        static decode(view: DataView): SessionCommand {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionCommand();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.PPID = decoder.uint64();
                        break;
                    }
                    case 7: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Argv.push(decoder.string());
                        break;
                    }
                    case 9: {
                        obj.ReturnCode = decoder.int32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionCommand

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.PPID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PPID);
            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;

            size += __size_string_repeated(this.Argv);

            size +=
                this.ReturnCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ReturnCode);

            return size;
        }

        // Encodes SessionCommand to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionCommand to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.PPID != 0) {
                encoder.uint32(0x30);
                encoder.uint64(this.PPID);
            }
            if (this.Path.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }

            if (this.Argv.length > 0) {
                for (let n: i32 = 0; n < this.Argv.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Argv[n].length);
                    encoder.string(this.Argv[n]);
                }
            }

            if (this.ReturnCode != 0) {
                encoder.uint32(0x48);
                encoder.int32(this.ReturnCode);
            }

            return buf;
        } // encode SessionCommand
    } // SessionCommand

    // SessionDisk is a session disk access event
    export class SessionDisk {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // BPFMetadata is a common BPF subsystem metadata
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        // Path is the full path to the executable.
        public Path: string = "";
        // Flags are the flags passed to open.
        public Flags: i32;
        // ReturnCode is the return code of disk open
        public ReturnCode: i32;

        // Decodes SessionDisk from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionDisk {
            return SessionDisk.decode(new DataView(buf));
        }

        // Decodes SessionDisk from a DataView
        static decode(view: DataView): SessionDisk {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionDisk();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Flags = decoder.int32();
                        break;
                    }
                    case 8: {
                        obj.ReturnCode = decoder.int32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionDisk

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size += this.Flags == 0 ? 0 : 1 + __proto.Sizer.int32(this.Flags);
            size +=
                this.ReturnCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ReturnCode);

            return size;
        }

        // Encodes SessionDisk to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionDisk to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Path.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.Flags != 0) {
                encoder.uint32(0x38);
                encoder.int32(this.Flags);
            }
            if (this.ReturnCode != 0) {
                encoder.uint32(0x40);
                encoder.int32(this.ReturnCode);
            }

            return buf;
        } // encode SessionDisk
    } // SessionDisk

    // SessionNetwork is a network event
    export class SessionNetwork {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // BPFMetadata is a common BPF subsystem metadata
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        // SrcAddr is the source IP address of the connection.
        public SrcAddr: string = "";
        // DstAddr is the destination IP address of the connection.
        public DstAddr: string = "";
        // DstPort is the destination port of the connection.
        public DstPort: i32;
        // TCPVersion is the version of TCP (4 or 6).
        public TCPVersion: i32;
        // Operation denotes what network operation was performed (e.g. connect)
        public Operation: u32;
        // Action denotes what happened in response to the event
        public Action: u32;

        // Decodes SessionNetwork from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionNetwork {
            return SessionNetwork.decode(new DataView(buf));
        }

        // Decodes SessionNetwork from a DataView
        static decode(view: DataView): SessionNetwork {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionNetwork();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.SrcAddr = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.DstAddr = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.DstPort = decoder.int32();
                        break;
                    }
                    case 9: {
                        obj.TCPVersion = decoder.int32();
                        break;
                    }
                    case 10: {
                        obj.Operation = decoder.uint32();
                        break;
                    }
                    case 11: {
                        obj.Action = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionNetwork

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SrcAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SrcAddr.length) +
                      this.SrcAddr.length
                    : 0;
            size +=
                this.DstAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DstAddr.length) +
                      this.DstAddr.length
                    : 0;
            size +=
                this.DstPort == 0 ? 0 : 1 + __proto.Sizer.int32(this.DstPort);
            size +=
                this.TCPVersion == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.TCPVersion);
            size +=
                this.Operation == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.Operation);
            size +=
                this.Action == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Action);

            return size;
        }

        // Encodes SessionNetwork to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionNetwork to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SrcAddr.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.SrcAddr.length);
                encoder.string(this.SrcAddr);
            }
            if (this.DstAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DstAddr.length);
                encoder.string(this.DstAddr);
            }
            if (this.DstPort != 0) {
                encoder.uint32(0x40);
                encoder.int32(this.DstPort);
            }
            if (this.TCPVersion != 0) {
                encoder.uint32(0x48);
                encoder.int32(this.TCPVersion);
            }
            if (this.Operation != 0) {
                encoder.uint32(0x50);
                encoder.uint32(this.Operation);
            }
            if (this.Action != 0) {
                encoder.uint32(0x58);
                encoder.uint32(this.Action);
            }

            return buf;
        } // encode SessionNetwork
    } // SessionNetwork

    // Operation is the network operation that was performed or attempted
    export enum SessionNetwork_NetworkOperation {
        // TCP connection establishment or binding a UDP socket to a remote address
        CONNECT = 0,
        // Transmission of data to a remote endpoint
        SEND = 1,
    } // SessionNetwork_NetworkOperation
    // SessionData is emitted to report session data usage.
    export class SessionData {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // BytesTransmitted is the amount of bytes transmitted
        public BytesTransmitted: u64;
        // BytesReceived is the amount of bytes received
        public BytesReceived: u64;

        // Decodes SessionData from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionData {
            return SessionData.decode(new DataView(buf));
        }

        // Decodes SessionData from a DataView
        static decode(view: DataView): SessionData {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionData();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.BytesTransmitted = decoder.uint64();
                        break;
                    }
                    case 7: {
                        obj.BytesReceived = decoder.uint64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionData

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.BytesTransmitted == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.BytesTransmitted);
            size +=
                this.BytesReceived == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.BytesReceived);

            return size;
        }

        // Encodes SessionData to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionData to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BytesTransmitted != 0) {
                encoder.uint32(0x30);
                encoder.uint64(this.BytesTransmitted);
            }
            if (this.BytesReceived != 0) {
                encoder.uint32(0x38);
                encoder.uint64(this.BytesReceived);
            }

            return buf;
        } // encode SessionData
    } // SessionData

    // SessionLeave is emitted to report that a user left the session
    export class SessionLeave {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();

        // Decodes SessionLeave from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionLeave {
            return SessionLeave.decode(new DataView(buf));
        }

        // Decodes SessionLeave from a DataView
        static decode(view: DataView): SessionLeave {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionLeave();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionLeave

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionLeave to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionLeave to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SessionLeave
    } // SessionLeave

    // UserLogin records a successfull or failed user login event
    export class UserLogin {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // Status contains common command or operation status fields
        public Status: events.Status = new events.Status();
        // Method is the event field indicating how the login was performed
        public Method: string = "";
        // IdentityAttributes is a map of user attributes received from identity provider
        public IdentityAttributes: google.protobuf.Struct =
            new google.protobuf.Struct();
        // MFA is the MFA device used during the login.
        public MFADevice: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes UserLogin from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserLogin {
            return UserLogin.decode(new DataView(buf));
        }

        // Decodes UserLogin from a DataView
        static decode(view: DataView): UserLogin {
            const decoder = new __proto.Decoder(view);
            const obj = new UserLogin();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Method = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.IdentityAttributes = google.protobuf.Struct.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.MFADevice = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserLogin

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Method.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Method.length) +
                      this.Method.length
                    : 0;

            if (this.IdentityAttributes != null) {
                const f: google.protobuf.Struct = this
                    .IdentityAttributes as google.protobuf.Struct;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADevice != null) {
                const f: events.MFADeviceMetadata = this
                    .MFADevice as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserLogin to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserLogin to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Method.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Method.length);
                encoder.string(this.Method);
            }

            if (this.IdentityAttributes != null) {
                const f = this.IdentityAttributes as google.protobuf.Struct;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.MFADevice != null) {
                const f = this.MFADevice as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserLogin
    } // UserLogin

    // ResourceMetadata is a common resource metadata
    export class ResourceMetadata {
        // ResourceName is a resource name
        public Name: string = "";
        // Expires is set if resource expires
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        // UpdatedBy if set indicates the user who modified the resource
        public UpdatedBy: string = "";
        /**
         * TTL is a TTL of reset password token represented as duration, e.g. "10m"
         *  used for compatibility purposes for some events, Expires should be used instead
         *  as it's more useful (contains exact expiration date/time)
         */
        public TTL: string = "";

        // Decodes ResourceMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceMetadata {
            return ResourceMetadata.decode(new DataView(buf));
        }

        // Decodes ResourceMetadata from a DataView
        static decode(view: DataView): ResourceMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.UpdatedBy = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.TTL = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.UpdatedBy.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UpdatedBy.length) +
                      this.UpdatedBy.length
                    : 0;
            size +=
                this.TTL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TTL.length) +
                      this.TTL.length
                    : 0;

            return size;
        }

        // Encodes ResourceMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UpdatedBy.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.UpdatedBy.length);
                encoder.string(this.UpdatedBy);
            }
            if (this.TTL.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.TTL.length);
                encoder.string(this.TTL);
            }

            return buf;
        } // encode ResourceMetadata
    } // ResourceMetadata

    // UserCreate is emitted when the user is created or updated (upsert).
    export class UserCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // Roles is a list of roles for the user.
        public Roles: Array<string> = new Array<string>();
        // Connector is the connector used to create the user.
        public Connector: string = "";

        // Decodes UserCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserCreate {
            return UserCreate.decode(new DataView(buf));
        }

        // Decodes UserCreate from a DataView
        static decode(view: DataView): UserCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new UserCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.Connector = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            size +=
                this.Connector.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Connector.length) +
                      this.Connector.length
                    : 0;

            return size;
        }

        // Encodes UserCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Connector.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Connector.length);
                encoder.string(this.Connector);
            }

            return buf;
        } // encode UserCreate
    } // UserCreate

    // UserDelete is emitted when a user gets deleted
    export class UserDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes UserDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserDelete {
            return UserDelete.decode(new DataView(buf));
        }

        // Decodes UserDelete from a DataView
        static decode(view: DataView): UserDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new UserDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserDelete
    } // UserDelete

    // UserPasswordChange is emitted when the user changes their own password.
    export class UserPasswordChange {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes UserPasswordChange from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserPasswordChange {
            return UserPasswordChange.decode(new DataView(buf));
        }

        // Decodes UserPasswordChange from a DataView
        static decode(view: DataView): UserPasswordChange {
            const decoder = new __proto.Decoder(view);
            const obj = new UserPasswordChange();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserPasswordChange

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserPasswordChange to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserPasswordChange to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserPasswordChange
    } // UserPasswordChange

    // AccessRequestCreate is emitted when access request has been created or updated
    export class AccessRequestCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // Roles is a list of roles for the user.
        public Roles: Array<string> = new Array<string>();
        // RequestID is access request ID
        public RequestID: string = "";
        /**
         * RequestState is access request state (in the access_request.review variant of
         *  the event this represents the post-review state of the request).
         */
        public RequestState: string = "";
        /**
         * Delegator is used by teleport plugins to indicate the identity
         *  which caused them to update state.
         */
        public Delegator: string = "";
        /**
         * Reason is an optional description of why the request is being
         *  created or updated.
         */
        public Reason: string = "";
        /**
         * Annotations is an optional set of attributes supplied by a plugin during
         *  approval/denail of the request.
         */
        public Annotations: google.protobuf.Struct =
            new google.protobuf.Struct();
        // Reviewer is the author of the review (only used in the access_request.review event variant).
        public Reviewer: string = "";
        /**
         * ProposedState is the state proposed by a review (only used in the access_request.review event
         *  variant).
         */
        public ProposedState: string = "";

        // Decodes AccessRequestCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestCreate {
            return AccessRequestCreate.decode(new DataView(buf));
        }

        // Decodes AccessRequestCreate from a DataView
        static decode(view: DataView): AccessRequestCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.RequestID = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.RequestState = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Delegator = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Annotations = google.protobuf.Struct.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        obj.Reviewer = decoder.string();
                        break;
                    }
                    case 11: {
                        obj.ProposedState = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            size +=
                this.RequestID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestID.length) +
                      this.RequestID.length
                    : 0;
            size +=
                this.RequestState.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestState.length) +
                      this.RequestState.length
                    : 0;
            size +=
                this.Delegator.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Delegator.length) +
                      this.Delegator.length
                    : 0;
            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            if (this.Annotations != null) {
                const f: google.protobuf.Struct = this
                    .Annotations as google.protobuf.Struct;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reviewer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reviewer.length) +
                      this.Reviewer.length
                    : 0;
            size +=
                this.ProposedState.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProposedState.length) +
                      this.ProposedState.length
                    : 0;

            return size;
        }

        // Encodes AccessRequestCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.RequestID.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.RequestID.length);
                encoder.string(this.RequestID);
            }
            if (this.RequestState.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.RequestState.length);
                encoder.string(this.RequestState);
            }
            if (this.Delegator.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Delegator.length);
                encoder.string(this.Delegator);
            }
            if (this.Reason.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            if (this.Annotations != null) {
                const f = this.Annotations as google.protobuf.Struct;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Reviewer.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.Reviewer.length);
                encoder.string(this.Reviewer);
            }
            if (this.ProposedState.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.ProposedState.length);
                encoder.string(this.ProposedState);
            }

            return buf;
        } // encode AccessRequestCreate
    } // AccessRequestCreate

    // AccessRequestDelete is emitted when an access request has been deleted.
    export class AccessRequestDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // RequestID is access request ID
        public RequestID: string = "";

        // Decodes AccessRequestDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestDelete {
            return AccessRequestDelete.decode(new DataView(buf));
        }

        // Decodes AccessRequestDelete from a DataView
        static decode(view: DataView): AccessRequestDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.RequestID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RequestID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestID.length) +
                      this.RequestID.length
                    : 0;

            return size;
        }

        // Encodes AccessRequestDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RequestID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.RequestID.length);
                encoder.string(this.RequestID);
            }

            return buf;
        } // encode AccessRequestDelete
    } // AccessRequestDelete

    // PortForward is emitted when a user requests port forwarding.
    export class PortForward {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Status contains operation success or failure status
        public Status: events.Status = new events.Status();
        // Addr is a target port forwarding address
        public Addr: string = "";

        // Decodes PortForward from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PortForward {
            return PortForward.decode(new DataView(buf));
        }

        // Decodes PortForward from a DataView
        static decode(view: DataView): PortForward {
            const decoder = new __proto.Decoder(view);
            const obj = new PortForward();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Addr = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PortForward

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;

            return size;
        }

        // Encodes PortForward to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PortForward to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Addr.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }

            return buf;
        } // encode PortForward
    } // PortForward

    // X11Forward is emitted when a user requests X11 protocol forwarding
    export class X11Forward {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Status contains operation success or failure status
        public Status: events.Status = new events.Status();

        // Decodes X11Forward from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): X11Forward {
            return X11Forward.decode(new DataView(buf));
        }

        // Decodes X11Forward from a DataView
        static decode(view: DataView): X11Forward {
            const decoder = new __proto.Decoder(view);
            const obj = new X11Forward();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode X11Forward

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes X11Forward to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes X11Forward to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode X11Forward
    } // X11Forward

    // CommandMetadata specifies common command fields
    export class CommandMetadata {
        // Command is the executed command name
        public Command: string = "";
        // ExitCode specifies command exit code
        public ExitCode: string = "";
        // Error is an optional exit error, set if command has failed
        public Error: string = "";

        // Decodes CommandMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CommandMetadata {
            return CommandMetadata.decode(new DataView(buf));
        }

        // Decodes CommandMetadata from a DataView
        static decode(view: DataView): CommandMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new CommandMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Command = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ExitCode = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Error = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CommandMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Command.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Command.length) +
                      this.Command.length
                    : 0;
            size +=
                this.ExitCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ExitCode.length) +
                      this.ExitCode.length
                    : 0;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;

            return size;
        }

        // Encodes CommandMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CommandMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Command.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Command.length);
                encoder.string(this.Command);
            }
            if (this.ExitCode.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ExitCode.length);
                encoder.string(this.ExitCode);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }

            return buf;
        } // encode CommandMetadata
    } // CommandMetadata

    // Exec specifies command exec event
    export class Exec {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // CommandMetadata is a common command metadata
        public Command: events.CommandMetadata = new events.CommandMetadata();
        /**
         * KubernetesCluster has information about a kubernetes cluster, if
         *  applicable.
         */
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        // KubernetesPod has information about a kubernetes pod, if applicable.
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();

        // Decodes Exec from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Exec {
            return Exec.decode(new DataView(buf));
        }

        // Decodes Exec from a DataView
        static decode(view: DataView): Exec {
            const decoder = new __proto.Decoder(view);
            const obj = new Exec();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Command = events.CommandMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Exec

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Command != null) {
                const f: events.CommandMetadata = this
                    .Command as events.CommandMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Exec to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Exec to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Command != null) {
                const f = this.Command as events.CommandMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode Exec
    } // Exec

    // SCP is emitted when data transfer has occurred between server and client
    export class SCP {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // CommandMetadata is a common command metadata
        public Command: events.CommandMetadata = new events.CommandMetadata();
        // Path is a copy path
        public Path: string = "";
        // Action is upload or download
        public Action: string = "";

        // Decodes SCP from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SCP {
            return SCP.decode(new DataView(buf));
        }

        // Decodes SCP from a DataView
        static decode(view: DataView): SCP {
            const decoder = new __proto.Decoder(view);
            const obj = new SCP();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Command = events.CommandMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Action = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SCP

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Command != null) {
                const f: events.CommandMetadata = this
                    .Command as events.CommandMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size +=
                this.Action.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Action.length) +
                      this.Action.length
                    : 0;

            return size;
        }

        // Encodes SCP to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SCP to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Command != null) {
                const f = this.Command as events.CommandMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Path.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.Action.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Action.length);
                encoder.string(this.Action);
            }

            return buf;
        } // encode SCP
    } // SCP

    // Subsystem is emitted when a user requests a new subsystem.
    export class Subsystem {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Name is a subsystem name
        public Name: string = "";
        // Error contains error in case of unsucessfull attempt
        public Error: string = "";

        // Decodes Subsystem from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Subsystem {
            return Subsystem.decode(new DataView(buf));
        }

        // Decodes Subsystem from a DataView
        static decode(view: DataView): Subsystem {
            const decoder = new __proto.Decoder(view);
            const obj = new Subsystem();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.Error = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Subsystem

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;

            return size;
        }

        // Encodes Subsystem to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Subsystem to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Name.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }

            return buf;
        } // encode Subsystem
    } // Subsystem

    /**
     * ClientDisconnect is emitted when client is disconnected
     *  by the server due to inactivity or any other reason
     */
    export class ClientDisconnect {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        /**
         * Reason is a field that specifies reason for event, e.g. in disconnect
         *  event it explains why server disconnected the client
         */
        public Reason: string = "";

        // Decodes ClientDisconnect from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClientDisconnect {
            return ClientDisconnect.decode(new DataView(buf));
        }

        // Decodes ClientDisconnect from a DataView
        static decode(view: DataView): ClientDisconnect {
            const decoder = new __proto.Decoder(view);
            const obj = new ClientDisconnect();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Reason = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClientDisconnect

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            return size;
        }

        // Encodes ClientDisconnect to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClientDisconnect to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Reason.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            return buf;
        } // encode ClientDisconnect
    } // ClientDisconnect

    // AuthAttempt is emitted upon a failed or successfull authentication attempt.
    export class AuthAttempt {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Status contains common command or operation status fields
        public Status: events.Status = new events.Status();

        // Decodes AuthAttempt from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthAttempt {
            return AuthAttempt.decode(new DataView(buf));
        }

        // Decodes AuthAttempt from a DataView
        static decode(view: DataView): AuthAttempt {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthAttempt();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthAttempt

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthAttempt to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthAttempt to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AuthAttempt
    } // AuthAttempt

    // UserTokenCreate is emitted when a user token is created.
    export class UserTokenCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes UserTokenCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenCreate {
            return UserTokenCreate.decode(new DataView(buf));
        }

        // Decodes UserTokenCreate from a DataView
        static decode(view: DataView): UserTokenCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode UserTokenCreate
    } // UserTokenCreate

    // RoleCreate is emitted when a role is created/updated.
    export class RoleCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RoleCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleCreate {
            return RoleCreate.decode(new DataView(buf));
        }

        // Decodes RoleCreate from a DataView
        static decode(view: DataView): RoleCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RoleCreate
    } // RoleCreate

    // RoleDelete is emitted when a role is deleted
    export class RoleDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RoleDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleDelete {
            return RoleDelete.decode(new DataView(buf));
        }

        // Decodes RoleDelete from a DataView
        static decode(view: DataView): RoleDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RoleDelete
    } // RoleDelete

    // TrustedClusterCreate is the event for creating a trusted cluster.
    export class TrustedClusterCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterCreate {
            return TrustedClusterCreate.decode(new DataView(buf));
        }

        // Decodes TrustedClusterCreate from a DataView
        static decode(view: DataView): TrustedClusterCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterCreate
    } // TrustedClusterCreate

    // TrustedClusterDelete is the event for removing a trusted cluster.
    export class TrustedClusterDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterDelete {
            return TrustedClusterDelete.decode(new DataView(buf));
        }

        // Decodes TrustedClusterDelete from a DataView
        static decode(view: DataView): TrustedClusterDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterDelete
    } // TrustedClusterDelete

    /**
     * TrustedClusterTokenCreate is the event for
     *  creating new join token for a trusted cluster.
     */
    export class TrustedClusterTokenCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterTokenCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterTokenCreate {
            return TrustedClusterTokenCreate.decode(new DataView(buf));
        }

        // Decodes TrustedClusterTokenCreate from a DataView
        static decode(view: DataView): TrustedClusterTokenCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterTokenCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterTokenCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterTokenCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterTokenCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterTokenCreate
    } // TrustedClusterTokenCreate

    // GithubConnectorCreate fires when a Github connector is created/updated.
    export class GithubConnectorCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes GithubConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorCreate {
            return GithubConnectorCreate.decode(new DataView(buf));
        }

        // Decodes GithubConnectorCreate from a DataView
        static decode(view: DataView): GithubConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorCreate
    } // GithubConnectorCreate

    // GithubConnectorDelete fires when a Github connector is deleted.
    export class GithubConnectorDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes GithubConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorDelete {
            return GithubConnectorDelete.decode(new DataView(buf));
        }

        // Decodes GithubConnectorDelete from a DataView
        static decode(view: DataView): GithubConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorDelete
    } // GithubConnectorDelete

    // OIDCConnectorCreate fires when OIDC connector is created/updated.
    export class OIDCConnectorCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes OIDCConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorCreate {
            return OIDCConnectorCreate.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorCreate from a DataView
        static decode(view: DataView): OIDCConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorCreate
    } // OIDCConnectorCreate

    // OIDCConnectorDelete fires when OIDC connector is deleted.
    export class OIDCConnectorDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes OIDCConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorDelete {
            return OIDCConnectorDelete.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorDelete from a DataView
        static decode(view: DataView): OIDCConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorDelete
    } // OIDCConnectorDelete

    // SAMLConnectorCreate fires when SAML connector is created/updated.
    export class SAMLConnectorCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes SAMLConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorCreate {
            return SAMLConnectorCreate.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorCreate from a DataView
        static decode(view: DataView): SAMLConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorCreate
    } // SAMLConnectorCreate

    // SAMLConnectorDelete fires when SAML connector is deleted.
    export class SAMLConnectorDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes SAMLConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorDelete {
            return SAMLConnectorDelete.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorDelete from a DataView
        static decode(view: DataView): SAMLConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorDelete
    } // SAMLConnectorDelete

    // KubeRequest specifies a Kubernetes API request event.
    export class KubeRequest {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // RequestPath is the raw request URL path.
        public RequestPath: string = "";
        // Verb is the HTTP verb used for this request (e.g. GET, POST, etc)
        public Verb: string = "";
        // ResourceAPIGroup is the resource API group.
        public ResourceAPIGroup: string = "";
        // ResourceNamespace is the resource namespace.
        public ResourceNamespace: string = "";
        // ResourceKind is the API resource kind (e.g. "pod", "service", etc).
        public ResourceKind: string = "";
        // ResourceName is the API resource name.
        public ResourceName: string = "";
        // ResponseCode is the HTTP response code for this request.
        public ResponseCode: i32;
        // Kubernetes has information about a kubernetes cluster, if applicable.
        public Kubernetes: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();

        // Decodes KubeRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubeRequest {
            return KubeRequest.decode(new DataView(buf));
        }

        // Decodes KubeRequest from a DataView
        static decode(view: DataView): KubeRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new KubeRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.RequestPath = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Verb = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ResourceAPIGroup = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.ResourceNamespace = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.ResourceKind = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.ResourceName = decoder.string();
                        break;
                    }
                    case 11: {
                        obj.ResponseCode = decoder.int32();
                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Kubernetes =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubeRequest

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RequestPath.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestPath.length) +
                      this.RequestPath.length
                    : 0;
            size +=
                this.Verb.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Verb.length) +
                      this.Verb.length
                    : 0;
            size +=
                this.ResourceAPIGroup.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceAPIGroup.length) +
                      this.ResourceAPIGroup.length
                    : 0;
            size +=
                this.ResourceNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceNamespace.length) +
                      this.ResourceNamespace.length
                    : 0;
            size +=
                this.ResourceKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceKind.length) +
                      this.ResourceKind.length
                    : 0;
            size +=
                this.ResourceName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceName.length) +
                      this.ResourceName.length
                    : 0;
            size +=
                this.ResponseCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ResponseCode);

            if (this.Kubernetes != null) {
                const f: events.KubernetesClusterMetadata = this
                    .Kubernetes as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes KubeRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubeRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RequestPath.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.RequestPath.length);
                encoder.string(this.RequestPath);
            }
            if (this.Verb.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Verb.length);
                encoder.string(this.Verb);
            }
            if (this.ResourceAPIGroup.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ResourceAPIGroup.length);
                encoder.string(this.ResourceAPIGroup);
            }
            if (this.ResourceNamespace.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.ResourceNamespace.length);
                encoder.string(this.ResourceNamespace);
            }
            if (this.ResourceKind.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.ResourceKind.length);
                encoder.string(this.ResourceKind);
            }
            if (this.ResourceName.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.ResourceName.length);
                encoder.string(this.ResourceName);
            }
            if (this.ResponseCode != 0) {
                encoder.uint32(0x58);
                encoder.int32(this.ResponseCode);
            }

            if (this.Kubernetes != null) {
                const f = this.Kubernetes as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode KubeRequest
    } // KubeRequest

    // AppMetadata contains common application information.
    export class AppMetadata {
        // AppURI is the application endpoint.
        public AppURI: string = "";
        // AppPublicAddr is the configured application public address.
        public AppPublicAddr: string = "";
        // AppLabels are the configured application labels.
        public AppLabels: Map<string, string> = new Map<string, string>();
        // AppName is the configured application name.
        public AppName: string = "";

        // Decodes AppMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppMetadata {
            return AppMetadata.decode(new DataView(buf));
        }

        // Decodes AppMetadata from a DataView
        static decode(view: DataView): AppMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new AppMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AppURI = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AppPublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.AppLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.AppName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AppURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppURI.length) +
                      this.AppURI.length
                    : 0;
            size +=
                this.AppPublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppPublicAddr.length) +
                      this.AppPublicAddr.length
                    : 0;

            if (this.AppLabels.size > 0) {
                const keys = this.AppLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.AppLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size +=
                this.AppName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppName.length) +
                      this.AppName.length
                    : 0;

            return size;
        }

        // Encodes AppMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AppURI.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AppURI.length);
                encoder.string(this.AppURI);
            }
            if (this.AppPublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.AppPublicAddr.length);
                encoder.string(this.AppPublicAddr);
            }

            if (this.AppLabels.size > 0) {
                const keys = this.AppLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.AppLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.AppName.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AppName.length);
                encoder.string(this.AppName);
            }

            return buf;
        } // encode AppMetadata
    } // AppMetadata

    // AppCreate is emitted when a new application resource is created.
    export class AppCreate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // AppMetadata is a common application resource metadata.
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppCreate {
            return AppCreate.decode(new DataView(buf));
        }

        // Decodes AppCreate from a DataView
        static decode(view: DataView): AppCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new AppCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppCreate
    } // AppCreate

    // AppUpdate is emitted when an existing application resource is updated.
    export class AppUpdate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // AppMetadata is a common application resource metadata.
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppUpdate {
            return AppUpdate.decode(new DataView(buf));
        }

        // Decodes AppUpdate from a DataView
        static decode(view: DataView): AppUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new AppUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppUpdate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppUpdate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppUpdate
    } // AppUpdate

    // AppDelete is emitted when an application resource is deleted.
    export class AppDelete {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes AppDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppDelete {
            return AppDelete.decode(new DataView(buf));
        }

        // Decodes AppDelete from a DataView
        static decode(view: DataView): AppDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new AppDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppDelete
    } // AppDelete

    // AppSessionStart is emitted when a user is issued an application certificate.
    export class AppSessionStart {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        /**
         * PublicAddr is the public address of the application being requested.
         *  DELETE IN 10.0: this information is also present on the AppMetadata.
         */
        public PublicAddr: string = "";
        // App is a common application resource metadata.
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionStart {
            return AppSessionStart.decode(new DataView(buf));
        }

        // Decodes AppSessionStart from a DataView
        static decode(view: DataView): AppSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppSessionStart to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionStart to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppSessionStart
    } // AppSessionStart

    /**
     * AppSessionChunk is emitted at the start of a 5 minute chunk on each
     *  proxy. This chunk is used to buffer 5 minutes of audit events at a time
     *  for applications.
     */
    export class AppSessionChunk {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // ServerMetadata is a common server metadata
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // ConnectionMetadata holds information about the connection
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        /**
         * SessionChunkID is the ID of the session that was created for this 5 minute
         *  application log chunk.
         */
        public SessionChunkID: string = "";
        // App is a common application resource metadata.
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppSessionChunk from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionChunk {
            return AppSessionChunk.decode(new DataView(buf));
        }

        // Decodes AppSessionChunk from a DataView
        static decode(view: DataView): AppSessionChunk {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionChunk();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.SessionChunkID = decoder.string();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionChunk

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SessionChunkID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionChunkID.length) +
                      this.SessionChunkID.length
                    : 0;

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppSessionChunk to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionChunk to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionChunkID.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.SessionChunkID.length);
                encoder.string(this.SessionChunkID);
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppSessionChunk
    } // AppSessionChunk

    // AppSessionRequest is an HTTP request and response.
    export class AppSessionRequest {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // StatusCode the HTTP response code for the request.
        public StatusCode: u32;
        // Path is relative path in the URL.
        public Path: string = "";
        // RawQuery are the encoded query values.
        public RawQuery: string = "";
        // Method is the request HTTP method, like GET/POST/DELETE/etc.
        public Method: string = "";
        // App is a common application resource metadata.
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionRequest {
            return AppSessionRequest.decode(new DataView(buf));
        }

        // Decodes AppSessionRequest from a DataView
        static decode(view: DataView): AppSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.StatusCode = decoder.uint32();
                        break;
                    }
                    case 3: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.RawQuery = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.Method = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.StatusCode == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.StatusCode);
            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size +=
                this.RawQuery.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RawQuery.length) +
                      this.RawQuery.length
                    : 0;
            size +=
                this.Method.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Method.length) +
                      this.Method.length
                    : 0;

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppSessionRequest to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionRequest to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.StatusCode != 0) {
                encoder.uint32(0x10);
                encoder.uint32(this.StatusCode);
            }
            if (this.Path.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.RawQuery.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.RawQuery.length);
                encoder.string(this.RawQuery);
            }
            if (this.Method.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Method.length);
                encoder.string(this.Method);
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode AppSessionRequest
    } // AppSessionRequest

    // DatabaseMetadata contains common database information.
    export class DatabaseMetadata {
        // DatabaseService is the name of the database service proxying the database.
        public DatabaseService: string = "";
        // DatabaseProtocol is the database type, e.g. postgres or mysql.
        public DatabaseProtocol: string = "";
        // DatabaseURI is the database URI to connect to.
        public DatabaseURI: string = "";
        // DatabaseName is the name of the database a user is connecting to.
        public DatabaseName: string = "";
        // DatabaseUser is the database username used to connect.
        public DatabaseUser: string = "";
        // DatabaseLabels is the database resource labels.
        public DatabaseLabels: Map<string, string> = new Map<string, string>();
        // DatabaseAWSRegion is AWS regions for AWS hosted databases.
        public DatabaseAWSRegion: string = "";
        // DatabaseAWSRegion is cluster ID for Redshift databases.
        public DatabaseAWSRedshiftClusterID: string = "";
        // DatabaseGCPProjectID is project ID for GCP hosted databases.
        public DatabaseGCPProjectID: string = "";
        // DatabaseGCPInstanceID is instance ID for GCP hosted databases.
        public DatabaseGCPInstanceID: string = "";

        // Decodes DatabaseMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseMetadata {
            return DatabaseMetadata.decode(new DataView(buf));
        }

        // Decodes DatabaseMetadata from a DataView
        static decode(view: DataView): DatabaseMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.DatabaseService = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DatabaseProtocol = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.DatabaseURI = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.DatabaseName = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.DatabaseUser = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DatabaseLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.DatabaseAWSRegion = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.DatabaseAWSRedshiftClusterID = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.DatabaseGCPProjectID = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.DatabaseGCPInstanceID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.DatabaseService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseService.length) +
                      this.DatabaseService.length
                    : 0;
            size +=
                this.DatabaseProtocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseProtocol.length) +
                      this.DatabaseProtocol.length
                    : 0;
            size +=
                this.DatabaseURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseURI.length) +
                      this.DatabaseURI.length
                    : 0;
            size +=
                this.DatabaseName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseName.length) +
                      this.DatabaseName.length
                    : 0;
            size +=
                this.DatabaseUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseUser.length) +
                      this.DatabaseUser.length
                    : 0;

            if (this.DatabaseLabels.size > 0) {
                const keys = this.DatabaseLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DatabaseLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size +=
                this.DatabaseAWSRegion.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseAWSRegion.length) +
                      this.DatabaseAWSRegion.length
                    : 0;
            size +=
                this.DatabaseAWSRedshiftClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.DatabaseAWSRedshiftClusterID.length
                      ) +
                      this.DatabaseAWSRedshiftClusterID.length
                    : 0;
            size +=
                this.DatabaseGCPProjectID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseGCPProjectID.length) +
                      this.DatabaseGCPProjectID.length
                    : 0;
            size +=
                this.DatabaseGCPInstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.DatabaseGCPInstanceID.length
                      ) +
                      this.DatabaseGCPInstanceID.length
                    : 0;

            return size;
        }

        // Encodes DatabaseMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DatabaseService.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.DatabaseService.length);
                encoder.string(this.DatabaseService);
            }
            if (this.DatabaseProtocol.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.DatabaseProtocol.length);
                encoder.string(this.DatabaseProtocol);
            }
            if (this.DatabaseURI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.DatabaseURI.length);
                encoder.string(this.DatabaseURI);
            }
            if (this.DatabaseName.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.DatabaseName.length);
                encoder.string(this.DatabaseName);
            }
            if (this.DatabaseUser.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DatabaseUser.length);
                encoder.string(this.DatabaseUser);
            }

            if (this.DatabaseLabels.size > 0) {
                const keys = this.DatabaseLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DatabaseLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x32);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DatabaseAWSRegion.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DatabaseAWSRegion.length);
                encoder.string(this.DatabaseAWSRegion);
            }
            if (this.DatabaseAWSRedshiftClusterID.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.DatabaseAWSRedshiftClusterID.length);
                encoder.string(this.DatabaseAWSRedshiftClusterID);
            }
            if (this.DatabaseGCPProjectID.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.DatabaseGCPProjectID.length);
                encoder.string(this.DatabaseGCPProjectID);
            }
            if (this.DatabaseGCPInstanceID.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.DatabaseGCPInstanceID.length);
                encoder.string(this.DatabaseGCPInstanceID);
            }

            return buf;
        } // encode DatabaseMetadata
    } // DatabaseMetadata

    // DatabaseCreate is emitted when a new database resource is created.
    export class DatabaseCreate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // DatabaseMetadata is a common database resource metadata.
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseCreate {
            return DatabaseCreate.decode(new DataView(buf));
        }

        // Decodes DatabaseCreate from a DataView
        static decode(view: DataView): DatabaseCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseCreate
    } // DatabaseCreate

    // DatabaseUpdate is emitted when an existing database resource is updated.
    export class DatabaseUpdate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // DatabaseMetadata is a common database resource metadata.
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseUpdate {
            return DatabaseUpdate.decode(new DataView(buf));
        }

        // Decodes DatabaseUpdate from a DataView
        static decode(view: DataView): DatabaseUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseUpdate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseUpdate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseUpdate
    } // DatabaseUpdate

    // DatabaseDelete is emitted when a database resource is deleted.
    export class DatabaseDelete {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // ResourceMetadata is a common resource event metadata.
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes DatabaseDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseDelete {
            return DatabaseDelete.decode(new DataView(buf));
        }

        // Decodes DatabaseDelete from a DataView
        static decode(view: DataView): DatabaseDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseDelete
    } // DatabaseDelete

    // DatabaseSessionStart is emitted when a user connects to a database.
    export class DatabaseSessionStart {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Session is a common event session metadata.
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // Server is a common server metadata.
        public Server: events.ServerMetadata = new events.ServerMetadata();
        // Connection holds information about the connection.
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Status indicates whether the connection was successful or denied.
        public Status: events.Status = new events.Status();
        // Database contains database related metadata.
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionStart {
            return DatabaseSessionStart.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionStart from a DataView
        static decode(view: DataView): DatabaseSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionStart to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionStart to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionStart
    } // DatabaseSessionStart

    // DatabaseSessionQuery is emitted when a user executes a database query.
    export class DatabaseSessionQuery {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // SessionMetadata is a common event session metadata.
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // Database contains database related metadata.
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();
        // DatabaseQuery is the executed query string.
        public DatabaseQuery: string = "";
        // DatabaseQueryParameters are the query parameters for prepared statements.
        public DatabaseQueryParameters: Array<string> = new Array<string>();
        // Status indicates whether the query was successfully sent to the database.
        public Status: events.Status = new events.Status();

        // Decodes DatabaseSessionQuery from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionQuery {
            return DatabaseSessionQuery.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionQuery from a DataView
        static decode(view: DataView): DatabaseSessionQuery {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionQuery();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.DatabaseQuery = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.DatabaseQueryParameters.push(decoder.string());
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionQuery

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.DatabaseQuery.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseQuery.length) +
                      this.DatabaseQuery.length
                    : 0;

            size += __size_string_repeated(this.DatabaseQueryParameters);

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionQuery to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionQuery to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseQuery.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DatabaseQuery.length);
                encoder.string(this.DatabaseQuery);
            }

            if (this.DatabaseQueryParameters.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.DatabaseQueryParameters.length;
                    n++
                ) {
                    encoder.uint32(0x32);
                    encoder.uint32(this.DatabaseQueryParameters[n].length);
                    encoder.string(this.DatabaseQueryParameters[n]);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionQuery
    } // DatabaseSessionQuery

    // WindowsDesktopSessionStart is emitted when a user connects to a desktop.
    export class WindowsDesktopSessionStart {
        // Metadata is common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Session is common event session metadata.
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // Connection holds information about the connection.
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        // Status indicates whether the connection was successful or denied.
        public Status: events.Status = new events.Status();
        // WindowsDesktopService is the name of the service proxying the RDP session.
        public WindowsDesktopService: string = "";
        // DesktopAddr is the address of the desktop being accessed.
        public DesktopAddr: string = "";
        // Domain is the Active Directory domain of the desktop being accessed.
        public Domain: string = "";
        // WindowsUser is the Windows username used to connect.
        public WindowsUser: string = "";
        // DesktopLabels are the labels on the desktop resource.
        public DesktopLabels: Map<string, string> = new Map<string, string>();

        // Decodes WindowsDesktopSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSessionStart {
            return WindowsDesktopSessionStart.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSessionStart from a DataView
        static decode(view: DataView): WindowsDesktopSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.WindowsDesktopService = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.DesktopAddr = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Domain = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.WindowsUser = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DesktopLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.WindowsDesktopService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.WindowsDesktopService.length
                      ) +
                      this.WindowsDesktopService.length
                    : 0;
            size +=
                this.DesktopAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DesktopAddr.length) +
                      this.DesktopAddr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;
            size +=
                this.WindowsUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WindowsUser.length) +
                      this.WindowsUser.length
                    : 0;

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes WindowsDesktopSessionStart to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSessionStart to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.WindowsDesktopService.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.WindowsDesktopService.length);
                encoder.string(this.WindowsDesktopService);
            }
            if (this.DesktopAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DesktopAddr.length);
                encoder.string(this.DesktopAddr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }
            if (this.WindowsUser.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.WindowsUser.length);
                encoder.string(this.WindowsUser);
            }

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x52);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode WindowsDesktopSessionStart
    } // WindowsDesktopSessionStart

    // DatabaseSessionEnd is emitted when a user ends the database session.
    export class DatabaseSessionEnd {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Session is a common event session metadata.
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // Database contains database related metadata.
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseSessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionEnd {
            return DatabaseSessionEnd.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionEnd from a DataView
        static decode(view: DataView): DatabaseSessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionEnd to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionEnd to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionEnd
    } // DatabaseSessionEnd

    // MFADeviceMetadata is a common MFA device metadata.
    export class MFADeviceMetadata {
        // Name is the user-specified name of the MFA device.
        public DeviceName: string = "";
        // ID is the UUID of the MFA device generated by Teleport.
        public DeviceID: string = "";
        // Type is the type of this MFA device.
        public DeviceType: string = "";

        // Decodes MFADeviceMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceMetadata {
            return MFADeviceMetadata.decode(new DataView(buf));
        }

        // Decodes MFADeviceMetadata from a DataView
        static decode(view: DataView): MFADeviceMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.DeviceName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DeviceID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.DeviceType = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.DeviceName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceName.length) +
                      this.DeviceName.length
                    : 0;
            size +=
                this.DeviceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceID.length) +
                      this.DeviceID.length
                    : 0;
            size +=
                this.DeviceType.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceType.length) +
                      this.DeviceType.length
                    : 0;

            return size;
        }

        // Encodes MFADeviceMetadata to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceMetadata to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DeviceName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.DeviceName.length);
                encoder.string(this.DeviceName);
            }
            if (this.DeviceID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.DeviceID.length);
                encoder.string(this.DeviceID);
            }
            if (this.DeviceType.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.DeviceType.length);
                encoder.string(this.DeviceType);
            }

            return buf;
        } // encode MFADeviceMetadata
    } // MFADeviceMetadata

    // MFADeviceAdd is emitted when a user adds an MFA device.
    export class MFADeviceAdd {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Device is the new MFA device added by the user.
        public Device: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes MFADeviceAdd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceAdd {
            return MFADeviceAdd.decode(new DataView(buf));
        }

        // Decodes MFADeviceAdd from a DataView
        static decode(view: DataView): MFADeviceAdd {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceAdd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Device = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceAdd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Device != null) {
                const f: events.MFADeviceMetadata = this
                    .Device as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADeviceAdd to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceAdd to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Device != null) {
                const f = this.Device as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode MFADeviceAdd
    } // MFADeviceAdd

    // MFADeviceDelete is emitted when a user deletes an MFA device.
    export class MFADeviceDelete {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Device is the MFA device deleted by the user.
        public Device: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes MFADeviceDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceDelete {
            return MFADeviceDelete.decode(new DataView(buf));
        }

        // Decodes MFADeviceDelete from a DataView
        static decode(view: DataView): MFADeviceDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Device = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Device != null) {
                const f: events.MFADeviceMetadata = this
                    .Device as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADeviceDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Device != null) {
                const f = this.Device as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode MFADeviceDelete
    } // MFADeviceDelete

    // BillingInformationUpdate is emitted when a user updates the billing information.
    export class BillingInformationUpdate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingInformationUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingInformationUpdate {
            return BillingInformationUpdate.decode(new DataView(buf));
        }

        // Decodes BillingInformationUpdate from a DataView
        static decode(view: DataView): BillingInformationUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingInformationUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingInformationUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingInformationUpdate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingInformationUpdate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode BillingInformationUpdate
    } // BillingInformationUpdate

    // BillingCardCreate is emitted when a user creates or updates a credit card.
    export class BillingCardCreate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingCardCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingCardCreate {
            return BillingCardCreate.decode(new DataView(buf));
        }

        // Decodes BillingCardCreate from a DataView
        static decode(view: DataView): BillingCardCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingCardCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingCardCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingCardCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingCardCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode BillingCardCreate
    } // BillingCardCreate

    // BillingCardDelete is emitted when a user deletes a credit card.
    export class BillingCardDelete {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingCardDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingCardDelete {
            return BillingCardDelete.decode(new DataView(buf));
        }

        // Decodes BillingCardDelete from a DataView
        static decode(view: DataView): BillingCardDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingCardDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingCardDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingCardDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingCardDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode BillingCardDelete
    } // BillingCardDelete

    /**
     * LockCreate is emitted when a lock is created/updated.
     *  Locks are used to restrict access to a Teleport environment by disabling
     *  interactions involving a user, an RBAC role, a node, etc.
     *  See rfd/0009-locking.md for more details.
     */
    export class LockCreate {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes LockCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockCreate {
            return LockCreate.decode(new DataView(buf));
        }

        // Decodes LockCreate from a DataView
        static decode(view: DataView): LockCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new LockCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LockCreate
    } // LockCreate

    // LockDelete is emitted when a lock is deleted
    export class LockDelete {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // ResourceMetadata is a common resource event metadata
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        // User is a common user event metadata
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes LockDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockDelete {
            return LockDelete.decode(new DataView(buf));
        }

        // Decodes LockDelete from a DataView
        static decode(view: DataView): LockDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new LockDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockDelete to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockDelete to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode LockDelete
    } // LockDelete

    // RecoveryCodeGenerate is emitted when a user's new recovery codes are generated and updated.
    export class RecoveryCodeGenerate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RecoveryCodeGenerate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodeGenerate {
            return RecoveryCodeGenerate.decode(new DataView(buf));
        }

        // Decodes RecoveryCodeGenerate from a DataView
        static decode(view: DataView): RecoveryCodeGenerate {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodeGenerate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodeGenerate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodeGenerate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodeGenerate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodeGenerate
    } // RecoveryCodeGenerate

    /**
     * RecoveryCodeUsed is emitted when a user's recovery code was used successfully or
     *  unsuccessfully.
     */
    export class RecoveryCodeUsed {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Status contains fields to indicate whether attempt was successful or not.
        public Status: events.Status = new events.Status();

        // Decodes RecoveryCodeUsed from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodeUsed {
            return RecoveryCodeUsed.decode(new DataView(buf));
        }

        // Decodes RecoveryCodeUsed from a DataView
        static decode(view: DataView): RecoveryCodeUsed {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodeUsed();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodeUsed

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodeUsed to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodeUsed to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodeUsed
    } // RecoveryCodeUsed

    // WindowsDesktopSessionEnd is emitted when a user ends a Windows desktop session.
    export class WindowsDesktopSessionEnd {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // User is a common user event metadata.
        public User: events.UserMetadata = new events.UserMetadata();
        // Session is a common event session metadata.
        public Session: events.SessionMetadata = new events.SessionMetadata();
        // WindowsDesktopService is the name of the service proxying the RDP session.
        public WindowsDesktopService: string = "";
        // DesktopAddr is the address of the desktop being accessed.
        public DesktopAddr: string = "";
        // Domain is the Active Directory domain of the desktop being accessed.
        public Domain: string = "";
        // WindowsUser is the Windows username used to connect.
        public WindowsUser: string = "";
        // DesktopLabels are the labels on the desktop resource.
        public DesktopLabels: Map<string, string> = new Map<string, string>();

        // Decodes WindowsDesktopSessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSessionEnd {
            return WindowsDesktopSessionEnd.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSessionEnd from a DataView
        static decode(view: DataView): WindowsDesktopSessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.WindowsDesktopService = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.DesktopAddr = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Domain = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.WindowsUser = decoder.string();
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DesktopLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.WindowsDesktopService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.WindowsDesktopService.length
                      ) +
                      this.WindowsDesktopService.length
                    : 0;
            size +=
                this.DesktopAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DesktopAddr.length) +
                      this.DesktopAddr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;
            size +=
                this.WindowsUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WindowsUser.length) +
                      this.WindowsUser.length
                    : 0;

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes WindowsDesktopSessionEnd to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSessionEnd to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.WindowsDesktopService.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.WindowsDesktopService.length);
                encoder.string(this.WindowsDesktopService);
            }
            if (this.DesktopAddr.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DesktopAddr.length);
                encoder.string(this.DesktopAddr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }
            if (this.WindowsUser.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.WindowsUser.length);
                encoder.string(this.WindowsUser);
            }

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x42);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode WindowsDesktopSessionEnd
    } // WindowsDesktopSessionEnd

    // CertificateCreate is emitted when a certificate is issued.
    export class CertificateCreate {
        // Metadata is a common event metadata.
        public Metadata: events.Metadata = new events.Metadata();
        // CertificateType is the type of certificate that was just issued.
        public CertificateType: string = "";
        // Identity is the identity associated with the certificate, as interpreted by Teleport.
        public Identity: events.Identity = new events.Identity();

        // Decodes CertificateCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CertificateCreate {
            return CertificateCreate.decode(new DataView(buf));
        }

        // Decodes CertificateCreate from a DataView
        static decode(view: DataView): CertificateCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new CertificateCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.CertificateType = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Identity = events.Identity.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CertificateCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.CertificateType.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CertificateType.length) +
                      this.CertificateType.length
                    : 0;

            if (this.Identity != null) {
                const f: events.Identity = this.Identity as events.Identity;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CertificateCreate to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CertificateCreate to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.CertificateType.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.CertificateType.length);
                encoder.string(this.CertificateType);
            }

            if (this.Identity != null) {
                const f = this.Identity as events.Identity;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode CertificateCreate
    } // CertificateCreate

    // OneOf is a union of one of audit events submitted to the auth service
    export class OneOf {
        public __oneOf_Event: string = "";
        public UserLogin: events.UserLogin | null;
        public UserCreate: events.UserCreate | null;
        public UserDelete: events.UserDelete | null;
        public UserPasswordChange: events.UserPasswordChange | null;
        public SessionStart: events.SessionStart | null;
        public SessionJoin: events.SessionJoin | null;
        public SessionPrint: events.SessionPrint | null;
        public SessionReject: events.SessionReject | null;
        public Resize: events.Resize | null;
        public SessionEnd: events.SessionEnd | null;
        public SessionCommand: events.SessionCommand | null;
        public SessionDisk: events.SessionDisk | null;
        public SessionNetwork: events.SessionNetwork | null;
        public SessionData: events.SessionData | null;
        public SessionLeave: events.SessionLeave | null;
        public PortForward: events.PortForward | null;
        public X11Forward: events.X11Forward | null;
        public SCP: events.SCP | null;
        public Exec: events.Exec | null;
        public Subsystem: events.Subsystem | null;
        public ClientDisconnect: events.ClientDisconnect | null;
        public AuthAttempt: events.AuthAttempt | null;
        public AccessRequestCreate: events.AccessRequestCreate | null;
        public UserTokenCreate: events.UserTokenCreate | null;
        public RoleCreate: events.RoleCreate | null;
        public RoleDelete: events.RoleDelete | null;
        public TrustedClusterCreate: events.TrustedClusterCreate | null;
        public TrustedClusterDelete: events.TrustedClusterDelete | null;
        public TrustedClusterTokenCreate: events.TrustedClusterTokenCreate | null;
        public GithubConnectorCreate: events.GithubConnectorCreate | null;
        public GithubConnectorDelete: events.GithubConnectorDelete | null;
        public OIDCConnectorCreate: events.OIDCConnectorCreate | null;
        public OIDCConnectorDelete: events.OIDCConnectorDelete | null;
        public SAMLConnectorCreate: events.SAMLConnectorCreate | null;
        public SAMLConnectorDelete: events.SAMLConnectorDelete | null;
        public KubeRequest: events.KubeRequest | null;
        public AppSessionStart: events.AppSessionStart | null;
        public AppSessionChunk: events.AppSessionChunk | null;
        public AppSessionRequest: events.AppSessionRequest | null;
        public DatabaseSessionStart: events.DatabaseSessionStart | null;
        public DatabaseSessionEnd: events.DatabaseSessionEnd | null;
        public DatabaseSessionQuery: events.DatabaseSessionQuery | null;
        public SessionUpload: events.SessionUpload | null;
        public MFADeviceAdd: events.MFADeviceAdd | null;
        public MFADeviceDelete: events.MFADeviceDelete | null;
        public BillingInformationUpdate: events.BillingInformationUpdate | null;
        public BillingCardCreate: events.BillingCardCreate | null;
        public BillingCardDelete: events.BillingCardDelete | null;
        public LockCreate: events.LockCreate | null;
        public LockDelete: events.LockDelete | null;
        public RecoveryCodeGenerate: events.RecoveryCodeGenerate | null;
        public RecoveryCodeUsed: events.RecoveryCodeUsed | null;
        public DatabaseCreate: events.DatabaseCreate | null;
        public DatabaseUpdate: events.DatabaseUpdate | null;
        public DatabaseDelete: events.DatabaseDelete | null;
        public AppCreate: events.AppCreate | null;
        public AppUpdate: events.AppUpdate | null;
        public AppDelete: events.AppDelete | null;
        public WindowsDesktopSessionStart: events.WindowsDesktopSessionStart | null;
        public WindowsDesktopSessionEnd: events.WindowsDesktopSessionEnd | null;
        public AccessRequestDelete: events.AccessRequestDelete | null;
        public SessionConnect: events.SessionConnect | null;
        public CertificateCreate: events.CertificateCreate | null;

        // Decodes OneOf from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OneOf {
            return OneOf.decode(new DataView(buf));
        }

        // Decodes OneOf from a DataView
        static decode(view: DataView): OneOf {
            const decoder = new __proto.Decoder(view);
            const obj = new OneOf();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.UserLogin = events.UserLogin.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "UserLogin";
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.UserCreate = events.UserCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "UserCreate";
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.UserDelete = events.UserDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "UserDelete";
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.UserPasswordChange =
                            events.UserPasswordChange.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "UserPasswordChange";
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.SessionStart = events.SessionStart.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionStart";
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.SessionJoin = events.SessionJoin.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionJoin";
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.SessionPrint = events.SessionPrint.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionPrint";
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.SessionReject = events.SessionReject.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionReject";
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Resize = events.Resize.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "Resize";
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.SessionEnd = events.SessionEnd.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionEnd";
                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.SessionCommand = events.SessionCommand.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionCommand";
                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.SessionDisk = events.SessionDisk.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionDisk";
                        break;
                    }
                    case 13: {
                        const length = decoder.uint32();
                        obj.SessionNetwork = events.SessionNetwork.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionNetwork";
                        break;
                    }
                    case 14: {
                        const length = decoder.uint32();
                        obj.SessionData = events.SessionData.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionData";
                        break;
                    }
                    case 15: {
                        const length = decoder.uint32();
                        obj.SessionLeave = events.SessionLeave.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionLeave";
                        break;
                    }
                    case 16: {
                        const length = decoder.uint32();
                        obj.PortForward = events.PortForward.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "PortForward";
                        break;
                    }
                    case 17: {
                        const length = decoder.uint32();
                        obj.X11Forward = events.X11Forward.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "X11Forward";
                        break;
                    }
                    case 18: {
                        const length = decoder.uint32();
                        obj.SCP = events.SCP.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SCP";
                        break;
                    }
                    case 19: {
                        const length = decoder.uint32();
                        obj.Exec = events.Exec.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "Exec";
                        break;
                    }
                    case 20: {
                        const length = decoder.uint32();
                        obj.Subsystem = events.Subsystem.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "Subsystem";
                        break;
                    }
                    case 21: {
                        const length = decoder.uint32();
                        obj.ClientDisconnect = events.ClientDisconnect.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "ClientDisconnect";
                        break;
                    }
                    case 22: {
                        const length = decoder.uint32();
                        obj.AuthAttempt = events.AuthAttempt.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AuthAttempt";
                        break;
                    }
                    case 23: {
                        const length = decoder.uint32();
                        obj.AccessRequestCreate =
                            events.AccessRequestCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AccessRequestCreate";
                        break;
                    }
                    case 24: {
                        const length = decoder.uint32();
                        obj.UserTokenCreate = events.UserTokenCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "UserTokenCreate";
                        break;
                    }
                    case 25: {
                        const length = decoder.uint32();
                        obj.RoleCreate = events.RoleCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "RoleCreate";
                        break;
                    }
                    case 26: {
                        const length = decoder.uint32();
                        obj.RoleDelete = events.RoleDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "RoleDelete";
                        break;
                    }
                    case 27: {
                        const length = decoder.uint32();
                        obj.TrustedClusterCreate =
                            events.TrustedClusterCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "TrustedClusterCreate";
                        break;
                    }
                    case 28: {
                        const length = decoder.uint32();
                        obj.TrustedClusterDelete =
                            events.TrustedClusterDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "TrustedClusterDelete";
                        break;
                    }
                    case 29: {
                        const length = decoder.uint32();
                        obj.TrustedClusterTokenCreate =
                            events.TrustedClusterTokenCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "TrustedClusterTokenCreate";
                        break;
                    }
                    case 30: {
                        const length = decoder.uint32();
                        obj.GithubConnectorCreate =
                            events.GithubConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "GithubConnectorCreate";
                        break;
                    }
                    case 31: {
                        const length = decoder.uint32();
                        obj.GithubConnectorDelete =
                            events.GithubConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "GithubConnectorDelete";
                        break;
                    }
                    case 32: {
                        const length = decoder.uint32();
                        obj.OIDCConnectorCreate =
                            events.OIDCConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "OIDCConnectorCreate";
                        break;
                    }
                    case 33: {
                        const length = decoder.uint32();
                        obj.OIDCConnectorDelete =
                            events.OIDCConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "OIDCConnectorDelete";
                        break;
                    }
                    case 34: {
                        const length = decoder.uint32();
                        obj.SAMLConnectorCreate =
                            events.SAMLConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SAMLConnectorCreate";
                        break;
                    }
                    case 35: {
                        const length = decoder.uint32();
                        obj.SAMLConnectorDelete =
                            events.SAMLConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SAMLConnectorDelete";
                        break;
                    }
                    case 36: {
                        const length = decoder.uint32();
                        obj.KubeRequest = events.KubeRequest.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "KubeRequest";
                        break;
                    }
                    case 37: {
                        const length = decoder.uint32();
                        obj.AppSessionStart = events.AppSessionStart.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppSessionStart";
                        break;
                    }
                    case 38: {
                        const length = decoder.uint32();
                        obj.AppSessionChunk = events.AppSessionChunk.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppSessionChunk";
                        break;
                    }
                    case 39: {
                        const length = decoder.uint32();
                        obj.AppSessionRequest = events.AppSessionRequest.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppSessionRequest";
                        break;
                    }
                    case 40: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionStart =
                            events.DatabaseSessionStart.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseSessionStart";
                        break;
                    }
                    case 41: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionEnd =
                            events.DatabaseSessionEnd.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseSessionEnd";
                        break;
                    }
                    case 42: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionQuery =
                            events.DatabaseSessionQuery.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseSessionQuery";
                        break;
                    }
                    case 43: {
                        const length = decoder.uint32();
                        obj.SessionUpload = events.SessionUpload.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionUpload";
                        break;
                    }
                    case 44: {
                        const length = decoder.uint32();
                        obj.MFADeviceAdd = events.MFADeviceAdd.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "MFADeviceAdd";
                        break;
                    }
                    case 45: {
                        const length = decoder.uint32();
                        obj.MFADeviceDelete = events.MFADeviceDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "MFADeviceDelete";
                        break;
                    }
                    case 46: {
                        const length = decoder.uint32();
                        obj.BillingInformationUpdate =
                            events.BillingInformationUpdate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "BillingInformationUpdate";
                        break;
                    }
                    case 47: {
                        const length = decoder.uint32();
                        obj.BillingCardCreate = events.BillingCardCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "BillingCardCreate";
                        break;
                    }
                    case 48: {
                        const length = decoder.uint32();
                        obj.BillingCardDelete = events.BillingCardDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "BillingCardDelete";
                        break;
                    }
                    case 49: {
                        const length = decoder.uint32();
                        obj.LockCreate = events.LockCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "LockCreate";
                        break;
                    }
                    case 50: {
                        const length = decoder.uint32();
                        obj.LockDelete = events.LockDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "LockDelete";
                        break;
                    }
                    case 51: {
                        const length = decoder.uint32();
                        obj.RecoveryCodeGenerate =
                            events.RecoveryCodeGenerate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "RecoveryCodeGenerate";
                        break;
                    }
                    case 52: {
                        const length = decoder.uint32();
                        obj.RecoveryCodeUsed = events.RecoveryCodeUsed.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "RecoveryCodeUsed";
                        break;
                    }
                    case 53: {
                        const length = decoder.uint32();
                        obj.DatabaseCreate = events.DatabaseCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseCreate";
                        break;
                    }
                    case 54: {
                        const length = decoder.uint32();
                        obj.DatabaseUpdate = events.DatabaseUpdate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseUpdate";
                        break;
                    }
                    case 55: {
                        const length = decoder.uint32();
                        obj.DatabaseDelete = events.DatabaseDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "DatabaseDelete";
                        break;
                    }
                    case 56: {
                        const length = decoder.uint32();
                        obj.AppCreate = events.AppCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppCreate";
                        break;
                    }
                    case 57: {
                        const length = decoder.uint32();
                        obj.AppUpdate = events.AppUpdate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppUpdate";
                        break;
                    }
                    case 58: {
                        const length = decoder.uint32();
                        obj.AppDelete = events.AppDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AppDelete";
                        break;
                    }
                    case 59: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopSessionStart =
                            events.WindowsDesktopSessionStart.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "WindowsDesktopSessionStart";
                        break;
                    }
                    case 60: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopSessionEnd =
                            events.WindowsDesktopSessionEnd.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "WindowsDesktopSessionEnd";
                        break;
                    }
                    case 66: {
                        const length = decoder.uint32();
                        obj.AccessRequestDelete =
                            events.AccessRequestDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        obj.__oneOf_Event = "AccessRequestDelete";
                        break;
                    }
                    case 67: {
                        const length = decoder.uint32();
                        obj.SessionConnect = events.SessionConnect.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "SessionConnect";
                        break;
                    }
                    case 68: {
                        const length = decoder.uint32();
                        obj.CertificateCreate = events.CertificateCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        obj.__oneOf_Event = "CertificateCreate";
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OneOf

        public size(): u32 {
            let size: u32 = 0;

            if (this.UserLogin != null) {
                const f: events.UserLogin = this.UserLogin as events.UserLogin;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserCreate != null) {
                const f: events.UserCreate = this
                    .UserCreate as events.UserCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserDelete != null) {
                const f: events.UserDelete = this
                    .UserDelete as events.UserDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserPasswordChange != null) {
                const f: events.UserPasswordChange = this
                    .UserPasswordChange as events.UserPasswordChange;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionStart != null) {
                const f: events.SessionStart = this
                    .SessionStart as events.SessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionJoin != null) {
                const f: events.SessionJoin = this
                    .SessionJoin as events.SessionJoin;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionPrint != null) {
                const f: events.SessionPrint = this
                    .SessionPrint as events.SessionPrint;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionReject != null) {
                const f: events.SessionReject = this
                    .SessionReject as events.SessionReject;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resize != null) {
                const f: events.Resize = this.Resize as events.Resize;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionEnd != null) {
                const f: events.SessionEnd = this
                    .SessionEnd as events.SessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionCommand != null) {
                const f: events.SessionCommand = this
                    .SessionCommand as events.SessionCommand;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionDisk != null) {
                const f: events.SessionDisk = this
                    .SessionDisk as events.SessionDisk;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionNetwork != null) {
                const f: events.SessionNetwork = this
                    .SessionNetwork as events.SessionNetwork;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionData != null) {
                const f: events.SessionData = this
                    .SessionData as events.SessionData;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionLeave != null) {
                const f: events.SessionLeave = this
                    .SessionLeave as events.SessionLeave;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.PortForward != null) {
                const f: events.PortForward = this
                    .PortForward as events.PortForward;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.X11Forward != null) {
                const f: events.X11Forward = this
                    .X11Forward as events.X11Forward;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SCP != null) {
                const f: events.SCP = this.SCP as events.SCP;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Exec != null) {
                const f: events.Exec = this.Exec as events.Exec;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Subsystem != null) {
                const f: events.Subsystem = this.Subsystem as events.Subsystem;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ClientDisconnect != null) {
                const f: events.ClientDisconnect = this
                    .ClientDisconnect as events.ClientDisconnect;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AuthAttempt != null) {
                const f: events.AuthAttempt = this
                    .AuthAttempt as events.AuthAttempt;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AccessRequestCreate != null) {
                const f: events.AccessRequestCreate = this
                    .AccessRequestCreate as events.AccessRequestCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserTokenCreate != null) {
                const f: events.UserTokenCreate = this
                    .UserTokenCreate as events.UserTokenCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleCreate != null) {
                const f: events.RoleCreate = this
                    .RoleCreate as events.RoleCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleDelete != null) {
                const f: events.RoleDelete = this
                    .RoleDelete as events.RoleDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterCreate != null) {
                const f: events.TrustedClusterCreate = this
                    .TrustedClusterCreate as events.TrustedClusterCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterDelete != null) {
                const f: events.TrustedClusterDelete = this
                    .TrustedClusterDelete as events.TrustedClusterDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterTokenCreate != null) {
                const f: events.TrustedClusterTokenCreate = this
                    .TrustedClusterTokenCreate as events.TrustedClusterTokenCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GithubConnectorCreate != null) {
                const f: events.GithubConnectorCreate = this
                    .GithubConnectorCreate as events.GithubConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GithubConnectorDelete != null) {
                const f: events.GithubConnectorDelete = this
                    .GithubConnectorDelete as events.GithubConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.OIDCConnectorCreate != null) {
                const f: events.OIDCConnectorCreate = this
                    .OIDCConnectorCreate as events.OIDCConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.OIDCConnectorDelete != null) {
                const f: events.OIDCConnectorDelete = this
                    .OIDCConnectorDelete as events.OIDCConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SAMLConnectorCreate != null) {
                const f: events.SAMLConnectorCreate = this
                    .SAMLConnectorCreate as events.SAMLConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SAMLConnectorDelete != null) {
                const f: events.SAMLConnectorDelete = this
                    .SAMLConnectorDelete as events.SAMLConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubeRequest != null) {
                const f: events.KubeRequest = this
                    .KubeRequest as events.KubeRequest;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionStart != null) {
                const f: events.AppSessionStart = this
                    .AppSessionStart as events.AppSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionChunk != null) {
                const f: events.AppSessionChunk = this
                    .AppSessionChunk as events.AppSessionChunk;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionRequest != null) {
                const f: events.AppSessionRequest = this
                    .AppSessionRequest as events.AppSessionRequest;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionStart != null) {
                const f: events.DatabaseSessionStart = this
                    .DatabaseSessionStart as events.DatabaseSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionEnd != null) {
                const f: events.DatabaseSessionEnd = this
                    .DatabaseSessionEnd as events.DatabaseSessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionQuery != null) {
                const f: events.DatabaseSessionQuery = this
                    .DatabaseSessionQuery as events.DatabaseSessionQuery;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionUpload != null) {
                const f: events.SessionUpload = this
                    .SessionUpload as events.SessionUpload;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADeviceAdd != null) {
                const f: events.MFADeviceAdd = this
                    .MFADeviceAdd as events.MFADeviceAdd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADeviceDelete != null) {
                const f: events.MFADeviceDelete = this
                    .MFADeviceDelete as events.MFADeviceDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingInformationUpdate != null) {
                const f: events.BillingInformationUpdate = this
                    .BillingInformationUpdate as events.BillingInformationUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingCardCreate != null) {
                const f: events.BillingCardCreate = this
                    .BillingCardCreate as events.BillingCardCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingCardDelete != null) {
                const f: events.BillingCardDelete = this
                    .BillingCardDelete as events.BillingCardDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockCreate != null) {
                const f: events.LockCreate = this
                    .LockCreate as events.LockCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockDelete != null) {
                const f: events.LockDelete = this
                    .LockDelete as events.LockDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryCodeGenerate != null) {
                const f: events.RecoveryCodeGenerate = this
                    .RecoveryCodeGenerate as events.RecoveryCodeGenerate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryCodeUsed != null) {
                const f: events.RecoveryCodeUsed = this
                    .RecoveryCodeUsed as events.RecoveryCodeUsed;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseCreate != null) {
                const f: events.DatabaseCreate = this
                    .DatabaseCreate as events.DatabaseCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseUpdate != null) {
                const f: events.DatabaseUpdate = this
                    .DatabaseUpdate as events.DatabaseUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseDelete != null) {
                const f: events.DatabaseDelete = this
                    .DatabaseDelete as events.DatabaseDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppCreate != null) {
                const f: events.AppCreate = this.AppCreate as events.AppCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppUpdate != null) {
                const f: events.AppUpdate = this.AppUpdate as events.AppUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppDelete != null) {
                const f: events.AppDelete = this.AppDelete as events.AppDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.WindowsDesktopSessionStart != null) {
                const f: events.WindowsDesktopSessionStart = this
                    .WindowsDesktopSessionStart as events.WindowsDesktopSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.WindowsDesktopSessionEnd != null) {
                const f: events.WindowsDesktopSessionEnd = this
                    .WindowsDesktopSessionEnd as events.WindowsDesktopSessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AccessRequestDelete != null) {
                const f: events.AccessRequestDelete = this
                    .AccessRequestDelete as events.AccessRequestDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionConnect != null) {
                const f: events.SessionConnect = this
                    .SessionConnect as events.SessionConnect;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.CertificateCreate != null) {
                const f: events.CertificateCreate = this
                    .CertificateCreate as events.CertificateCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OneOf to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OneOf to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UserLogin != null) {
                const f = this.UserLogin as events.UserLogin;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UserCreate != null) {
                const f = this.UserCreate as events.UserCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UserDelete != null) {
                const f = this.UserDelete as events.UserDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UserPasswordChange != null) {
                const f = this.UserPasswordChange as events.UserPasswordChange;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionStart != null) {
                const f = this.SessionStart as events.SessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionJoin != null) {
                const f = this.SessionJoin as events.SessionJoin;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionPrint != null) {
                const f = this.SessionPrint as events.SessionPrint;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionReject != null) {
                const f = this.SessionReject as events.SessionReject;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Resize != null) {
                const f = this.Resize as events.Resize;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionEnd != null) {
                const f = this.SessionEnd as events.SessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionCommand != null) {
                const f = this.SessionCommand as events.SessionCommand;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionDisk != null) {
                const f = this.SessionDisk as events.SessionDisk;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionNetwork != null) {
                const f = this.SessionNetwork as events.SessionNetwork;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x6a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionData != null) {
                const f = this.SessionData as events.SessionData;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x72);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionLeave != null) {
                const f = this.SessionLeave as events.SessionLeave;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x7a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.PortForward != null) {
                const f = this.PortForward as events.PortForward;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x82);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.X11Forward != null) {
                const f = this.X11Forward as events.X11Forward;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x8a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SCP != null) {
                const f = this.SCP as events.SCP;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x92);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Exec != null) {
                const f = this.Exec as events.Exec;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x9a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.Subsystem != null) {
                const f = this.Subsystem as events.Subsystem;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.ClientDisconnect != null) {
                const f = this.ClientDisconnect as events.ClientDisconnect;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xaa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AuthAttempt != null) {
                const f = this.AuthAttempt as events.AuthAttempt;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xb2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AccessRequestCreate != null) {
                const f = this
                    .AccessRequestCreate as events.AccessRequestCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xba);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UserTokenCreate != null) {
                const f = this.UserTokenCreate as events.UserTokenCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xc2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RoleCreate != null) {
                const f = this.RoleCreate as events.RoleCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xca);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RoleDelete != null) {
                const f = this.RoleDelete as events.RoleDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xd2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TrustedClusterCreate != null) {
                const f = this
                    .TrustedClusterCreate as events.TrustedClusterCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xda);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TrustedClusterDelete != null) {
                const f = this
                    .TrustedClusterDelete as events.TrustedClusterDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xe2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TrustedClusterTokenCreate != null) {
                const f = this
                    .TrustedClusterTokenCreate as events.TrustedClusterTokenCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xea);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.GithubConnectorCreate != null) {
                const f = this
                    .GithubConnectorCreate as events.GithubConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xf2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.GithubConnectorDelete != null) {
                const f = this
                    .GithubConnectorDelete as events.GithubConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xfa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.OIDCConnectorCreate != null) {
                const f = this
                    .OIDCConnectorCreate as events.OIDCConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x102);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.OIDCConnectorDelete != null) {
                const f = this
                    .OIDCConnectorDelete as events.OIDCConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x10a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SAMLConnectorCreate != null) {
                const f = this
                    .SAMLConnectorCreate as events.SAMLConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x112);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SAMLConnectorDelete != null) {
                const f = this
                    .SAMLConnectorDelete as events.SAMLConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x11a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.KubeRequest != null) {
                const f = this.KubeRequest as events.KubeRequest;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x122);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppSessionStart != null) {
                const f = this.AppSessionStart as events.AppSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppSessionChunk != null) {
                const f = this.AppSessionChunk as events.AppSessionChunk;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x132);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppSessionRequest != null) {
                const f = this.AppSessionRequest as events.AppSessionRequest;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x13a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseSessionStart != null) {
                const f = this
                    .DatabaseSessionStart as events.DatabaseSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x142);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseSessionEnd != null) {
                const f = this.DatabaseSessionEnd as events.DatabaseSessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x14a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseSessionQuery != null) {
                const f = this
                    .DatabaseSessionQuery as events.DatabaseSessionQuery;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x152);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionUpload != null) {
                const f = this.SessionUpload as events.SessionUpload;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x15a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.MFADeviceAdd != null) {
                const f = this.MFADeviceAdd as events.MFADeviceAdd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x162);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.MFADeviceDelete != null) {
                const f = this.MFADeviceDelete as events.MFADeviceDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x16a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BillingInformationUpdate != null) {
                const f = this
                    .BillingInformationUpdate as events.BillingInformationUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x172);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BillingCardCreate != null) {
                const f = this.BillingCardCreate as events.BillingCardCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x17a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.BillingCardDelete != null) {
                const f = this.BillingCardDelete as events.BillingCardDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x182);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.LockCreate != null) {
                const f = this.LockCreate as events.LockCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x18a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.LockDelete != null) {
                const f = this.LockDelete as events.LockDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x192);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RecoveryCodeGenerate != null) {
                const f = this
                    .RecoveryCodeGenerate as events.RecoveryCodeGenerate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x19a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RecoveryCodeUsed != null) {
                const f = this.RecoveryCodeUsed as events.RecoveryCodeUsed;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseCreate != null) {
                const f = this.DatabaseCreate as events.DatabaseCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1aa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseUpdate != null) {
                const f = this.DatabaseUpdate as events.DatabaseUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1b2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseDelete != null) {
                const f = this.DatabaseDelete as events.DatabaseDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1ba);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppCreate != null) {
                const f = this.AppCreate as events.AppCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1c2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppUpdate != null) {
                const f = this.AppUpdate as events.AppUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1ca);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AppDelete != null) {
                const f = this.AppDelete as events.AppDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1d2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.WindowsDesktopSessionStart != null) {
                const f = this
                    .WindowsDesktopSessionStart as events.WindowsDesktopSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1da);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.WindowsDesktopSessionEnd != null) {
                const f = this
                    .WindowsDesktopSessionEnd as events.WindowsDesktopSessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1e2);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.AccessRequestDelete != null) {
                const f = this
                    .AccessRequestDelete as events.AccessRequestDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x212);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionConnect != null) {
                const f = this.SessionConnect as events.SessionConnect;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x21a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.CertificateCreate != null) {
                const f = this.CertificateCreate as events.CertificateCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x222);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode OneOf
    } // OneOf

    // StreamStatus reflects stream status
    export class StreamStatus {
        // UploadID represents upload ID
        public UploadID: string = "";
        // LastEventIndex updates last event index
        public LastEventIndex: i64;
        // LastUploadTime is the time of the last upload
        public LastUploadTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes StreamStatus from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StreamStatus {
            return StreamStatus.decode(new DataView(buf));
        }

        // Decodes StreamStatus from a DataView
        static decode(view: DataView): StreamStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new StreamStatus();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.UploadID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.LastEventIndex = decoder.int64();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LastUploadTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StreamStatus

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.UploadID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UploadID.length) +
                      this.UploadID.length
                    : 0;
            size +=
                this.LastEventIndex == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.LastEventIndex);

            if (this.LastUploadTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LastUploadTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StreamStatus to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StreamStatus to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UploadID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.UploadID.length);
                encoder.string(this.UploadID);
            }
            if (this.LastEventIndex != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.LastEventIndex);
            }

            if (this.LastUploadTime != null) {
                const f = this.LastUploadTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            return buf;
        } // encode StreamStatus
    } // StreamStatus

    // SessionUpload is a session upload
    export class SessionUpload {
        // Metadata is a common event metadata
        public Metadata: events.Metadata = new events.Metadata();
        // SessionMetadata is a common event session metadata
        public SessionMetadata: events.SessionMetadata =
            new events.SessionMetadata();
        // ID is a unique event identifier
        public UID: string = "";
        // URL is where the url the session event data upload is at
        public SessionURL: string = "";

        // Decodes SessionUpload from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionUpload {
            return SessionUpload.decode(new DataView(buf));
        }

        // Decodes SessionUpload from a DataView
        static decode(view: DataView): SessionUpload {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionUpload();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.SessionMetadata = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.UID = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.SessionURL = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionUpload

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionMetadata != null) {
                const f: events.SessionMetadata = this
                    .SessionMetadata as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.UID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UID.length) +
                      this.UID.length
                    : 0;
            size +=
                this.SessionURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionURL.length) +
                      this.SessionURL.length
                    : 0;

            return size;
        }

        // Encodes SessionUpload to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionUpload to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.SessionMetadata != null) {
                const f = this.SessionMetadata as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.UID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.UID.length);
                encoder.string(this.UID);
            }
            if (this.SessionURL.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.SessionURL.length);
                encoder.string(this.SessionURL);
            }

            return buf;
        } // encode SessionUpload
    } // SessionUpload

    /**
     * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except
     *  for RouteToApp and RouteToDatabase which are nullable and Traits which is
     *  represented as a google.protobuf.Struct (still containing a map from string
     *  to strings). Field names match other names already used in other events
     *  rather than the field names in tlsca.Identity.
     */
    export class Identity {
        // User is a username or name of the node connection
        public User: string = "";
        // Impersonator is a username of a user impersonating this user
        public Impersonator: string = "";
        // Roles is a list of groups (Teleport roles) encoded in the identity
        public Roles: Array<string> = new Array<string>();
        // Usage is a list of usage restrictions encoded in the identity
        public Usage: Array<string> = new Array<string>();
        // Logins is a list of Unix logins allowed.
        public Logins: Array<string> = new Array<string>();
        // KubernetesGroups is a list of Kubernetes groups allowed
        public KubernetesGroups: Array<string> = new Array<string>();
        // KubernetesUsers is a list of Kubernetes users allowed
        public KubernetesUsers: Array<string> = new Array<string>();
        // Expires specifies whenever the session will expire
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        /**
         * RouteToCluster specifies the target cluster
         *  if present in the session
         */
        public RouteToCluster: string = "";
        /**
         * KubernetesCluster specifies the target kubernetes cluster for TLS
         *  identities. This can be empty on older Teleport clients.
         */
        public KubernetesCluster: string = "";
        // Traits hold claim data used to populate a role at runtime.
        public Traits: wrappers.LabelValues = new wrappers.LabelValues();
        /**
         * RouteToApp holds routing information for applications. Routing metadata
         *  allows Teleport web proxy to route HTTP requests to the appropriate
         *  cluster and Teleport application proxy within the cluster.
         */
        public RouteToApp: events.RouteToApp = new events.RouteToApp();
        /**
         * TeleportCluster is the name of the teleport cluster that this identity
         *  originated from. For TLS certs this may not be the same as cert issuer,
         *  in case of multi-hop requests that originate from a remote cluster.
         */
        public TeleportCluster: string = "";
        // RouteToDatabase contains routing information for databases.
        public RouteToDatabase: events.RouteToDatabase =
            new events.RouteToDatabase();
        // DatabaseNames is a list of allowed database names.
        public DatabaseNames: Array<string> = new Array<string>();
        // DatabaseUsers is a list of allowed database users.
        public DatabaseUsers: Array<string> = new Array<string>();
        /**
         * MFADeviceUUID is the UUID of an MFA device when this Identity was
         *  confirmed immediately after an MFA check.
         */
        public MFADeviceUUID: string = "";
        // ClientIP is an observed IP of the client that this Identity represents.
        public ClientIP: string = "";
        // AWSRoleARNs is a list of allowed AWS role ARNs user can assume.
        public AWSRoleARNs: Array<string> = new Array<string>();
        // AccessRequests is a list of UUIDs of active requests for this Identity.
        public AccessRequests: Array<string> = new Array<string>();
        /**
         * DisallowReissue is a flag that, if set, instructs the auth server to
         *  deny any attempts to reissue new certificates while authenticated with
         *  this certificate.
         */
        public DisallowReissue: bool;

        // Decodes Identity from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Identity {
            return Identity.decode(new DataView(buf));
        }

        // Decodes Identity from a DataView
        static decode(view: DataView): Identity {
            const decoder = new __proto.Decoder(view);
            const obj = new Identity();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Impersonator = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 4: {
                        obj.Usage.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.Logins.push(decoder.string());
                        break;
                    }
                    case 6: {
                        obj.KubernetesGroups.push(decoder.string());
                        break;
                    }
                    case 7: {
                        obj.KubernetesUsers.push(decoder.string());
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.RouteToCluster = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.KubernetesCluster = decoder.string();
                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.Traits = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.RouteToApp = events.RouteToApp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        obj.TeleportCluster = decoder.string();
                        break;
                    }
                    case 14: {
                        const length = decoder.uint32();
                        obj.RouteToDatabase = events.RouteToDatabase.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 15: {
                        obj.DatabaseNames.push(decoder.string());
                        break;
                    }
                    case 16: {
                        obj.DatabaseUsers.push(decoder.string());
                        break;
                    }
                    case 17: {
                        obj.MFADeviceUUID = decoder.string();
                        break;
                    }
                    case 18: {
                        obj.ClientIP = decoder.string();
                        break;
                    }
                    case 19: {
                        obj.AWSRoleARNs.push(decoder.string());
                        break;
                    }
                    case 20: {
                        obj.AccessRequests.push(decoder.string());
                        break;
                    }
                    case 21: {
                        obj.DisallowReissue = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Identity

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Impersonator.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Impersonator.length) +
                      this.Impersonator.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            size += __size_string_repeated(this.Usage);

            size += __size_string_repeated(this.Logins);

            size += __size_string_repeated(this.KubernetesGroups);

            size += __size_string_repeated(this.KubernetesUsers);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RouteToCluster.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RouteToCluster.length) +
                      this.RouteToCluster.length
                    : 0;
            size +=
                this.KubernetesCluster.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesCluster.length) +
                      this.KubernetesCluster.length
                    : 0;

            if (this.Traits != null) {
                const f: wrappers.LabelValues = this
                    .Traits as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RouteToApp != null) {
                const f: events.RouteToApp = this
                    .RouteToApp as events.RouteToApp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.TeleportCluster.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TeleportCluster.length) +
                      this.TeleportCluster.length
                    : 0;

            if (this.RouteToDatabase != null) {
                const f: events.RouteToDatabase = this
                    .RouteToDatabase as events.RouteToDatabase;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.DatabaseNames);

            size += __size_string_repeated(this.DatabaseUsers);

            size +=
                this.MFADeviceUUID.length > 0
                    ? 2 +
                      __proto.Sizer.varint64(this.MFADeviceUUID.length) +
                      this.MFADeviceUUID.length
                    : 0;
            size +=
                this.ClientIP.length > 0
                    ? 2 +
                      __proto.Sizer.varint64(this.ClientIP.length) +
                      this.ClientIP.length
                    : 0;

            size += __size_string_repeated(this.AWSRoleARNs);

            size += __size_string_repeated(this.AccessRequests);

            size += this.DisallowReissue == 0 ? 0 : 2 + 1;

            return size;
        }

        // Encodes Identity to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Identity to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Impersonator.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Impersonator.length);
                encoder.string(this.Impersonator);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Usage.length > 0) {
                for (let n: i32 = 0; n < this.Usage.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Usage[n].length);
                    encoder.string(this.Usage[n]);
                }
            }

            if (this.Logins.length > 0) {
                for (let n: i32 = 0; n < this.Logins.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.Logins[n].length);
                    encoder.string(this.Logins[n]);
                }
            }

            if (this.KubernetesGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesGroups.length; n++) {
                    encoder.uint32(0x32);
                    encoder.uint32(this.KubernetesGroups[n].length);
                    encoder.string(this.KubernetesGroups[n]);
                }
            }

            if (this.KubernetesUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesUsers.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.KubernetesUsers[n].length);
                    encoder.string(this.KubernetesUsers[n]);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RouteToCluster.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.RouteToCluster.length);
                encoder.string(this.RouteToCluster);
            }
            if (this.KubernetesCluster.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.KubernetesCluster.length);
                encoder.string(this.KubernetesCluster);
            }

            if (this.Traits != null) {
                const f = this.Traits as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.RouteToApp != null) {
                const f = this.RouteToApp as events.RouteToApp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.TeleportCluster.length > 0) {
                encoder.uint32(0x6a);
                encoder.uint32(this.TeleportCluster.length);
                encoder.string(this.TeleportCluster);
            }

            if (this.RouteToDatabase != null) {
                const f = this.RouteToDatabase as events.RouteToDatabase;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x72);
                    encoder.uint32(messageSize);
                    f.encodeU8Array(encoder);
                }
            }

            if (this.DatabaseNames.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseNames.length; n++) {
                    encoder.uint32(0x7a);
                    encoder.uint32(this.DatabaseNames[n].length);
                    encoder.string(this.DatabaseNames[n]);
                }
            }

            if (this.DatabaseUsers.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseUsers.length; n++) {
                    encoder.uint32(0x82);
                    encoder.uint32(this.DatabaseUsers[n].length);
                    encoder.string(this.DatabaseUsers[n]);
                }
            }

            if (this.MFADeviceUUID.length > 0) {
                encoder.uint32(0x8a);
                encoder.uint32(this.MFADeviceUUID.length);
                encoder.string(this.MFADeviceUUID);
            }
            if (this.ClientIP.length > 0) {
                encoder.uint32(0x92);
                encoder.uint32(this.ClientIP.length);
                encoder.string(this.ClientIP);
            }

            if (this.AWSRoleARNs.length > 0) {
                for (let n: i32 = 0; n < this.AWSRoleARNs.length; n++) {
                    encoder.uint32(0x9a);
                    encoder.uint32(this.AWSRoleARNs[n].length);
                    encoder.string(this.AWSRoleARNs[n]);
                }
            }

            if (this.AccessRequests.length > 0) {
                for (let n: i32 = 0; n < this.AccessRequests.length; n++) {
                    encoder.uint32(0xa2);
                    encoder.uint32(this.AccessRequests[n].length);
                    encoder.string(this.AccessRequests[n]);
                }
            }

            if (this.DisallowReissue != 0) {
                encoder.uint32(0xa8);
                encoder.bool(this.DisallowReissue);
            }

            return buf;
        } // encode Identity
    } // Identity

    // RouteToApp contains parameters for application access certificate requests.
    export class RouteToApp {
        // Name is the application name certificate is being requested for.
        public Name: string = "";
        // SessionID is the ID of the application session.
        public SessionID: string = "";
        // PublicAddr is the application public address.
        public PublicAddr: string = "";
        // ClusterName is the cluster where the application resides.
        public ClusterName: string = "";
        // AWSRoleARN is the AWS role to assume when accessing AWS API.
        public AWSRoleARN: string = "";

        // Decodes RouteToApp from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RouteToApp {
            return RouteToApp.decode(new DataView(buf));
        }

        // Decodes RouteToApp from a DataView
        static decode(view: DataView): RouteToApp {
            const decoder = new __proto.Decoder(view);
            const obj = new RouteToApp();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SessionID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AWSRoleARN = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RouteToApp

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;
            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;
            size +=
                this.AWSRoleARN.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSRoleARN.length) +
                      this.AWSRoleARN.length
                    : 0;

            return size;
        }

        // Encodes RouteToApp to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RouteToApp to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.SessionID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }
            if (this.ClusterName.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }
            if (this.AWSRoleARN.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.AWSRoleARN.length);
                encoder.string(this.AWSRoleARN);
            }

            return buf;
        } // encode RouteToApp
    } // RouteToApp

    // RouteToDatabase combines parameters for database service routing information.
    export class RouteToDatabase {
        // ServiceName is the Teleport database proxy service name the cert is for.
        public ServiceName: string = "";
        // Protocol is the type of the database the cert is for.
        public Protocol: string = "";
        // Username is an optional database username to embed.
        public Username: string = "";
        // Database is an optional database name to embed.
        public Database: string = "";

        // Decodes RouteToDatabase from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RouteToDatabase {
            return RouteToDatabase.decode(new DataView(buf));
        }

        // Decodes RouteToDatabase from a DataView
        static decode(view: DataView): RouteToDatabase {
            const decoder = new __proto.Decoder(view);
            const obj = new RouteToDatabase();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ServiceName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Protocol = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Username = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Database = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RouteToDatabase

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ServiceName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServiceName.length) +
                      this.ServiceName.length
                    : 0;
            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;
            size +=
                this.Username.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Username.length) +
                      this.Username.length
                    : 0;
            size +=
                this.Database.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Database.length) +
                      this.Database.length
                    : 0;

            return size;
        }

        // Encodes RouteToDatabase to the DataView
        encode(): DataView {
            const source = this.encodeU8Array();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RouteToDatabase to the Array<u8>
        encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ServiceName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ServiceName.length);
                encoder.string(this.ServiceName);
            }
            if (this.Protocol.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }
            if (this.Username.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Username.length);
                encoder.string(this.Username);
            }
            if (this.Database.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Database.length);
                encoder.string(this.Database);
            }

            return buf;
        } // encode RouteToDatabase
    } // RouteToDatabase
} // events

// __decodeMap_string_google_protobuf_Value

function __decodeMap_string_google_protobuf_Value(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, google.protobuf.Value>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: google.protobuf.Value = new google.protobuf.Value();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = google.protobuf.Value.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as google.protobuf.Value);
}

// __sizeMapEntry_string_google_protobuf_Value

function __sizeMapEntry_string_google_protobuf_Value(
    key: string,
    value: google.protobuf.Value
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __size_string_repeated

function __size_string_repeated(value: Array<string>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;
    }

    return size;
}

// __decodeMap_string_wrappers_StringValues

function __decodeMap_string_wrappers_StringValues(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, wrappers.StringValues>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: wrappers.StringValues = new wrappers.StringValues();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = wrappers.StringValues.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as wrappers.StringValues);
}

// __sizeMapEntry_string_wrappers_StringValues

function __sizeMapEntry_string_wrappers_StringValues(
    key: string,
    value: wrappers.StringValues
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __decodeMap_string_string

function __decodeMap_string_string(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, string>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: string = "";

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                value = decoder.string();
                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as string);
}

// __sizeMapEntry_string_string

function __sizeMapEntry_string_string(key: string, value: string): u32 {
    return (
        (key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0) +
        (value.length > 0
            ? 1 + __proto.Sizer.varint64(value.length) + value.length
            : 0)
    );
}

// __decodeMap_string_types_CommandLabelV2

function __decodeMap_string_types_CommandLabelV2(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.CommandLabelV2>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.CommandLabelV2 = new types.CommandLabelV2();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.CommandLabelV2.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.CommandLabelV2);
}

// __sizeMapEntry_string_types_CommandLabelV2

function __sizeMapEntry_string_types_CommandLabelV2(
    key: string,
    value: types.CommandLabelV2
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __size_bytes_repeated

function __size_bytes_repeated(value: Array<Array<u8>>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;
    }

    return size;
}

// __size_uint32_repeated

function __size_uint32_repeated(value: Array<u32>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.uint32(value[n]);
    }

    return size;
}

// __decodeMap_string_types_ThresholdIndexSets

function __decodeMap_string_types_ThresholdIndexSets(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.ThresholdIndexSets>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.ThresholdIndexSets = new types.ThresholdIndexSets();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.ThresholdIndexSets.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.ThresholdIndexSets);
}

// __sizeMapEntry_string_types_ThresholdIndexSets

function __sizeMapEntry_string_types_ThresholdIndexSets(
    key: string,
    value: types.ThresholdIndexSets
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __decodeMap_string_types_PluginDataEntry

function __decodeMap_string_types_PluginDataEntry(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.PluginDataEntry>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.PluginDataEntry = new types.PluginDataEntry();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.PluginDataEntry.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.PluginDataEntry);
}

// __sizeMapEntry_string_types_PluginDataEntry

function __sizeMapEntry_string_types_PluginDataEntry(
    key: string,
    value: types.PluginDataEntry
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// Type aliases
export type Event = events.OneOf;

namespace __proto {
    /**
     * Decoder implements protobuf message decode interface.
     *
     * Useful references:
     *
     * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
     * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
     * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
     */
    export class Decoder {
        public view: DataView;
        public pos: i32;

        constructor(view: DataView) {
            this.view = view;
            this.pos = 0;
        }

        /**
         * Returns true if current reader has reached it's end
         * @returns True if current reader has reached it's end
         */
        @inline
        eof(): bool {
            return this.pos >= this.view.byteLength;
        }

        /**
         * Returns current buffer length in bytes
         * @returns Length in bytes
         */
        @inline
        get byteLength(): i32 {
            return this.view.byteLength;
        }

        /**
         * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].
         * TODO: Replace with return tuple when tuples become implemented in AS.
         * @returns Message tag value
         */
        @inline
        tag(): u32 {
            return this.uint32();
        }

        /**
         * Returns byte at offset, alias for getUint8
         * @param byteOffset Offset
         * @returns u8
         */
        @inline
        private u8at(byteOffset: i32): u8 {
            return this.view.getUint8(byteOffset);
        }

        /**
         * Reads and returns varint number (128 + 10 bits max) from a current position.
         * @returns Returns varint
         */
        varint(): u64 {
            let value: u64;

            // u32
            value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u32 remainder or u64 byte
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u64
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value |
                    ((u64(u8(this.u8at(this.pos))) & 127) <<
                        42)) /* 42!!! */ >>>
                0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;
            // u64 remainder
            value =
                (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
            if (u8(this.u8at(this.pos++)) < 128) return value;

            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            return value;
        }

        @inline
        int32(): i32 {
            return i32(this.varint());
        }

        @inline
        int64(): i64 {
            return i32(this.varint());
        }

        @inline
        uint32(): u32 {
            return u32(this.varint());
        }

        @inline
        uint64(): u64 {
            return u64(this.varint());
        }

        @inline
        sint32(): i32 {
            const n: u64 = this.varint();
            return i32((n >>> 1) ^ -(n & 1));
        }

        @inline
        sint64(): i64 {
            const n: u64 = this.varint();
            return i64((n >>> 1) ^ -(n & 1));
        }

        fixed32(): u32 {
            this.pos += 4;
            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)
            return (
                u32(u8(this.u8at(this.pos - 4))) |
                (u32(u8(this.u8at(this.pos - 3))) << 8) |
                (u32(u8(this.u8at(this.pos - 2))) << 16) |
                (u32(u8(this.u8at(this.pos - 1))) << 24)
            );
        }

        @inline
        sfixed32(): i32 {
            return i32(this.fixed32());
        }

        fixed64(): u64 {
            this.pos += 8;
            if (this.pos > this.byteLength) {
                this.throwOutOfRange();
            }

            return (
                u64(u8(this.u8at(this.pos - 8))) |
                (u64(u8(this.u8at(this.pos - 7))) << 8) |
                (u64(u8(this.u8at(this.pos - 6))) << 16) |
                (u64(u8(this.u8at(this.pos - 5))) << 24) |
                (u64(u8(this.u8at(this.pos - 4))) << 32) |
                (u64(u8(this.u8at(this.pos - 3))) << 40) |
                (u64(u8(this.u8at(this.pos - 2))) << 48) |
                (u64(u8(this.u8at(this.pos - 1))) << 56)
            );
        }

        @inline
        sfixed64(): i64 {
            return i64(this.fixed64());
        }

        @inline
        float(): f32 {
            return f32.reinterpret_i32(this.fixed32());
        }

        @inline
        double(): f64 {
            return f64.reinterpret_i64(this.fixed64());
        }

        @inline
        bool(): boolean {
            return this.uint32() > 0;
        }

        /**
         * Reads and returns UTF8 string.
         * @returns String
         */
        string(): string {
            const length = this.uint32();
            if (this.pos + length > this.byteLength) {
                this.throwOutOfRange();
            }

            const p = this.pos + this.view.byteOffset;
            const value = String.UTF8.decode(
                this.view.buffer.slice(p, p + length)
            );
            this.pos += length;
            return value;
        }

        /**
         * Reads and returns bytes array.
         * @returns Array<u8> of bytes
         */
        bytes(): Array<u8> {
            const len = this.uint32();
            if (this.pos + len > this.byteLength) {
                this.throwOutOfRange();
            }

            const a = new Array<u8>(len);
            for (let i: u32 = 0; i < len; i++) {
                a[i] = u8(this.u8at(this.pos++));
            }

            return a;
        }

        /**
         * Skips a message field if it can'be recognized by an object's decode() method
         * @param wireType Current wire type
         */
        skipType(wireType: u32): void {
            switch (wireType) {
                // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length
                case 0:
                    this.varint(); // Just read a varint
                    break;
                // fixed64, sfixed64, double: 8 bytes always
                case 1:
                    this.skip(8);
                    break;
                // length-delimited; length is determined by varint32; skip length bytes;
                case 2:
                    this.skip(this.uint32());
                    break;
                // tart group: skip till the end of the group, then skip group end marker
                case 3:
                    while ((wireType = this.uint32() & 7) !== 4) {
                        this.skipType(wireType);
                    }
                    break;
                // fixed32, sfixed32, float: 4 bytes always
                case 5:
                    this.skip(4);
                    break;

                // Something went beyond our capability to understand
                default:
                    throw new Error(
                        `Invalid wire type ${wireType} at offset ${this.pos}`
                    );
            }
        }

        /**
         * Fast-forwards cursor by length with boundary check
         * @param length Byte length
         */
        skip(length: u32): void {
            if (this.pos + length > this.byteLength) {
                this.throwOutOfRange();
            }
            this.pos += length;
        }

        /**
         * OutOfRange check. Throws an exception if current position exceeds current buffer range
         */
        private throwOutOfRange(): void {
            throw new Error(`Decoder position ${this.pos} is out of range!`);
        }
    }

    /**
     * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses
     * Array<u8>.
     *
     * Useful references:
     *
     * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
     * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
     * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
     */
    export class Encoder {
        public buf: Array<u8>;

        constructor(buf: Array<u8>) {
            this.buf = buf;
        }

        /**
         * Encodes varint at a current position
         * @returns Returns varint
         */
        varint64(value: u64): void {
            let v: u64 = value;

            while (v > 127) {
                this.buf.push(u8((v & 127) | 128));
                v = v >> 7;
            }

            this.buf.push(u8(v));
        }

        @inline
        int32(value: i32): void {
            this.varint64(value);
        }

        @inline
        int64(value: i64): void {
            this.varint64(value);
        }

        @inline
        uint32(value: u32): void {
            this.varint64(value);
        }

        @inline
        uint64(value: u64): void {
            this.varint64(value);
        }

        @inline
        sint32(value: i32): void {
            this.varint64((value << 1) ^ (value >> 31));
        }

        @inline
        sint64(value: i64): void {
            this.varint64((value << 1) ^ (value >> 63));
        }

        @inline
        fixed32(value: u32): void {
            this.buf.push(u8(value & 255));
            this.buf.push(u8((value >> 8) & 255));
            this.buf.push(u8((value >> 16) & 255));
            this.buf.push(u8(value >> 24));
        }

        @inline
        sfixed32(value: i32): void {
            this.fixed32(u32(value));
        }

        @inline
        fixed64(value: u64): void {
            this.buf.push(u8(value & 255));
            this.buf.push(u8((value >> 8) & 255));
            this.buf.push(u8((value >> 16) & 255));
            this.buf.push(u8((value >> 24) & 255));
            this.buf.push(u8((value >> 32) & 255));
            this.buf.push(u8((value >> 40) & 255));
            this.buf.push(u8((value >> 48) & 255));
            this.buf.push(u8(value >> 56));
        }

        @inline
        sfixed64(value: i64): void {
            this.fixed64(u64(value));
        }

        @inline
        float(value: f32): void {
            this.fixed32(u32(i32.reinterpret_f32(value)));
        }

        @inline
        double(value: f64): void {
            this.fixed64(u64(i64.reinterpret_f64(value)));
        }

        @inline
        bool(value: boolean): void {
            this.buf.push(value ? 1 : 0);
        }

        string(value: string): void {
            const utf8string = new DataView(String.UTF8.encode(value));

            for (let i = 0; i < utf8string.byteLength; i++) {
                this.buf.push(utf8string.getUint8(i));
            }
        }

        @inline
        bytes(value: Array<u8>): void {
            for (let i = 0; i < value.length; i++) {
                this.buf.push(value[i]);
            }
        }
    }

    /**
     * Returns byte size required to encode a value of a certain type
     */
    export class Sizer {
        static varint64(value: u64): u32 {
            return value < 128
                ? 1 // 2^7
                : value < 16384
                ? 2 // 2^14
                : value < 2097152
                ? 3 // 2^21
                : value < 268435456
                ? 4 // 2^28
                : value < 34359738368
                ? 5 // 2^35
                : value < 4398046511104
                ? 6 // 2^42
                : value < 562949953421312
                ? 7 // 2^49
                : value < 72057594037927936
                ? 8 // 2^56
                : value < 9223372036854775808
                ? 9 // 2^63
                : 10;
        }

        @inline
        static int32(value: i32): u32 {
            return Sizer.varint64(u64(value));
        }

        @inline
        static int64(value: i64): u32 {
            return Sizer.varint64(u64(value));
        }

        @inline
        static uint32(value: u32): u32 {
            return Sizer.varint64(value);
        }

        @inline
        static uint64(value: u64): u32 {
            return Sizer.varint64(value);
        }

        @inline
        static sint32(value: i32): u32 {
            return Sizer.varint64((value << 1) ^ (value >> 31));
        }

        @inline
        static sint64(value: i64): u32 {
            return Sizer.varint64((value << 1) ^ (value >> 63));
        }

        @inline
        static string(value: string): u32 {
            return value.length;
        }

        @inline
        static bytes(value: Array<u8>): u32 {
            return value.length;
        }
    }
}
/**
 * Allocates the memory segment for a protobuf binary message.
 * @param length Segment length
 * @returns [Segment addr, segment length]
 */
export function __protobuf_alloc(length: i32): u64 {
    const view = new DataView(new ArrayBuffer(length));
    __pin(changetype<usize>(view));
    return (u64(changetype<usize>(view)) << 32) | (changetype<usize>(view.buffer) + view.byteOffset);
}

/**
 * Returns length of the memory segment.
 * @param data DataView instance
 * @returns Length
 */
export function __protobuf_getLength(view: DataView): u32 {
    return view.byteLength;
}

/**
 * Returns address of the memory segment, accessible via WASM memory.
 *
 * @param data DataView instance
 * @returns Memory address
 */
export function __protobuf_getAddr(view: DataView): usize {
    return changetype<usize>(view.buffer) + view.byteOffset;
}

export namespace google {
    export namespace protobuf {
        export class Timestamp {
            public seconds: i64;
            public nanos: i32;

            // Decodes Timestamp from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Timestamp {
                return Timestamp.decode(new DataView(buf));
            }

            // Decodes Timestamp from a DataView
            static decode(view: DataView): Timestamp {
                const decoder = new __proto.Decoder(view);
                const obj = new Timestamp();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            obj.seconds = decoder.int64();
                            break;
                        }
                        case 2: {
                            obj.nanos = decoder.int32();
                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Timestamp

            public size(): u32 {
                let size: u32 = 0;

                size +=
                    this.seconds == 0
                        ? 0
                        : 1 + __proto.Sizer.int64(this.seconds);
                size +=
                    this.nanos == 0 ? 0 : 1 + __proto.Sizer.int32(this.nanos);

                return size;
            }

            // Encodes Timestamp to the DataView
            encodeDataView(): DataView {
                const source = this.encode();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Timestamp to the Array<u8>
            encode(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.seconds != 0) {
                    encoder.uint32(0x8);
                    encoder.int64(this.seconds);
                }
                if (this.nanos != 0) {
                    encoder.uint32(0x10);
                    encoder.int32(this.nanos);
                }

                return buf;
            } // encode Timestamp
        } // Timestamp

        export enum NullValue {
            NULL_VALUE = 0,
        } // NullValue
        export class Struct {
            public fields: Map<string, google.protobuf.Value> = new Map<
                string,
                google.protobuf.Value
            >();

            // Decodes Struct from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Struct {
                return Struct.decode(new DataView(buf));
            }

            // Decodes Struct from a DataView
            static decode(view: DataView): Struct {
                const decoder = new __proto.Decoder(view);
                const obj = new Struct();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            const length = decoder.uint32();
                            __decodeMap_string_google_protobuf_Value(
                                decoder,
                                length,
                                obj.fields
                            );
                            decoder.skip(length);

                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Struct

            public size(): u32 {
                let size: u32 = 0;

                if (this.fields.size > 0) {
                    const keys = this.fields.keys();

                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = this.fields.get(key);
                        const itemSize =
                            __sizeMapEntry_string_google_protobuf_Value(
                                key,
                                value
                            );
                        if (itemSize > 0) {
                            size +=
                                1 + __proto.Sizer.varint64(itemSize) + itemSize;
                        }
                    }
                }

                return size;
            }

            // Encodes Struct to the DataView
            encodeDataView(): DataView {
                const source = this.encode();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Struct to the Array<u8>
            encode(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.fields.size > 0) {
                    const keys = this.fields.keys();
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = this.fields.get(key);
                        const size =
                            __sizeMapEntry_string_google_protobuf_Value(
                                key,
                                value
                            );
                        if (size > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(size);
                            if (key.length > 0) {
                                encoder.uint32(0xa);
                                encoder.uint32(key.length);
                                encoder.string(key);
                            }

                            const messageSize = value.size();

                            if (messageSize > 0) {
                                encoder.uint32(0x12);
                                encoder.uint32(messageSize);
                                value.encode(encoder);
                            }
                        }
                    }
                }

                return buf;
            } // encode Struct
        } // Struct

        export class Value {
            public null_value: u32;
            public number_value: f64;
            public string_value: string = "";
            public bool_value: bool;
            public struct_value: google.protobuf.Struct | null;
            public list_value: google.protobuf.ListValue | null;

            // Decodes Value from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): Value {
                return Value.decode(new DataView(buf));
            }

            // Decodes Value from a DataView
            static decode(view: DataView): Value {
                const decoder = new __proto.Decoder(view);
                const obj = new Value();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            obj.null_value = decoder.uint32();
                            break;
                        }
                        case 2: {
                            obj.number_value = decoder.double();
                            break;
                        }
                        case 3: {
                            obj.string_value = decoder.string();
                            break;
                        }
                        case 4: {
                            obj.bool_value = decoder.bool();
                            break;
                        }
                        case 5: {
                            const length = decoder.uint32();
                            obj.struct_value = google.protobuf.Struct.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                            decoder.skip(length);

                            break;
                        }
                        case 6: {
                            const length = decoder.uint32();
                            obj.list_value = google.protobuf.ListValue.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                            decoder.skip(length);

                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode Value

            public size(): u32 {
                let size: u32 = 0;

                size +=
                    this.null_value == 0
                        ? 0
                        : 1 + __proto.Sizer.uint32(this.null_value);
                size += this.number_value == 0 ? 0 : 1 + 8;
                size +=
                    this.string_value.length > 0
                        ? 1 +
                          __proto.Sizer.varint64(this.string_value.length) +
                          this.string_value.length
                        : 0;
                size += this.bool_value == 0 ? 0 : 1 + 1;

                if (this.struct_value != null) {
                    const f: google.protobuf.Struct = this
                        .struct_value as google.protobuf.Struct;
                    const messageSize = f.size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                if (this.list_value != null) {
                    const f: google.protobuf.ListValue = this
                        .list_value as google.protobuf.ListValue;
                    const messageSize = f.size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                return size;
            }

            // Encodes Value to the DataView
            encodeDataView(): DataView {
                const source = this.encode();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes Value to the Array<u8>
            encode(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                if (this.null_value != 0) {
                    encoder.uint32(0x8);
                    encoder.uint32(this.null_value);
                }
                if (this.number_value != 0) {
                    encoder.uint32(0x11);
                    encoder.double(this.number_value);
                }
                if (this.string_value.length > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.string_value.length);
                    encoder.string(this.string_value);
                }
                if (this.bool_value != 0) {
                    encoder.uint32(0x20);
                    encoder.bool(this.bool_value);
                }

                if (this.struct_value != null) {
                    const f = this.struct_value as google.protobuf.Struct;

                    const messageSize = f.size();

                    if (messageSize > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(messageSize);
                        f.encode(encoder);
                    }
                }

                if (this.list_value != null) {
                    const f = this.list_value as google.protobuf.ListValue;

                    const messageSize = f.size();

                    if (messageSize > 0) {
                        encoder.uint32(0x32);
                        encoder.uint32(messageSize);
                        f.encode(encoder);
                    }
                }

                return buf;
            } // encode Value
        } // Value

        export class ListValue {
            public values: Array<google.protobuf.Value> =
                new Array<google.protobuf.Value>();

            // Decodes ListValue from an ArrayBuffer
            static decodeArrayBuffer(buf: ArrayBuffer): ListValue {
                return ListValue.decode(new DataView(buf));
            }

            // Decodes ListValue from a DataView
            static decode(view: DataView): ListValue {
                const decoder = new __proto.Decoder(view);
                const obj = new ListValue();

                while (!decoder.eof()) {
                    const tag = decoder.tag();
                    const number = tag >>> 3;

                    switch (number) {
                        case 1: {
                            const length = decoder.uint32();
                            obj.values.push(
                                google.protobuf.Value.decode(
                                    new DataView(
                                        decoder.view.buffer,
                                        decoder.pos + decoder.view.byteOffset,
                                        length
                                    )
                                )
                            );
                            decoder.skip(length);

                            break;
                        }

                        default:
                            decoder.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            } // decode ListValue

            public size(): u32 {
                let size: u32 = 0;

                for (let n: i32 = 0; n < this.values.length; n++) {
                    const messageSize = this.values[n].size();

                    if (messageSize > 0) {
                        size +=
                            1 +
                            __proto.Sizer.varint64(messageSize) +
                            messageSize;
                    }
                }

                return size;
            }

            // Encodes ListValue to the DataView
            encodeDataView(): DataView {
                const source = this.encode();
                const view = new DataView(new ArrayBuffer(source.length));
                for (let i: i32 = 0; i < source.length; i++) {
                    view.setUint8(i, source.at(i));
                }
                return view;
            }

            // Encodes ListValue to the Array<u8>
            encode(
                encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
            ): Array<u8> {
                const buf = encoder.buf;

                for (let n: i32 = 0; n < this.values.length; n++) {
                    const messageSize = this.values[n].size();

                    if (messageSize > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(messageSize);
                        this.values[n].encode(encoder);
                    }
                }

                return buf;
            } // encode ListValue
        } // ListValue
    } // protobuf
} // google
export namespace wrappers {
    export class StringValues {
        public Values: Array<string> = new Array<string>();

        // Decodes StringValues from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StringValues {
            return StringValues.decode(new DataView(buf));
        }

        // Decodes StringValues from a DataView
        static decode(view: DataView): StringValues {
            const decoder = new __proto.Decoder(view);
            const obj = new StringValues();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Values.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StringValues

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Values);

            return size;
        }

        // Encodes StringValues to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StringValues to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Values.length > 0) {
                for (let n: i32 = 0; n < this.Values.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Values[n].length);
                    encoder.string(this.Values[n]);
                }
            }

            return buf;
        } // encode StringValues
    } // StringValues

    export class LabelValues {
        public Values: Map<string, wrappers.StringValues> = new Map<
            string,
            wrappers.StringValues
        >();

        // Decodes LabelValues from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LabelValues {
            return LabelValues.decode(new DataView(buf));
        }

        // Decodes LabelValues from a DataView
        static decode(view: DataView): LabelValues {
            const decoder = new __proto.Decoder(view);
            const obj = new LabelValues();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_wrappers_StringValues(
                            decoder,
                            length,
                            obj.Values
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LabelValues

        public size(): u32 {
            let size: u32 = 0;

            if (this.Values.size > 0) {
                const keys = this.Values.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Values.get(key);
                    const itemSize =
                        __sizeMapEntry_string_wrappers_StringValues(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes LabelValues to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LabelValues to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Values.size > 0) {
                const keys = this.Values.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Values.get(key);
                    const size = __sizeMapEntry_string_wrappers_StringValues(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode LabelValues
    } // LabelValues
} // wrappers
export namespace types {
    export enum PrivateKeyType {
        RAW = 0,
        PKCS11 = 1,
    } // PrivateKeyType
    export enum ProxyListenerMode {
        Separate = 0,
        Multiplex = 1,
    } // ProxyListenerMode
    export enum RoutingStrategy {
        UNAMBIGUOUS_MATCH = 0,
        MOST_RECENT = 1,
    } // RoutingStrategy
    export enum UserTokenUsage {
        USER_TOKEN_USAGE_UNSPECIFIED = 0,
        USER_TOKEN_RECOVER_PASSWORD = 1,
        USER_TOKEN_RECOVER_MFA = 2,
    } // UserTokenUsage
    export enum RequestState {
        NONE = 0,
        PENDING = 1,
        APPROVED = 2,
        DENIED = 3,
    } // RequestState
    export class KeepAlive {
        public Name: string = "";
        public Namespace: string = "";
        public LeaseID: i64;
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Type: u32;
        public HostID: string = "";

        // Decodes KeepAlive from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KeepAlive {
            return KeepAlive.decode(new DataView(buf));
        }

        // Decodes KeepAlive from a DataView
        static decode(view: DataView): KeepAlive {
            const decoder = new __proto.Decoder(view);
            const obj = new KeepAlive();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.LeaseID = decoder.int64();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.Type = decoder.uint32();
                        break;
                    }
                    case 10: {
                        obj.HostID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KeepAlive

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;
            size +=
                this.LeaseID == 0 ? 0 : 1 + __proto.Sizer.int64(this.LeaseID);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.Type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Type);
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            return size;
        }

        // Encodes KeepAlive to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KeepAlive to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }
            if (this.LeaseID != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Type != 0) {
                encoder.uint32(0x48);
                encoder.uint32(this.Type);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            return buf;
        } // encode KeepAlive
    } // KeepAlive

    export enum KeepAlive_KeepAliveType {
        UNKNOWN = 0,
        NODE = 1,
        APP = 2,
        DATABASE = 3,
        WINDOWS_DESKTOP = 4,
    } // KeepAlive_KeepAliveType
    export class Metadata {
        public Name: string = "";
        public Namespace: string = "";
        public Description: string = "";
        public Labels: Map<string, string> = new Map<string, string>();
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public ID: i64;

        // Decodes Metadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Metadata {
            return Metadata.decode(new DataView(buf));
        }

        // Decodes Metadata from a DataView
        static decode(view: DataView): Metadata {
            const decoder = new __proto.Decoder(view);
            const obj = new Metadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Description = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Labels);
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.ID = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Metadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;
            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;

            if (this.Labels.size > 0) {
                const keys = this.Labels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Labels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.ID == 0 ? 0 : 1 + __proto.Sizer.int64(this.ID);

            return size;
        }

        // Encodes Metadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Metadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }
            if (this.Description.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }

            if (this.Labels.size > 0) {
                const keys = this.Labels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Labels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ID != 0) {
                encoder.uint32(0x38);
                encoder.int64(this.ID);
            }

            return buf;
        } // encode Metadata
    } // Metadata

    export class Rotation {
        public State: string = "";
        public Phase: string = "";
        public Mode: string = "";
        public CurrentID: string = "";
        public Started: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public GracePeriod: i64;
        public LastRotated: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Schedule: types.RotationSchedule = new types.RotationSchedule();

        // Decodes Rotation from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rotation {
            return Rotation.decode(new DataView(buf));
        }

        // Decodes Rotation from a DataView
        static decode(view: DataView): Rotation {
            const decoder = new __proto.Decoder(view);
            const obj = new Rotation();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.State = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Phase = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Mode = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.CurrentID = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Started = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.GracePeriod = decoder.int64();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.LastRotated = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.Schedule = types.RotationSchedule.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rotation

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.State.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.State.length) +
                      this.State.length
                    : 0;
            size +=
                this.Phase.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Phase.length) +
                      this.Phase.length
                    : 0;
            size +=
                this.Mode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Mode.length) +
                      this.Mode.length
                    : 0;
            size +=
                this.CurrentID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CurrentID.length) +
                      this.CurrentID.length
                    : 0;

            if (this.Started != null) {
                const f: google.protobuf.Timestamp = this
                    .Started as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.GracePeriod == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.GracePeriod);

            if (this.LastRotated != null) {
                const f: google.protobuf.Timestamp = this
                    .LastRotated as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Schedule != null) {
                const f: types.RotationSchedule = this
                    .Schedule as types.RotationSchedule;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Rotation to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rotation to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.State.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.State.length);
                encoder.string(this.State);
            }
            if (this.Phase.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Phase.length);
                encoder.string(this.Phase);
            }
            if (this.Mode.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Mode.length);
                encoder.string(this.Mode);
            }
            if (this.CurrentID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CurrentID.length);
                encoder.string(this.CurrentID);
            }

            if (this.Started != null) {
                const f = this.Started as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.GracePeriod != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.GracePeriod);
            }

            if (this.LastRotated != null) {
                const f = this.LastRotated as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Schedule != null) {
                const f = this.Schedule as types.RotationSchedule;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode Rotation
    } // Rotation

    export class RotationSchedule {
        public UpdateClients: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public UpdateServers: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Standby: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RotationSchedule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RotationSchedule {
            return RotationSchedule.decode(new DataView(buf));
        }

        // Decodes RotationSchedule from a DataView
        static decode(view: DataView): RotationSchedule {
            const decoder = new __proto.Decoder(view);
            const obj = new RotationSchedule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.UpdateClients = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.UpdateServers = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Standby = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RotationSchedule

        public size(): u32 {
            let size: u32 = 0;

            if (this.UpdateClients != null) {
                const f: google.protobuf.Timestamp = this
                    .UpdateClients as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UpdateServers != null) {
                const f: google.protobuf.Timestamp = this
                    .UpdateServers as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Standby != null) {
                const f: google.protobuf.Timestamp = this
                    .Standby as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RotationSchedule to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RotationSchedule to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UpdateClients != null) {
                const f = this.UpdateClients as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UpdateServers != null) {
                const f = this.UpdateServers as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Standby != null) {
                const f = this.Standby as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RotationSchedule
    } // RotationSchedule

    export class ResourceHeader {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();

        // Decodes ResourceHeader from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceHeader {
            return ResourceHeader.decode(new DataView(buf));
        }

        // Decodes ResourceHeader from a DataView
        static decode(view: DataView): ResourceHeader {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceHeader();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceHeader

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ResourceHeader to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceHeader to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ResourceHeader
    } // ResourceHeader

    export class DatabaseServerV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.DatabaseServerSpecV3 =
            new types.DatabaseServerSpecV3();

        // Decodes DatabaseServerV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseServerV3 {
            return DatabaseServerV3.decode(new DataView(buf));
        }

        // Decodes DatabaseServerV3 from a DataView
        static decode(view: DataView): DatabaseServerV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseServerV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.DatabaseServerSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseServerV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.DatabaseServerSpecV3 = this
                    .Spec as types.DatabaseServerSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseServerV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseServerV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.DatabaseServerSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseServerV3
    } // DatabaseServerV3

    export class DatabaseServerSpecV3 {
        public Description: string = "";
        public Protocol: string = "";
        public URI: string = "";
        public CACert: Array<u8> = new Array<u8>();
        public AWS: types.AWS = new types.AWS();
        public Version: string = "";
        public Hostname: string = "";
        public HostID: string = "";
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        public Rotation: types.Rotation = new types.Rotation();
        public GCP: types.GCPCloudSQL = new types.GCPCloudSQL();
        public Database: types.DatabaseV3 = new types.DatabaseV3();

        // Decodes DatabaseServerSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseServerSpecV3 {
            return DatabaseServerSpecV3.decode(new DataView(buf));
        }

        // Decodes DatabaseServerSpecV3 from a DataView
        static decode(view: DataView): DatabaseServerSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseServerSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Description = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Protocol = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.CACert = decoder.bytes();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.GCP = types.GCPCloudSQL.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Database = types.DatabaseV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseServerSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;
            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GCP != null) {
                const f: types.GCPCloudSQL = this.GCP as types.GCPCloudSQL;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: types.DatabaseV3 = this.Database as types.DatabaseV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseServerSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseServerSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Description.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }
            if (this.Protocol.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.CACert.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CACert.length);
                encoder.bytes(this.CACert);
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Version.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x4a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.GCP != null) {
                const f = this.GCP as types.GCPCloudSQL;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as types.DatabaseV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseServerSpecV3
    } // DatabaseServerSpecV3

    export class DatabaseV3List {
        public Databases: Array<types.DatabaseV3> =
            new Array<types.DatabaseV3>();

        // Decodes DatabaseV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseV3List {
            return DatabaseV3List.decode(new DataView(buf));
        }

        // Decodes DatabaseV3List from a DataView
        static decode(view: DataView): DatabaseV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Databases.push(
                            types.DatabaseV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Databases.length; n++) {
                const messageSize = this.Databases[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseV3List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseV3List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Databases.length; n++) {
                const messageSize = this.Databases[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Databases[n].encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseV3List
    } // DatabaseV3List

    export class DatabaseV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.DatabaseSpecV3 = new types.DatabaseSpecV3();
        public Status: types.DatabaseStatusV3 = new types.DatabaseStatusV3();

        // Decodes DatabaseV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseV3 {
            return DatabaseV3.decode(new DataView(buf));
        }

        // Decodes DatabaseV3 from a DataView
        static decode(view: DataView): DatabaseV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.DatabaseSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = types.DatabaseStatusV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.DatabaseSpecV3 = this
                    .Spec as types.DatabaseSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.DatabaseStatusV3 = this
                    .Status as types.DatabaseStatusV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.DatabaseSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.DatabaseStatusV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseV3
    } // DatabaseV3

    export class DatabaseSpecV3 {
        public Protocol: string = "";
        public URI: string = "";
        public CACert: string = "";
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        public AWS: types.AWS = new types.AWS();
        public GCP: types.GCPCloudSQL = new types.GCPCloudSQL();

        // Decodes DatabaseSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSpecV3 {
            return DatabaseSpecV3.decode(new DataView(buf));
        }

        // Decodes DatabaseSpecV3 from a DataView
        static decode(view: DataView): DatabaseSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Protocol = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.CACert = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.GCP = types.GCPCloudSQL.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GCP != null) {
                const f: types.GCPCloudSQL = this.GCP as types.GCPCloudSQL;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Protocol.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.CACert.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.CACert.length);
                encoder.string(this.CACert);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.GCP != null) {
                const f = this.GCP as types.GCPCloudSQL;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseSpecV3
    } // DatabaseSpecV3

    export class DatabaseStatusV3 {
        public CACert: string = "";
        public AWS: types.AWS = new types.AWS();

        // Decodes DatabaseStatusV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseStatusV3 {
            return DatabaseStatusV3.decode(new DataView(buf));
        }

        // Decodes DatabaseStatusV3 from a DataView
        static decode(view: DataView): DatabaseStatusV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseStatusV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.CACert = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.AWS = types.AWS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseStatusV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.CACert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CACert.length) +
                      this.CACert.length
                    : 0;

            if (this.AWS != null) {
                const f: types.AWS = this.AWS as types.AWS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseStatusV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseStatusV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.CACert.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.CACert.length);
                encoder.string(this.CACert);
            }

            if (this.AWS != null) {
                const f = this.AWS as types.AWS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseStatusV3
    } // DatabaseStatusV3

    export class AWS {
        public Region: string = "";
        public Redshift: types.Redshift = new types.Redshift();
        public RDS: types.RDS = new types.RDS();
        public AccountID: string = "";

        // Decodes AWS from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AWS {
            return AWS.decode(new DataView(buf));
        }

        // Decodes AWS from a DataView
        static decode(view: DataView): AWS {
            const decoder = new __proto.Decoder(view);
            const obj = new AWS();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Region = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Redshift = types.Redshift.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.RDS = types.RDS.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.AccountID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AWS

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Region.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Region.length) +
                      this.Region.length
                    : 0;

            if (this.Redshift != null) {
                const f: types.Redshift = this.Redshift as types.Redshift;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RDS != null) {
                const f: types.RDS = this.RDS as types.RDS;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.AccountID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AccountID.length) +
                      this.AccountID.length
                    : 0;

            return size;
        }

        // Encodes AWS to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AWS to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Region.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Region.length);
                encoder.string(this.Region);
            }

            if (this.Redshift != null) {
                const f = this.Redshift as types.Redshift;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RDS != null) {
                const f = this.RDS as types.RDS;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AccountID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AccountID.length);
                encoder.string(this.AccountID);
            }

            return buf;
        } // encode AWS
    } // AWS

    export class Redshift {
        public ClusterID: string = "";

        // Decodes Redshift from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Redshift {
            return Redshift.decode(new DataView(buf));
        }

        // Decodes Redshift from a DataView
        static decode(view: DataView): Redshift {
            const decoder = new __proto.Decoder(view);
            const obj = new Redshift();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Redshift

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;

            return size;
        }

        // Encodes Redshift to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Redshift to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }

            return buf;
        } // encode Redshift
    } // Redshift

    export class RDS {
        public InstanceID: string = "";
        public ClusterID: string = "";
        public ResourceID: string = "";
        public IAMAuth: bool;

        // Decodes RDS from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RDS {
            return RDS.decode(new DataView(buf));
        }

        // Decodes RDS from a DataView
        static decode(view: DataView): RDS {
            const decoder = new __proto.Decoder(view);
            const obj = new RDS();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.InstanceID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ResourceID = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.IAMAuth = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RDS

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.InstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.InstanceID.length) +
                      this.InstanceID.length
                    : 0;
            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;
            size +=
                this.ResourceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceID.length) +
                      this.ResourceID.length
                    : 0;
            size += this.IAMAuth == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes RDS to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RDS to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.InstanceID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.InstanceID.length);
                encoder.string(this.InstanceID);
            }
            if (this.ClusterID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }
            if (this.ResourceID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ResourceID.length);
                encoder.string(this.ResourceID);
            }
            if (this.IAMAuth != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.IAMAuth);
            }

            return buf;
        } // encode RDS
    } // RDS

    export class GCPCloudSQL {
        public ProjectID: string = "";
        public InstanceID: string = "";

        // Decodes GCPCloudSQL from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GCPCloudSQL {
            return GCPCloudSQL.decode(new DataView(buf));
        }

        // Decodes GCPCloudSQL from a DataView
        static decode(view: DataView): GCPCloudSQL {
            const decoder = new __proto.Decoder(view);
            const obj = new GCPCloudSQL();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ProjectID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.InstanceID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GCPCloudSQL

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ProjectID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProjectID.length) +
                      this.ProjectID.length
                    : 0;
            size +=
                this.InstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.InstanceID.length) +
                      this.InstanceID.length
                    : 0;

            return size;
        }

        // Encodes GCPCloudSQL to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GCPCloudSQL to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ProjectID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ProjectID.length);
                encoder.string(this.ProjectID);
            }
            if (this.InstanceID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.InstanceID.length);
                encoder.string(this.InstanceID);
            }

            return buf;
        } // encode GCPCloudSQL
    } // GCPCloudSQL

    export class ServerV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ServerSpecV2 = new types.ServerSpecV2();

        // Decodes ServerV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerV2 {
            return ServerV2.decode(new DataView(buf));
        }

        // Decodes ServerV2 from a DataView
        static decode(view: DataView): ServerV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ServerSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ServerSpecV2 = this.Spec as types.ServerSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ServerSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ServerV2
    } // ServerV2

    export class ServerV2List {
        public Servers: Array<types.ServerV2> = new Array<types.ServerV2>();

        // Decodes ServerV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerV2List {
            return ServerV2List.decode(new DataView(buf));
        }

        // Decodes ServerV2List from a DataView
        static decode(view: DataView): ServerV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Servers.push(
                            types.ServerV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Servers.length; n++) {
                const messageSize = this.Servers[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerV2List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerV2List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Servers.length; n++) {
                const messageSize = this.Servers[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Servers[n].encode(encoder);
                }
            }

            return buf;
        } // encode ServerV2List
    } // ServerV2List

    export class ServerSpecV2 {
        public Addr: string = "";
        public PublicAddr: string = "";
        public Hostname: string = "";
        public CmdLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        public Rotation: types.Rotation = new types.Rotation();
        public UseTunnel: bool;
        public Version: string = "";
        public Apps: Array<types.App> = new Array<types.App>();
        public KubernetesClusters: Array<types.KubernetesCluster> =
            new Array<types.KubernetesCluster>();

        // Decodes ServerSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerSpecV2 {
            return ServerSpecV2.decode(new DataView(buf));
        }

        // Decodes ServerSpecV2 from a DataView
        static decode(view: DataView): ServerSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.CmdLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.UseTunnel = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Apps.push(
                            types.App.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.KubernetesClusters.push(
                            types.KubernetesCluster.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;

            if (this.CmdLabels.size > 0) {
                const keys = this.CmdLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.CmdLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.UseTunnel == 0 ? 0 : 1 + 1;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {
                const messageSize = this.KubernetesClusters[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ServerSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }

            if (this.CmdLabels.size > 0) {
                const keys = this.CmdLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.CmdLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UseTunnel != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.UseTunnel);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    this.Apps[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {
                const messageSize = this.KubernetesClusters[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.KubernetesClusters[n].encode(encoder);
                }
            }

            return buf;
        } // encode ServerSpecV2
    } // ServerSpecV2

    export class AppServerV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.AppServerSpecV3 = new types.AppServerSpecV3();

        // Decodes AppServerV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppServerV3 {
            return AppServerV3.decode(new DataView(buf));
        }

        // Decodes AppServerV3 from a DataView
        static decode(view: DataView): AppServerV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppServerV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AppServerSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppServerV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AppServerSpecV3 = this
                    .Spec as types.AppServerSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppServerV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppServerV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AppServerSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppServerV3
    } // AppServerV3

    export class AppServerSpecV3 {
        public Version: string = "";
        public Hostname: string = "";
        public HostID: string = "";
        public Rotation: types.Rotation = new types.Rotation();
        public App: types.AppV3 = new types.AppV3();

        // Decodes AppServerSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppServerSpecV3 {
            return AppServerSpecV3.decode(new DataView(buf));
        }

        // Decodes AppServerSpecV3 from a DataView
        static decode(view: DataView): AppServerSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppServerSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Hostname = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.App = types.AppV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppServerSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;
            size +=
                this.Hostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Hostname.length) +
                      this.Hostname.length
                    : 0;
            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: types.AppV3 = this.App as types.AppV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppServerSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppServerSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Version.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }
            if (this.Hostname.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Hostname.length);
                encoder.string(this.Hostname);
            }
            if (this.HostID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as types.AppV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppServerSpecV3
    } // AppServerSpecV3

    export class AppV3List {
        public Apps: Array<types.AppV3> = new Array<types.AppV3>();

        // Decodes AppV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppV3List {
            return AppV3List.decode(new DataView(buf));
        }

        // Decodes AppV3List from a DataView
        static decode(view: DataView): AppV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new AppV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Apps.push(
                            types.AppV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppV3List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppV3List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Apps.length; n++) {
                const messageSize = this.Apps[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Apps[n].encode(encoder);
                }
            }

            return buf;
        } // encode AppV3List
    } // AppV3List

    export class AppV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.AppSpecV3 = new types.AppSpecV3();

        // Decodes AppV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppV3 {
            return AppV3.decode(new DataView(buf));
        }

        // Decodes AppV3 from a DataView
        static decode(view: DataView): AppV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AppSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AppSpecV3 = this.Spec as types.AppSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AppSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppV3
    } // AppV3

    export class AppSpecV3 {
        public URI: string = "";
        public PublicAddr: string = "";
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        public InsecureSkipVerify: bool;
        public Rewrite: types.Rewrite = new types.Rewrite();

        // Decodes AppSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSpecV3 {
            return AppSpecV3.decode(new DataView(buf));
        }

        // Decodes AppSpecV3 from a DataView
        static decode(view: DataView): AppSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.InsecureSkipVerify = decoder.bool();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Rewrite = types.Rewrite.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;

            if (this.Rewrite != null) {
                const f: types.Rewrite = this.Rewrite as types.Rewrite;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.URI.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            if (this.InsecureSkipVerify != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.InsecureSkipVerify);
            }

            if (this.Rewrite != null) {
                const f = this.Rewrite as types.Rewrite;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppSpecV3
    } // AppSpecV3

    export class App {
        public Name: string = "";
        public URI: string = "";
        public PublicAddr: string = "";
        public StaticLabels: Map<string, string> = new Map<string, string>();
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();
        public InsecureSkipVerify: bool;
        public Rewrite: types.Rewrite = new types.Rewrite();
        public Description: string = "";

        // Decodes App from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): App {
            return App.decode(new DataView(buf));
        }

        // Decodes App from a DataView
        static decode(view: DataView): App {
            const decoder = new __proto.Decoder(view);
            const obj = new App();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URI = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.StaticLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.InsecureSkipVerify = decoder.bool();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Rewrite = types.Rewrite.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        obj.Description = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode App

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.URI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URI.length) +
                      this.URI.length
                    : 0;
            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;

            if (this.Rewrite != null) {
                const f: types.Rewrite = this.Rewrite as types.Rewrite;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Description.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Description.length) +
                      this.Description.length
                    : 0;

            return size;
        }

        // Encodes App to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes App to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.URI.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URI.length);
                encoder.string(this.URI);
            }
            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            if (this.InsecureSkipVerify != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.InsecureSkipVerify);
            }

            if (this.Rewrite != null) {
                const f = this.Rewrite as types.Rewrite;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Description.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Description.length);
                encoder.string(this.Description);
            }

            return buf;
        } // encode App
    } // App

    export class Rewrite {
        public Redirect: Array<string> = new Array<string>();
        public Headers: Array<types.Header> = new Array<types.Header>();

        // Decodes Rewrite from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rewrite {
            return Rewrite.decode(new DataView(buf));
        }

        // Decodes Rewrite from a DataView
        static decode(view: DataView): Rewrite {
            const decoder = new __proto.Decoder(view);
            const obj = new Rewrite();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Redirect.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Headers.push(
                            types.Header.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rewrite

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Redirect);

            for (let n: i32 = 0; n < this.Headers.length; n++) {
                const messageSize = this.Headers[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Rewrite to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rewrite to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Redirect.length > 0) {
                for (let n: i32 = 0; n < this.Redirect.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Redirect[n].length);
                    encoder.string(this.Redirect[n]);
                }
            }

            for (let n: i32 = 0; n < this.Headers.length; n++) {
                const messageSize = this.Headers[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.Headers[n].encode(encoder);
                }
            }

            return buf;
        } // encode Rewrite
    } // Rewrite

    export class Header {
        public Name: string = "";
        public Value: string = "";

        // Decodes Header from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Header {
            return Header.decode(new DataView(buf));
        }

        // Decodes Header from a DataView
        static decode(view: DataView): Header {
            const decoder = new __proto.Decoder(view);
            const obj = new Header();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Header

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            return size;
        }

        // Encodes Header to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Header to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            return buf;
        } // encode Header
    } // Header

    export class CommandLabelV2 {
        public Period: i64;
        public Command: Array<string> = new Array<string>();
        public Result: string = "";

        // Decodes CommandLabelV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CommandLabelV2 {
            return CommandLabelV2.decode(new DataView(buf));
        }

        // Decodes CommandLabelV2 from a DataView
        static decode(view: DataView): CommandLabelV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CommandLabelV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Period = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.Command.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Result = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CommandLabelV2

        public size(): u32 {
            let size: u32 = 0;

            size += this.Period == 0 ? 0 : 1 + __proto.Sizer.int64(this.Period);

            size += __size_string_repeated(this.Command);

            size +=
                this.Result.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Result.length) +
                      this.Result.length
                    : 0;

            return size;
        }

        // Encodes CommandLabelV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CommandLabelV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Period != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.Period);
            }

            if (this.Command.length > 0) {
                for (let n: i32 = 0; n < this.Command.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Command[n].length);
                    encoder.string(this.Command[n]);
                }
            }

            if (this.Result.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Result.length);
                encoder.string(this.Result);
            }

            return buf;
        } // encode CommandLabelV2
    } // CommandLabelV2

    export class SSHKeyPair {
        public PublicKey: Array<u8> = new Array<u8>();
        public PrivateKey: Array<u8> = new Array<u8>();
        public PrivateKeyType: u32;

        // Decodes SSHKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SSHKeyPair {
            return SSHKeyPair.decode(new DataView(buf));
        }

        // Decodes SSHKeyPair from a DataView
        static decode(view: DataView): SSHKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new SSHKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PublicKey = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.PrivateKey = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PrivateKeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SSHKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PublicKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicKey.length) +
                      this.PublicKey.length
                    : 0;
            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.PrivateKeyType == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.PrivateKeyType);

            return size;
        }

        // Encodes SSHKeyPair to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SSHKeyPair to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PublicKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PublicKey.length);
                encoder.bytes(this.PublicKey);
            }
            if (this.PrivateKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PrivateKey.length);
                encoder.bytes(this.PrivateKey);
            }
            if (this.PrivateKeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.PrivateKeyType);
            }

            return buf;
        } // encode SSHKeyPair
    } // SSHKeyPair

    export class TLSKeyPair {
        public Cert: Array<u8> = new Array<u8>();
        public Key: Array<u8> = new Array<u8>();
        public KeyType: u32;

        // Decodes TLSKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TLSKeyPair {
            return TLSKeyPair.decode(new DataView(buf));
        }

        // Decodes TLSKeyPair from a DataView
        static decode(view: DataView): TLSKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new TLSKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Cert = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.Key = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.KeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TLSKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;
            size +=
                this.Key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Key.length) +
                      this.Key.length
                    : 0;
            size +=
                this.KeyType == 0 ? 0 : 1 + __proto.Sizer.uint32(this.KeyType);

            return size;
        }

        // Encodes TLSKeyPair to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TLSKeyPair to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Cert.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Cert.length);
                encoder.bytes(this.Cert);
            }
            if (this.Key.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Key.length);
                encoder.bytes(this.Key);
            }
            if (this.KeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.KeyType);
            }

            return buf;
        } // encode TLSKeyPair
    } // TLSKeyPair

    export class JWTKeyPair {
        public PublicKey: Array<u8> = new Array<u8>();
        public PrivateKey: Array<u8> = new Array<u8>();
        public PrivateKeyType: u32;

        // Decodes JWTKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): JWTKeyPair {
            return JWTKeyPair.decode(new DataView(buf));
        }

        // Decodes JWTKeyPair from a DataView
        static decode(view: DataView): JWTKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new JWTKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PublicKey = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.PrivateKey = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PrivateKeyType = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode JWTKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PublicKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicKey.length) +
                      this.PublicKey.length
                    : 0;
            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.PrivateKeyType == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.PrivateKeyType);

            return size;
        }

        // Encodes JWTKeyPair to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes JWTKeyPair to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PublicKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PublicKey.length);
                encoder.bytes(this.PublicKey);
            }
            if (this.PrivateKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.PrivateKey.length);
                encoder.bytes(this.PrivateKey);
            }
            if (this.PrivateKeyType != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.PrivateKeyType);
            }

            return buf;
        } // encode JWTKeyPair
    } // JWTKeyPair

    export class CertAuthorityV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.CertAuthoritySpecV2 =
            new types.CertAuthoritySpecV2();

        // Decodes CertAuthorityV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CertAuthorityV2 {
            return CertAuthorityV2.decode(new DataView(buf));
        }

        // Decodes CertAuthorityV2 from a DataView
        static decode(view: DataView): CertAuthorityV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CertAuthorityV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.CertAuthoritySpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CertAuthorityV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.CertAuthoritySpecV2 = this
                    .Spec as types.CertAuthoritySpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CertAuthorityV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CertAuthorityV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.CertAuthoritySpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode CertAuthorityV2
    } // CertAuthorityV2

    export class CertAuthoritySpecV2 {
        public Type: string = "";
        public ClusterName: string = "";
        public CheckingKeys: Array<Array<u8>> = new Array<Array<u8>>();
        public SigningKeys: Array<Array<u8>> = new Array<Array<u8>>();
        public Roles: Array<string> = new Array<string>();
        public RoleMap: Array<types.RoleMapping> =
            new Array<types.RoleMapping>();
        public TLSKeyPairs: Array<types.TLSKeyPair> =
            new Array<types.TLSKeyPair>();
        public Rotation: types.Rotation = new types.Rotation();
        public SigningAlg: u32;
        public JWTKeyPairs: Array<types.JWTKeyPair> =
            new Array<types.JWTKeyPair>();
        public ActiveKeys: types.CAKeySet = new types.CAKeySet();
        public AdditionalTrustedKeys: types.CAKeySet = new types.CAKeySet();

        // Decodes CertAuthoritySpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CertAuthoritySpecV2 {
            return CertAuthoritySpecV2.decode(new DataView(buf));
        }

        // Decodes CertAuthoritySpecV2 from a DataView
        static decode(view: DataView): CertAuthoritySpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new CertAuthoritySpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.CheckingKeys.push(decoder.bytes());
                        break;
                    }
                    case 4: {
                        obj.SigningKeys.push(decoder.bytes());
                        break;
                    }
                    case 5: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.RoleMap.push(
                            types.RoleMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.TLSKeyPairs.push(
                            types.TLSKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.Rotation = types.Rotation.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.SigningAlg = decoder.uint32();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.JWTKeyPairs.push(
                            types.JWTKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.ActiveKeys = types.CAKeySet.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.AdditionalTrustedKeys = types.CAKeySet.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CertAuthoritySpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            size += __size_bytes_repeated(this.CheckingKeys);

            size += __size_bytes_repeated(this.SigningKeys);

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {
                const messageSize = this.TLSKeyPairs[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Rotation != null) {
                const f: types.Rotation = this.Rotation as types.Rotation;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SigningAlg == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.SigningAlg);

            for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {
                const messageSize = this.JWTKeyPairs[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ActiveKeys != null) {
                const f: types.CAKeySet = this.ActiveKeys as types.CAKeySet;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AdditionalTrustedKeys != null) {
                const f: types.CAKeySet = this
                    .AdditionalTrustedKeys as types.CAKeySet;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CertAuthoritySpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CertAuthoritySpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ClusterName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            if (this.CheckingKeys.length > 0) {
                for (let n: i32 = 0; n < this.CheckingKeys.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.CheckingKeys[n].length);
                    encoder.bytes(this.CheckingKeys[n]);
                }
            }

            if (this.SigningKeys.length > 0) {
                for (let n: i32 = 0; n < this.SigningKeys.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.SigningKeys[n].length);
                    encoder.bytes(this.SigningKeys[n]);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    this.RoleMap[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {
                const messageSize = this.TLSKeyPairs[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    this.TLSKeyPairs[n].encode(encoder);
                }
            }

            if (this.Rotation != null) {
                const f = this.Rotation as types.Rotation;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SigningAlg != 0) {
                encoder.uint32(0x48);
                encoder.uint32(this.SigningAlg);
            }

            for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {
                const messageSize = this.JWTKeyPairs[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.JWTKeyPairs[n].encode(encoder);
                }
            }

            if (this.ActiveKeys != null) {
                const f = this.ActiveKeys as types.CAKeySet;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AdditionalTrustedKeys != null) {
                const f = this.AdditionalTrustedKeys as types.CAKeySet;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode CertAuthoritySpecV2
    } // CertAuthoritySpecV2

    export enum CertAuthoritySpecV2_SigningAlgType {
        UNKNOWN = 0,
        RSA_SHA1 = 1,
        RSA_SHA2_256 = 2,
        RSA_SHA2_512 = 3,
    } // CertAuthoritySpecV2_SigningAlgType
    export class CAKeySet {
        public SSH: Array<types.SSHKeyPair> = new Array<types.SSHKeyPair>();
        public TLS: Array<types.TLSKeyPair> = new Array<types.TLSKeyPair>();
        public JWT: Array<types.JWTKeyPair> = new Array<types.JWTKeyPair>();

        // Decodes CAKeySet from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CAKeySet {
            return CAKeySet.decode(new DataView(buf));
        }

        // Decodes CAKeySet from a DataView
        static decode(view: DataView): CAKeySet {
            const decoder = new __proto.Decoder(view);
            const obj = new CAKeySet();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.SSH.push(
                            types.SSHKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.TLS.push(
                            types.TLSKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.JWT.push(
                            types.JWTKeyPair.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CAKeySet

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.SSH.length; n++) {
                const messageSize = this.SSH[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.TLS.length; n++) {
                const messageSize = this.TLS[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.JWT.length; n++) {
                const messageSize = this.JWT[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CAKeySet to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CAKeySet to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.SSH.length; n++) {
                const messageSize = this.SSH[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.SSH[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.TLS.length; n++) {
                const messageSize = this.TLS[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.TLS[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.JWT.length; n++) {
                const messageSize = this.JWT[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    this.JWT[n].encode(encoder);
                }
            }

            return buf;
        } // encode CAKeySet
    } // CAKeySet

    export class RoleMapping {
        public Remote: string = "";
        public Local: Array<string> = new Array<string>();

        // Decodes RoleMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleMapping {
            return RoleMapping.decode(new DataView(buf));
        }

        // Decodes RoleMapping from a DataView
        static decode(view: DataView): RoleMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Remote = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Local.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Remote.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Remote.length) +
                      this.Remote.length
                    : 0;

            size += __size_string_repeated(this.Local);

            return size;
        }

        // Encodes RoleMapping to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleMapping to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Remote.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Remote.length);
                encoder.string(this.Remote);
            }

            if (this.Local.length > 0) {
                for (let n: i32 = 0; n < this.Local.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Local[n].length);
                    encoder.string(this.Local[n]);
                }
            }

            return buf;
        } // encode RoleMapping
    } // RoleMapping

    export class ProvisionTokenV1 {
        public Roles: Array<string> = new Array<string>();
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Token: string = "";

        // Decodes ProvisionTokenV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV1 {
            return ProvisionTokenV1.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV1 from a DataView
        static decode(view: DataView): ProvisionTokenV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV1

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes ProvisionTokenV1 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV1 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Token.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode ProvisionTokenV1
    } // ProvisionTokenV1

    export class ProvisionTokenV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ProvisionTokenSpecV2 =
            new types.ProvisionTokenSpecV2();

        // Decodes ProvisionTokenV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV2 {
            return ProvisionTokenV2.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV2 from a DataView
        static decode(view: DataView): ProvisionTokenV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ProvisionTokenSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ProvisionTokenSpecV2 = this
                    .Spec as types.ProvisionTokenSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ProvisionTokenV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ProvisionTokenSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ProvisionTokenV2
    } // ProvisionTokenV2

    export class ProvisionTokenV2List {
        public ProvisionTokens: Array<types.ProvisionTokenV2> =
            new Array<types.ProvisionTokenV2>();

        // Decodes ProvisionTokenV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenV2List {
            return ProvisionTokenV2List.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenV2List from a DataView
        static decode(view: DataView): ProvisionTokenV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.ProvisionTokens.push(
                            types.ProvisionTokenV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {
                const messageSize = this.ProvisionTokens[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ProvisionTokenV2List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenV2List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {
                const messageSize = this.ProvisionTokens[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.ProvisionTokens[n].encode(encoder);
                }
            }

            return buf;
        } // encode ProvisionTokenV2List
    } // ProvisionTokenV2List

    export class TokenRule {
        public AWSAccount: string = "";
        public AWSRegions: Array<string> = new Array<string>();
        public AWSRole: string = "";

        // Decodes TokenRule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TokenRule {
            return TokenRule.decode(new DataView(buf));
        }

        // Decodes TokenRule from a DataView
        static decode(view: DataView): TokenRule {
            const decoder = new __proto.Decoder(view);
            const obj = new TokenRule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AWSAccount = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AWSRegions.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.AWSRole = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TokenRule

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AWSAccount.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSAccount.length) +
                      this.AWSAccount.length
                    : 0;

            size += __size_string_repeated(this.AWSRegions);

            size +=
                this.AWSRole.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSRole.length) +
                      this.AWSRole.length
                    : 0;

            return size;
        }

        // Encodes TokenRule to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TokenRule to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AWSAccount.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AWSAccount.length);
                encoder.string(this.AWSAccount);
            }

            if (this.AWSRegions.length > 0) {
                for (let n: i32 = 0; n < this.AWSRegions.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.AWSRegions[n].length);
                    encoder.string(this.AWSRegions[n]);
                }
            }

            if (this.AWSRole.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.AWSRole.length);
                encoder.string(this.AWSRole);
            }

            return buf;
        } // encode TokenRule
    } // TokenRule

    export class ProvisionTokenSpecV2 {
        public Roles: Array<string> = new Array<string>();
        public allow: Array<types.TokenRule> = new Array<types.TokenRule>();
        public AWSIIDTTL: i64;

        // Decodes ProvisionTokenSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ProvisionTokenSpecV2 {
            return ProvisionTokenSpecV2.decode(new DataView(buf));
        }

        // Decodes ProvisionTokenSpecV2 from a DataView
        static decode(view: DataView): ProvisionTokenSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ProvisionTokenSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.allow.push(
                            types.TokenRule.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.AWSIIDTTL = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ProvisionTokenSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.allow.length; n++) {
                const messageSize = this.allow[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.AWSIIDTTL == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.AWSIIDTTL);

            return size;
        }

        // Encodes ProvisionTokenSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ProvisionTokenSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.allow.length; n++) {
                const messageSize = this.allow[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.allow[n].encode(encoder);
                }
            }

            if (this.AWSIIDTTL != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.AWSIIDTTL);
            }

            return buf;
        } // encode ProvisionTokenSpecV2
    } // ProvisionTokenSpecV2

    export class StaticTokensV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.StaticTokensSpecV2 = new types.StaticTokensSpecV2();

        // Decodes StaticTokensV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StaticTokensV2 {
            return StaticTokensV2.decode(new DataView(buf));
        }

        // Decodes StaticTokensV2 from a DataView
        static decode(view: DataView): StaticTokensV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new StaticTokensV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.StaticTokensSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StaticTokensV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.StaticTokensSpecV2 = this
                    .Spec as types.StaticTokensSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StaticTokensV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StaticTokensV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.StaticTokensSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode StaticTokensV2
    } // StaticTokensV2

    export class StaticTokensSpecV2 {
        public StaticTokens: Array<types.ProvisionTokenV1> =
            new Array<types.ProvisionTokenV1>();

        // Decodes StaticTokensSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StaticTokensSpecV2 {
            return StaticTokensSpecV2.decode(new DataView(buf));
        }

        // Decodes StaticTokensSpecV2 from a DataView
        static decode(view: DataView): StaticTokensSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new StaticTokensSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.StaticTokens.push(
                            types.ProvisionTokenV1.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StaticTokensSpecV2

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.StaticTokens.length; n++) {
                const messageSize = this.StaticTokens[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StaticTokensSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StaticTokensSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.StaticTokens.length; n++) {
                const messageSize = this.StaticTokens[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.StaticTokens[n].encode(encoder);
                }
            }

            return buf;
        } // encode StaticTokensSpecV2
    } // StaticTokensSpecV2

    export class ClusterNameV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ClusterNameSpecV2 = new types.ClusterNameSpecV2();

        // Decodes ClusterNameV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNameV2 {
            return ClusterNameV2.decode(new DataView(buf));
        }

        // Decodes ClusterNameV2 from a DataView
        static decode(view: DataView): ClusterNameV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNameV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterNameSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNameV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterNameSpecV2 = this
                    .Spec as types.ClusterNameSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterNameV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNameV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterNameSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ClusterNameV2
    } // ClusterNameV2

    export class ClusterNameSpecV2 {
        public ClusterName: string = "";
        public ClusterID: string = "";

        // Decodes ClusterNameSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNameSpecV2 {
            return ClusterNameSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterNameSpecV2 from a DataView
        static decode(view: DataView): ClusterNameSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNameSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClusterID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNameSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;
            size +=
                this.ClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterID.length) +
                      this.ClusterID.length
                    : 0;

            return size;
        }

        // Encodes ClusterNameSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNameSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }
            if (this.ClusterID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClusterID.length);
                encoder.string(this.ClusterID);
            }

            return buf;
        } // encode ClusterNameSpecV2
    } // ClusterNameSpecV2

    export class ClusterAuditConfigV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ClusterAuditConfigSpecV2 =
            new types.ClusterAuditConfigSpecV2();

        // Decodes ClusterAuditConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterAuditConfigV2 {
            return ClusterAuditConfigV2.decode(new DataView(buf));
        }

        // Decodes ClusterAuditConfigV2 from a DataView
        static decode(view: DataView): ClusterAuditConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterAuditConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterAuditConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterAuditConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterAuditConfigSpecV2 = this
                    .Spec as types.ClusterAuditConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterAuditConfigV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterAuditConfigV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterAuditConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ClusterAuditConfigV2
    } // ClusterAuditConfigV2

    export class ClusterAuditConfigSpecV2 {
        public Type: string = "";
        public Region: string = "";
        public AuditSessionsURI: string = "";
        public AuditEventsURI: wrappers.StringValues =
            new wrappers.StringValues();
        public EnableContinuousBackups: bool;
        public EnableAutoScaling: bool;
        public ReadMaxCapacity: i64;
        public ReadMinCapacity: i64;
        public ReadTargetValue: f64;
        public WriteMaxCapacity: i64;
        public WriteMinCapacity: i64;
        public WriteTargetValue: f64;

        // Decodes ClusterAuditConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterAuditConfigSpecV2 {
            return ClusterAuditConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterAuditConfigSpecV2 from a DataView
        static decode(view: DataView): ClusterAuditConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterAuditConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Region = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.AuditSessionsURI = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.AuditEventsURI = wrappers.StringValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.EnableContinuousBackups = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.EnableAutoScaling = decoder.bool();
                        break;
                    }
                    case 8: {
                        obj.ReadMaxCapacity = decoder.int64();
                        break;
                    }
                    case 9: {
                        obj.ReadMinCapacity = decoder.int64();
                        break;
                    }
                    case 10: {
                        obj.ReadTargetValue = decoder.double();
                        break;
                    }
                    case 11: {
                        obj.WriteMaxCapacity = decoder.int64();
                        break;
                    }
                    case 12: {
                        obj.WriteMinCapacity = decoder.int64();
                        break;
                    }
                    case 13: {
                        obj.WriteTargetValue = decoder.double();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterAuditConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.Region.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Region.length) +
                      this.Region.length
                    : 0;
            size +=
                this.AuditSessionsURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AuditSessionsURI.length) +
                      this.AuditSessionsURI.length
                    : 0;

            if (this.AuditEventsURI != null) {
                const f: wrappers.StringValues = this
                    .AuditEventsURI as wrappers.StringValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.EnableContinuousBackups == 0 ? 0 : 1 + 1;
            size += this.EnableAutoScaling == 0 ? 0 : 1 + 1;
            size +=
                this.ReadMaxCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ReadMaxCapacity);
            size +=
                this.ReadMinCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ReadMinCapacity);
            size += this.ReadTargetValue == 0 ? 0 : 1 + 8;
            size +=
                this.WriteMaxCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WriteMaxCapacity);
            size +=
                this.WriteMinCapacity == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WriteMinCapacity);
            size += this.WriteTargetValue == 0 ? 0 : 1 + 8;

            return size;
        }

        // Encodes ClusterAuditConfigSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterAuditConfigSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.Region.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Region.length);
                encoder.string(this.Region);
            }
            if (this.AuditSessionsURI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.AuditSessionsURI.length);
                encoder.string(this.AuditSessionsURI);
            }

            if (this.AuditEventsURI != null) {
                const f = this.AuditEventsURI as wrappers.StringValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.EnableContinuousBackups != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.EnableContinuousBackups);
            }
            if (this.EnableAutoScaling != 0) {
                encoder.uint32(0x38);
                encoder.bool(this.EnableAutoScaling);
            }
            if (this.ReadMaxCapacity != 0) {
                encoder.uint32(0x40);
                encoder.int64(this.ReadMaxCapacity);
            }
            if (this.ReadMinCapacity != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.ReadMinCapacity);
            }
            if (this.ReadTargetValue != 0) {
                encoder.uint32(0x51);
                encoder.double(this.ReadTargetValue);
            }
            if (this.WriteMaxCapacity != 0) {
                encoder.uint32(0x58);
                encoder.int64(this.WriteMaxCapacity);
            }
            if (this.WriteMinCapacity != 0) {
                encoder.uint32(0x60);
                encoder.int64(this.WriteMinCapacity);
            }
            if (this.WriteTargetValue != 0) {
                encoder.uint32(0x69);
                encoder.double(this.WriteTargetValue);
            }

            return buf;
        } // encode ClusterAuditConfigSpecV2
    } // ClusterAuditConfigSpecV2

    export class ClusterNetworkingConfigV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ClusterNetworkingConfigSpecV2 =
            new types.ClusterNetworkingConfigSpecV2();

        // Decodes ClusterNetworkingConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClusterNetworkingConfigV2 {
            return ClusterNetworkingConfigV2.decode(new DataView(buf));
        }

        // Decodes ClusterNetworkingConfigV2 from a DataView
        static decode(view: DataView): ClusterNetworkingConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNetworkingConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ClusterNetworkingConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNetworkingConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ClusterNetworkingConfigSpecV2 = this
                    .Spec as types.ClusterNetworkingConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ClusterNetworkingConfigV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNetworkingConfigV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ClusterNetworkingConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ClusterNetworkingConfigV2
    } // ClusterNetworkingConfigV2

    export class ClusterNetworkingConfigSpecV2 {
        public ClientIdleTimeout: i64;
        public KeepAliveInterval: i64;
        public KeepAliveCountMax: i64;
        public SessionControlTimeout: i64;
        public ClientIdleTimeoutMessage: string = "";
        public WebIdleTimeout: i64;
        public ProxyListenerMode: u32;
        public RoutingStrategy: u32;

        // Decodes ClusterNetworkingConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ClusterNetworkingConfigSpecV2 {
            return ClusterNetworkingConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes ClusterNetworkingConfigSpecV2 from a DataView
        static decode(view: DataView): ClusterNetworkingConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ClusterNetworkingConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClientIdleTimeout = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.KeepAliveInterval = decoder.int64();
                        break;
                    }
                    case 3: {
                        obj.KeepAliveCountMax = decoder.int64();
                        break;
                    }
                    case 4: {
                        obj.SessionControlTimeout = decoder.int64();
                        break;
                    }
                    case 5: {
                        obj.ClientIdleTimeoutMessage = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.WebIdleTimeout = decoder.int64();
                        break;
                    }
                    case 7: {
                        obj.ProxyListenerMode = decoder.uint32();
                        break;
                    }
                    case 8: {
                        obj.RoutingStrategy = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClusterNetworkingConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClientIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);
            size +=
                this.KeepAliveInterval == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.KeepAliveInterval);
            size +=
                this.KeepAliveCountMax == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.KeepAliveCountMax);
            size +=
                this.SessionControlTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.SessionControlTimeout);
            size +=
                this.ClientIdleTimeoutMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.ClientIdleTimeoutMessage.length
                      ) +
                      this.ClientIdleTimeoutMessage.length
                    : 0;
            size +=
                this.WebIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.WebIdleTimeout);
            size +=
                this.ProxyListenerMode == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.ProxyListenerMode);
            size +=
                this.RoutingStrategy == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.RoutingStrategy);

            return size;
        }

        // Encodes ClusterNetworkingConfigSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClusterNetworkingConfigSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClientIdleTimeout != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.ClientIdleTimeout);
            }
            if (this.KeepAliveInterval != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.KeepAliveInterval);
            }
            if (this.KeepAliveCountMax != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.KeepAliveCountMax);
            }
            if (this.SessionControlTimeout != 0) {
                encoder.uint32(0x20);
                encoder.int64(this.SessionControlTimeout);
            }
            if (this.ClientIdleTimeoutMessage.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ClientIdleTimeoutMessage.length);
                encoder.string(this.ClientIdleTimeoutMessage);
            }
            if (this.WebIdleTimeout != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.WebIdleTimeout);
            }
            if (this.ProxyListenerMode != 0) {
                encoder.uint32(0x38);
                encoder.uint32(this.ProxyListenerMode);
            }
            if (this.RoutingStrategy != 0) {
                encoder.uint32(0x40);
                encoder.uint32(this.RoutingStrategy);
            }

            return buf;
        } // encode ClusterNetworkingConfigSpecV2
    } // ClusterNetworkingConfigSpecV2

    export class SessionRecordingConfigV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.SessionRecordingConfigSpecV2 =
            new types.SessionRecordingConfigSpecV2();

        // Decodes SessionRecordingConfigV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionRecordingConfigV2 {
            return SessionRecordingConfigV2.decode(new DataView(buf));
        }

        // Decodes SessionRecordingConfigV2 from a DataView
        static decode(view: DataView): SessionRecordingConfigV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionRecordingConfigV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SessionRecordingConfigSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionRecordingConfigV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SessionRecordingConfigSpecV2 = this
                    .Spec as types.SessionRecordingConfigSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionRecordingConfigV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionRecordingConfigV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SessionRecordingConfigSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SessionRecordingConfigV2
    } // SessionRecordingConfigV2

    export class SessionRecordingConfigSpecV2 {
        public Mode: string = "";
        public ProxyChecksHostKeys: types.BoolValue = new types.BoolValue();

        // Decodes SessionRecordingConfigSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): SessionRecordingConfigSpecV2 {
            return SessionRecordingConfigSpecV2.decode(new DataView(buf));
        }

        // Decodes SessionRecordingConfigSpecV2 from a DataView
        static decode(view: DataView): SessionRecordingConfigSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionRecordingConfigSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Mode = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ProxyChecksHostKeys = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionRecordingConfigSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Mode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Mode.length) +
                      this.Mode.length
                    : 0;

            if (this.ProxyChecksHostKeys != null) {
                const f: types.BoolValue = this
                    .ProxyChecksHostKeys as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionRecordingConfigSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionRecordingConfigSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Mode.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Mode.length);
                encoder.string(this.Mode);
            }

            if (this.ProxyChecksHostKeys != null) {
                const f = this.ProxyChecksHostKeys as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SessionRecordingConfigSpecV2
    } // SessionRecordingConfigSpecV2

    export class AuthPreferenceV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.AuthPreferenceSpecV2 =
            new types.AuthPreferenceSpecV2();

        // Decodes AuthPreferenceV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthPreferenceV2 {
            return AuthPreferenceV2.decode(new DataView(buf));
        }

        // Decodes AuthPreferenceV2 from a DataView
        static decode(view: DataView): AuthPreferenceV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthPreferenceV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AuthPreferenceSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthPreferenceV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AuthPreferenceSpecV2 = this
                    .Spec as types.AuthPreferenceSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthPreferenceV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthPreferenceV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AuthPreferenceSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AuthPreferenceV2
    } // AuthPreferenceV2

    export class AuthPreferenceSpecV2 {
        public Type: string = "";
        public SecondFactor: string = "";
        public ConnectorName: string = "";
        public U2F: types.U2F = new types.U2F();
        public RequireSessionMFA: bool;
        public DisconnectExpiredCert: types.BoolValue = new types.BoolValue();
        public AllowLocalAuth: types.BoolValue = new types.BoolValue();
        public MessageOfTheDay: string = "";
        public LockingMode: string = "";
        public Webauthn: types.Webauthn = new types.Webauthn();

        // Decodes AuthPreferenceSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthPreferenceSpecV2 {
            return AuthPreferenceSpecV2.decode(new DataView(buf));
        }

        // Decodes AuthPreferenceSpecV2 from a DataView
        static decode(view: DataView): AuthPreferenceSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthPreferenceSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SecondFactor = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ConnectorName = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.U2F = types.U2F.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.RequireSessionMFA = decoder.bool();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.DisconnectExpiredCert = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.AllowLocalAuth = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        obj.MessageOfTheDay = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.LockingMode = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Webauthn = types.Webauthn.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthPreferenceSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.SecondFactor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SecondFactor.length) +
                      this.SecondFactor.length
                    : 0;
            size +=
                this.ConnectorName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ConnectorName.length) +
                      this.ConnectorName.length
                    : 0;

            if (this.U2F != null) {
                const f: types.U2F = this.U2F as types.U2F;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;

            if (this.DisconnectExpiredCert != null) {
                const f: types.BoolValue = this
                    .DisconnectExpiredCert as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AllowLocalAuth != null) {
                const f: types.BoolValue = this
                    .AllowLocalAuth as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.MessageOfTheDay.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.MessageOfTheDay.length) +
                      this.MessageOfTheDay.length
                    : 0;
            size +=
                this.LockingMode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LockingMode.length) +
                      this.LockingMode.length
                    : 0;

            if (this.Webauthn != null) {
                const f: types.Webauthn = this.Webauthn as types.Webauthn;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthPreferenceSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthPreferenceSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.SecondFactor.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SecondFactor.length);
                encoder.string(this.SecondFactor);
            }
            if (this.ConnectorName.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ConnectorName.length);
                encoder.string(this.ConnectorName);
            }

            if (this.U2F != null) {
                const f = this.U2F as types.U2F;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RequireSessionMFA != 0) {
                encoder.uint32(0x28);
                encoder.bool(this.RequireSessionMFA);
            }

            if (this.DisconnectExpiredCert != null) {
                const f = this.DisconnectExpiredCert as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AllowLocalAuth != null) {
                const f = this.AllowLocalAuth as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.MessageOfTheDay.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.MessageOfTheDay.length);
                encoder.string(this.MessageOfTheDay);
            }
            if (this.LockingMode.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.LockingMode.length);
                encoder.string(this.LockingMode);
            }

            if (this.Webauthn != null) {
                const f = this.Webauthn as types.Webauthn;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AuthPreferenceSpecV2
    } // AuthPreferenceSpecV2

    export class U2F {
        public AppID: string = "";
        public Facets: Array<string> = new Array<string>();
        public DeviceAttestationCAs: Array<string> = new Array<string>();

        // Decodes U2F from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2F {
            return U2F.decode(new DataView(buf));
        }

        // Decodes U2F from a DataView
        static decode(view: DataView): U2F {
            const decoder = new __proto.Decoder(view);
            const obj = new U2F();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AppID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Facets.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.DeviceAttestationCAs.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2F

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AppID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppID.length) +
                      this.AppID.length
                    : 0;

            size += __size_string_repeated(this.Facets);

            size += __size_string_repeated(this.DeviceAttestationCAs);

            return size;
        }

        // Encodes U2F to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2F to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AppID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AppID.length);
                encoder.string(this.AppID);
            }

            if (this.Facets.length > 0) {
                for (let n: i32 = 0; n < this.Facets.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Facets[n].length);
                    encoder.string(this.Facets[n]);
                }
            }

            if (this.DeviceAttestationCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.DeviceAttestationCAs.length;
                    n++
                ) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.DeviceAttestationCAs[n].length);
                    encoder.string(this.DeviceAttestationCAs[n]);
                }
            }

            return buf;
        } // encode U2F
    } // U2F

    export class Webauthn {
        public RPID: string = "";
        public AttestationAllowedCAs: Array<string> = new Array<string>();
        public AttestationDeniedCAs: Array<string> = new Array<string>();
        public Disabled: bool;

        // Decodes Webauthn from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Webauthn {
            return Webauthn.decode(new DataView(buf));
        }

        // Decodes Webauthn from a DataView
        static decode(view: DataView): Webauthn {
            const decoder = new __proto.Decoder(view);
            const obj = new Webauthn();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RPID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AttestationAllowedCAs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.AttestationDeniedCAs.push(decoder.string());
                        break;
                    }
                    case 4: {
                        obj.Disabled = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Webauthn

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.RPID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RPID.length) +
                      this.RPID.length
                    : 0;

            size += __size_string_repeated(this.AttestationAllowedCAs);

            size += __size_string_repeated(this.AttestationDeniedCAs);

            size += this.Disabled == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes Webauthn to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Webauthn to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RPID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.RPID.length);
                encoder.string(this.RPID);
            }

            if (this.AttestationAllowedCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AttestationAllowedCAs.length;
                    n++
                ) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.AttestationAllowedCAs[n].length);
                    encoder.string(this.AttestationAllowedCAs[n]);
                }
            }

            if (this.AttestationDeniedCAs.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AttestationDeniedCAs.length;
                    n++
                ) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.AttestationDeniedCAs[n].length);
                    encoder.string(this.AttestationDeniedCAs[n]);
                }
            }

            if (this.Disabled != 0) {
                encoder.uint32(0x20);
                encoder.bool(this.Disabled);
            }

            return buf;
        } // encode Webauthn
    } // Webauthn

    export class Namespace {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.NamespaceSpec = new types.NamespaceSpec();

        // Decodes Namespace from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Namespace {
            return Namespace.decode(new DataView(buf));
        }

        // Decodes Namespace from a DataView
        static decode(view: DataView): Namespace {
            const decoder = new __proto.Decoder(view);
            const obj = new Namespace();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.NamespaceSpec.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Namespace

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.NamespaceSpec = this.Spec as types.NamespaceSpec;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Namespace to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Namespace to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.NamespaceSpec;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode Namespace
    } // Namespace

    export class NamespaceSpec {
        // Decodes NamespaceSpec from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NamespaceSpec {
            return NamespaceSpec.decode(new DataView(buf));
        }

        // Decodes NamespaceSpec from a DataView
        static decode(view: DataView): NamespaceSpec {
            const decoder = new __proto.Decoder(view);
            const obj = new NamespaceSpec();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NamespaceSpec

        public size(): u32 {
            let size: u32 = 0;

            return size;
        }

        // Encodes NamespaceSpec to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NamespaceSpec to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            return buf;
        } // encode NamespaceSpec
    } // NamespaceSpec

    export class UserTokenV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.UserTokenSpecV3 = new types.UserTokenSpecV3();

        // Decodes UserTokenV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenV3 {
            return UserTokenV3.decode(new DataView(buf));
        }

        // Decodes UserTokenV3 from a DataView
        static decode(view: DataView): UserTokenV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserTokenSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserTokenSpecV3 = this
                    .Spec as types.UserTokenSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserTokenSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserTokenV3
    } // UserTokenV3

    export class UserTokenSpecV3 {
        public User: string = "";
        public URL: string = "";
        public Usage: u32;
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes UserTokenSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSpecV3 {
            return UserTokenSpecV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSpecV3 from a DataView
        static decode(view: DataView): UserTokenSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.URL = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Usage = decoder.uint32();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.URL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.URL.length) +
                      this.URL.length
                    : 0;
            size += this.Usage == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Usage);

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.URL.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.URL.length);
                encoder.string(this.URL);
            }
            if (this.Usage != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.Usage);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserTokenSpecV3
    } // UserTokenSpecV3

    export class UserTokenSecretsV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.UserTokenSecretsSpecV3 =
            new types.UserTokenSecretsSpecV3();

        // Decodes UserTokenSecretsV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSecretsV3 {
            return UserTokenSecretsV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSecretsV3 from a DataView
        static decode(view: DataView): UserTokenSecretsV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSecretsV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserTokenSecretsSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSecretsV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserTokenSecretsSpecV3 = this
                    .Spec as types.UserTokenSecretsSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSecretsV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSecretsV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserTokenSecretsSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserTokenSecretsV3
    } // UserTokenSecretsV3

    export class UserTokenSecretsSpecV3 {
        public OTPKey: string = "";
        public QRCode: string = "";
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes UserTokenSecretsSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenSecretsSpecV3 {
            return UserTokenSecretsSpecV3.decode(new DataView(buf));
        }

        // Decodes UserTokenSecretsSpecV3 from a DataView
        static decode(view: DataView): UserTokenSecretsSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenSecretsSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.OTPKey = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.QRCode = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenSecretsSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.OTPKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.OTPKey.length) +
                      this.OTPKey.length
                    : 0;
            size +=
                this.QRCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.QRCode.length) +
                      this.QRCode.length
                    : 0;

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenSecretsSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenSecretsSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.OTPKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.OTPKey.length);
                encoder.string(this.OTPKey);
            }
            if (this.QRCode.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.QRCode.length);
                encoder.string(this.QRCode);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserTokenSecretsSpecV3
    } // UserTokenSecretsSpecV3

    export class AccessRequestV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.AccessRequestSpecV3 =
            new types.AccessRequestSpecV3();

        // Decodes AccessRequestV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestV3 {
            return AccessRequestV3.decode(new DataView(buf));
        }

        // Decodes AccessRequestV3 from a DataView
        static decode(view: DataView): AccessRequestV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.AccessRequestSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.AccessRequestSpecV3 = this
                    .Spec as types.AccessRequestSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AccessRequestV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.AccessRequestSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AccessRequestV3
    } // AccessRequestV3

    export class AccessReviewThreshold {
        public Name: string = "";
        public Filter: string = "";
        public Approve: u32;
        public Deny: u32;

        // Decodes AccessReviewThreshold from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewThreshold {
            return AccessReviewThreshold.decode(new DataView(buf));
        }

        // Decodes AccessReviewThreshold from a DataView
        static decode(view: DataView): AccessReviewThreshold {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewThreshold();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Filter = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Approve = decoder.uint32();
                        break;
                    }
                    case 4: {
                        obj.Deny = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewThreshold

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Filter.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Filter.length) +
                      this.Filter.length
                    : 0;
            size +=
                this.Approve == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Approve);
            size += this.Deny == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Deny);

            return size;
        }

        // Encodes AccessReviewThreshold to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewThreshold to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Filter.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Filter.length);
                encoder.string(this.Filter);
            }
            if (this.Approve != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.Approve);
            }
            if (this.Deny != 0) {
                encoder.uint32(0x20);
                encoder.uint32(this.Deny);
            }

            return buf;
        } // encode AccessReviewThreshold
    } // AccessReviewThreshold

    export class AccessReview {
        public Author: string = "";
        public Roles: Array<string> = new Array<string>();
        public ProposedState: u32;
        public Reason: string = "";
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Annotations: wrappers.LabelValues = new wrappers.LabelValues();
        public ThresholdIndexes: Array<u32> = new Array<u32>();

        // Decodes AccessReview from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReview {
            return AccessReview.decode(new DataView(buf));
        }

        // Decodes AccessReview from a DataView
        static decode(view: DataView): AccessReview {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReview();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Author = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.ProposedState = decoder.uint32();
                        break;
                    }
                    case 4: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Annotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.ThresholdIndexes.push(decoder.uint32());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReview

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Author.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Author.length) +
                      this.Author.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            size +=
                this.ProposedState == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.ProposedState);
            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Annotations != null) {
                const f: wrappers.LabelValues = this
                    .Annotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_uint32_repeated(this.ThresholdIndexes);

            return size;
        }

        // Encodes AccessReview to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReview to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Author.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Author.length);
                encoder.string(this.Author);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.ProposedState != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.ProposedState);
            }
            if (this.Reason.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Annotations != null) {
                const f = this.Annotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ThresholdIndexes.length > 0) {
                for (let n: i32 = 0; n < this.ThresholdIndexes.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.ThresholdIndexes[n]);
                }
            }

            return buf;
        } // encode AccessReview
    } // AccessReview

    export class AccessReviewSubmission {
        public RequestID: string = "";
        public Review: types.AccessReview = new types.AccessReview();

        // Decodes AccessReviewSubmission from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewSubmission {
            return AccessReviewSubmission.decode(new DataView(buf));
        }

        // Decodes AccessReviewSubmission from a DataView
        static decode(view: DataView): AccessReviewSubmission {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewSubmission();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RequestID = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Review = types.AccessReview.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewSubmission

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.RequestID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestID.length) +
                      this.RequestID.length
                    : 0;

            if (this.Review != null) {
                const f: types.AccessReview = this.Review as types.AccessReview;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AccessReviewSubmission to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewSubmission to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RequestID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.RequestID.length);
                encoder.string(this.RequestID);
            }

            if (this.Review != null) {
                const f = this.Review as types.AccessReview;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AccessReviewSubmission
    } // AccessReviewSubmission

    export class ThresholdIndexSet {
        public Indexes: Array<u32> = new Array<u32>();

        // Decodes ThresholdIndexSet from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ThresholdIndexSet {
            return ThresholdIndexSet.decode(new DataView(buf));
        }

        // Decodes ThresholdIndexSet from a DataView
        static decode(view: DataView): ThresholdIndexSet {
            const decoder = new __proto.Decoder(view);
            const obj = new ThresholdIndexSet();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Indexes.push(decoder.uint32());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ThresholdIndexSet

        public size(): u32 {
            let size: u32 = 0;

            size += __size_uint32_repeated(this.Indexes);

            return size;
        }

        // Encodes ThresholdIndexSet to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ThresholdIndexSet to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Indexes.length > 0) {
                for (let n: i32 = 0; n < this.Indexes.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Indexes[n]);
                }
            }

            return buf;
        } // encode ThresholdIndexSet
    } // ThresholdIndexSet

    export class ThresholdIndexSets {
        public Sets: Array<types.ThresholdIndexSet> =
            new Array<types.ThresholdIndexSet>();

        // Decodes ThresholdIndexSets from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ThresholdIndexSets {
            return ThresholdIndexSets.decode(new DataView(buf));
        }

        // Decodes ThresholdIndexSets from a DataView
        static decode(view: DataView): ThresholdIndexSets {
            const decoder = new __proto.Decoder(view);
            const obj = new ThresholdIndexSets();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Sets.push(
                            types.ThresholdIndexSet.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ThresholdIndexSets

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Sets.length; n++) {
                const messageSize = this.Sets[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ThresholdIndexSets to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ThresholdIndexSets to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Sets.length; n++) {
                const messageSize = this.Sets[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Sets[n].encode(encoder);
                }
            }

            return buf;
        } // encode ThresholdIndexSets
    } // ThresholdIndexSets

    export class AccessRequestSpecV3 {
        public User: string = "";
        public Roles: Array<string> = new Array<string>();
        public State: u32;
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public RequestReason: string = "";
        public ResolveReason: string = "";
        public ResolveAnnotations: wrappers.LabelValues =
            new wrappers.LabelValues();
        public SystemAnnotations: wrappers.LabelValues =
            new wrappers.LabelValues();
        public Thresholds: Array<types.AccessReviewThreshold> =
            new Array<types.AccessReviewThreshold>();
        public RoleThresholdMapping: Map<string, types.ThresholdIndexSets> =
            new Map<string, types.ThresholdIndexSets>();
        public Reviews: Array<types.AccessReview> =
            new Array<types.AccessReview>();
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessRequestSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestSpecV3 {
            return AccessRequestSpecV3.decode(new DataView(buf));
        }

        // Decodes AccessRequestSpecV3 from a DataView
        static decode(view: DataView): AccessRequestSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.State = decoder.uint32();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.RequestReason = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ResolveReason = decoder.string();
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.ResolveAnnotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.SystemAnnotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.Thresholds.push(
                            types.AccessReviewThreshold.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_ThresholdIndexSets(
                            decoder,
                            length,
                            obj.RoleThresholdMapping
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Reviews.push(
                            types.AccessReview.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RequestReason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestReason.length) +
                      this.RequestReason.length
                    : 0;
            size +=
                this.ResolveReason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResolveReason.length) +
                      this.ResolveReason.length
                    : 0;

            if (this.ResolveAnnotations != null) {
                const f: wrappers.LabelValues = this
                    .ResolveAnnotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SystemAnnotations != null) {
                const f: wrappers.LabelValues = this
                    .SystemAnnotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleThresholdMapping.size > 0) {
                const keys = this.RoleThresholdMapping.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.RoleThresholdMapping.get(key);
                    const itemSize =
                        __sizeMapEntry_string_types_ThresholdIndexSets(
                            key,
                            value
                        );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            for (let n: i32 = 0; n < this.Reviews.length; n++) {
                const messageSize = this.Reviews[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessRequestSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.State != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.State);
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RequestReason.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.RequestReason.length);
                encoder.string(this.RequestReason);
            }
            if (this.ResolveReason.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ResolveReason.length);
                encoder.string(this.ResolveReason);
            }

            if (this.ResolveAnnotations != null) {
                const f = this.ResolveAnnotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SystemAnnotations != null) {
                const f = this.SystemAnnotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.Thresholds[n].encode(encoder);
                }
            }

            if (this.RoleThresholdMapping.size > 0) {
                const keys = this.RoleThresholdMapping.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.RoleThresholdMapping.get(key);
                    const size = __sizeMapEntry_string_types_ThresholdIndexSets(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x5a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            for (let n: i32 = 0; n < this.Reviews.length; n++) {
                const messageSize = this.Reviews[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    this.Reviews[n].encode(encoder);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessRequestSpecV3
    } // AccessRequestSpecV3

    export class AccessRequestFilter {
        public ID: string = "";
        public User: string = "";
        public State: u32;

        // Decodes AccessRequestFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestFilter {
            return AccessRequestFilter.decode(new DataView(buf));
        }

        // Decodes AccessRequestFilter from a DataView
        static decode(view: DataView): AccessRequestFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.State = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);

            return size;
        }

        // Encodes AccessRequestFilter to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestFilter to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.User.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.State != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.State);
            }

            return buf;
        } // encode AccessRequestFilter
    } // AccessRequestFilter

    export class AccessCapabilities {
        public RequestableRoles: Array<string> = new Array<string>();
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessCapabilities from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessCapabilities {
            return AccessCapabilities.decode(new DataView(buf));
        }

        // Decodes AccessCapabilities from a DataView
        static decode(view: DataView): AccessCapabilities {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessCapabilities();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.RequestableRoles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessCapabilities

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.RequestableRoles);

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessCapabilities to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessCapabilities to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.RequestableRoles.length > 0) {
                for (let n: i32 = 0; n < this.RequestableRoles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.RequestableRoles[n].length);
                    encoder.string(this.RequestableRoles[n]);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessCapabilities
    } // AccessCapabilities

    export class AccessCapabilitiesRequest {
        public User: string = "";
        public RequestableRoles: bool;
        public SuggestedReviewers: bool;

        // Decodes AccessCapabilitiesRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessCapabilitiesRequest {
            return AccessCapabilitiesRequest.decode(new DataView(buf));
        }

        // Decodes AccessCapabilitiesRequest from a DataView
        static decode(view: DataView): AccessCapabilitiesRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessCapabilitiesRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.RequestableRoles = decoder.bool();
                        break;
                    }
                    case 3: {
                        obj.SuggestedReviewers = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessCapabilitiesRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size += this.RequestableRoles == 0 ? 0 : 1 + 1;
            size += this.SuggestedReviewers == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes AccessCapabilitiesRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessCapabilitiesRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.RequestableRoles != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.RequestableRoles);
            }
            if (this.SuggestedReviewers != 0) {
                encoder.uint32(0x18);
                encoder.bool(this.SuggestedReviewers);
            }

            return buf;
        } // encode AccessCapabilitiesRequest
    } // AccessCapabilitiesRequest

    export class PluginDataV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.PluginDataSpecV3 = new types.PluginDataSpecV3();

        // Decodes PluginDataV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataV3 {
            return PluginDataV3.decode(new DataView(buf));
        }

        // Decodes PluginDataV3 from a DataView
        static decode(view: DataView): PluginDataV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.PluginDataSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.PluginDataSpecV3 = this
                    .Spec as types.PluginDataSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes PluginDataV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.PluginDataSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode PluginDataV3
    } // PluginDataV3

    export class PluginDataEntry {
        public Data: Map<string, string> = new Map<string, string>();

        // Decodes PluginDataEntry from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataEntry {
            return PluginDataEntry.decode(new DataView(buf));
        }

        // Decodes PluginDataEntry from a DataView
        static decode(view: DataView): PluginDataEntry {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataEntry();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Data);
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataEntry

        public size(): u32 {
            let size: u32 = 0;

            if (this.Data.size > 0) {
                const keys = this.Data.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Data.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataEntry to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataEntry to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Data.size > 0) {
                const keys = this.Data.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Data.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataEntry
    } // PluginDataEntry

    export class PluginDataSpecV3 {
        public Entries: Map<string, types.PluginDataEntry> = new Map<
            string,
            types.PluginDataEntry
        >();

        // Decodes PluginDataSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataSpecV3 {
            return PluginDataSpecV3.decode(new DataView(buf));
        }

        // Decodes PluginDataSpecV3 from a DataView
        static decode(view: DataView): PluginDataSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_PluginDataEntry(
                            decoder,
                            length,
                            obj.Entries
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataSpecV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Entries.size > 0) {
                const keys = this.Entries.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Entries.get(key);
                    const itemSize =
                        __sizeMapEntry_string_types_PluginDataEntry(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Entries.size > 0) {
                const keys = this.Entries.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Entries.get(key);
                    const size = __sizeMapEntry_string_types_PluginDataEntry(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataSpecV3
    } // PluginDataSpecV3

    export class PluginDataFilter {
        public Kind: string = "";
        public Resource: string = "";
        public Plugin: string = "";

        // Decodes PluginDataFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataFilter {
            return PluginDataFilter.decode(new DataView(buf));
        }

        // Decodes PluginDataFilter from a DataView
        static decode(view: DataView): PluginDataFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Resource = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Plugin = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.Resource.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Resource.length) +
                      this.Resource.length
                    : 0;
            size +=
                this.Plugin.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Plugin.length) +
                      this.Plugin.length
                    : 0;

            return size;
        }

        // Encodes PluginDataFilter to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataFilter to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.Resource.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Resource.length);
                encoder.string(this.Resource);
            }
            if (this.Plugin.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Plugin.length);
                encoder.string(this.Plugin);
            }

            return buf;
        } // encode PluginDataFilter
    } // PluginDataFilter

    export class PluginDataUpdateParams {
        public Kind: string = "";
        public Resource: string = "";
        public Plugin: string = "";
        public Set: Map<string, string> = new Map<string, string>();
        public Expect: Map<string, string> = new Map<string, string>();

        // Decodes PluginDataUpdateParams from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PluginDataUpdateParams {
            return PluginDataUpdateParams.decode(new DataView(buf));
        }

        // Decodes PluginDataUpdateParams from a DataView
        static decode(view: DataView): PluginDataUpdateParams {
            const decoder = new __proto.Decoder(view);
            const obj = new PluginDataUpdateParams();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Resource = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Plugin = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Set);
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(decoder, length, obj.Expect);
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PluginDataUpdateParams

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.Resource.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Resource.length) +
                      this.Resource.length
                    : 0;
            size +=
                this.Plugin.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Plugin.length) +
                      this.Plugin.length
                    : 0;

            if (this.Set.size > 0) {
                const keys = this.Set.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Set.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.Expect.size > 0) {
                const keys = this.Expect.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Expect.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes PluginDataUpdateParams to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PluginDataUpdateParams to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.Resource.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Resource.length);
                encoder.string(this.Resource);
            }
            if (this.Plugin.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Plugin.length);
                encoder.string(this.Plugin);
            }

            if (this.Set.size > 0) {
                const keys = this.Set.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Set.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x22);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.Expect.size > 0) {
                const keys = this.Expect.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.Expect.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode PluginDataUpdateParams
    } // PluginDataUpdateParams

    export class RoleV4 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.RoleSpecV4 = new types.RoleSpecV4();

        // Decodes RoleV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleV4 {
            return RoleV4.decode(new DataView(buf));
        }

        // Decodes RoleV4 from a DataView
        static decode(view: DataView): RoleV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.RoleSpecV4.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleV4

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.RoleSpecV4 = this.Spec as types.RoleSpecV4;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleV4 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleV4 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.RoleSpecV4;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RoleV4
    } // RoleV4

    export class RoleSpecV4 {
        public Options: types.RoleOptions = new types.RoleOptions();
        public Allow: types.RoleConditions = new types.RoleConditions();
        public Deny: types.RoleConditions = new types.RoleConditions();

        // Decodes RoleSpecV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleSpecV4 {
            return RoleSpecV4.decode(new DataView(buf));
        }

        // Decodes RoleSpecV4 from a DataView
        static decode(view: DataView): RoleSpecV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleSpecV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Options = types.RoleOptions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Allow = types.RoleConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Deny = types.RoleConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleSpecV4

        public size(): u32 {
            let size: u32 = 0;

            if (this.Options != null) {
                const f: types.RoleOptions = this.Options as types.RoleOptions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Allow != null) {
                const f: types.RoleConditions = this
                    .Allow as types.RoleConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Deny != null) {
                const f: types.RoleConditions = this
                    .Deny as types.RoleConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleSpecV4 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleSpecV4 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Options != null) {
                const f = this.Options as types.RoleOptions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Allow != null) {
                const f = this.Allow as types.RoleConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Deny != null) {
                const f = this.Deny as types.RoleConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RoleSpecV4
    } // RoleSpecV4

    export class RoleOptions {
        public ForwardAgent: bool;
        public MaxSessionTTL: i64;
        public PortForwarding: types.BoolValue = new types.BoolValue();
        public CertificateFormat: string = "";
        public ClientIdleTimeout: i64;
        public DisconnectExpiredCert: bool;
        public BPF: Array<string> = new Array<string>();
        public PermitX11Forwarding: bool;
        public MaxConnections: i64;
        public MaxSessions: i64;
        public RequestAccess: string = "";
        public RequestPrompt: string = "";
        public RequireSessionMFA: bool;
        public Lock: string = "";

        // Decodes RoleOptions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleOptions {
            return RoleOptions.decode(new DataView(buf));
        }

        // Decodes RoleOptions from a DataView
        static decode(view: DataView): RoleOptions {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleOptions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ForwardAgent = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.MaxSessionTTL = decoder.int64();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.PortForwarding = types.BoolValue.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.CertificateFormat = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ClientIdleTimeout = decoder.int64();
                        break;
                    }
                    case 6: {
                        obj.DisconnectExpiredCert = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.BPF.push(decoder.string());
                        break;
                    }
                    case 8: {
                        obj.PermitX11Forwarding = decoder.bool();
                        break;
                    }
                    case 9: {
                        obj.MaxConnections = decoder.int64();
                        break;
                    }
                    case 10: {
                        obj.MaxSessions = decoder.int64();
                        break;
                    }
                    case 11: {
                        obj.RequestAccess = decoder.string();
                        break;
                    }
                    case 12: {
                        obj.RequestPrompt = decoder.string();
                        break;
                    }
                    case 13: {
                        obj.RequireSessionMFA = decoder.bool();
                        break;
                    }
                    case 14: {
                        obj.Lock = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleOptions

        public size(): u32 {
            let size: u32 = 0;

            size += this.ForwardAgent == 0 ? 0 : 1 + 1;
            size +=
                this.MaxSessionTTL == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxSessionTTL);

            if (this.PortForwarding != null) {
                const f: types.BoolValue = this
                    .PortForwarding as types.BoolValue;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.CertificateFormat.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CertificateFormat.length) +
                      this.CertificateFormat.length
                    : 0;
            size +=
                this.ClientIdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);
            size += this.DisconnectExpiredCert == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.BPF);

            size += this.PermitX11Forwarding == 0 ? 0 : 1 + 1;
            size +=
                this.MaxConnections == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxConnections);
            size +=
                this.MaxSessions == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxSessions);
            size +=
                this.RequestAccess.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestAccess.length) +
                      this.RequestAccess.length
                    : 0;
            size +=
                this.RequestPrompt.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestPrompt.length) +
                      this.RequestPrompt.length
                    : 0;
            size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;
            size +=
                this.Lock.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Lock.length) +
                      this.Lock.length
                    : 0;

            return size;
        }

        // Encodes RoleOptions to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleOptions to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ForwardAgent != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.ForwardAgent);
            }
            if (this.MaxSessionTTL != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.MaxSessionTTL);
            }

            if (this.PortForwarding != null) {
                const f = this.PortForwarding as types.BoolValue;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.CertificateFormat.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.CertificateFormat.length);
                encoder.string(this.CertificateFormat);
            }
            if (this.ClientIdleTimeout != 0) {
                encoder.uint32(0x28);
                encoder.int64(this.ClientIdleTimeout);
            }
            if (this.DisconnectExpiredCert != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.DisconnectExpiredCert);
            }

            if (this.BPF.length > 0) {
                for (let n: i32 = 0; n < this.BPF.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.BPF[n].length);
                    encoder.string(this.BPF[n]);
                }
            }

            if (this.PermitX11Forwarding != 0) {
                encoder.uint32(0x40);
                encoder.bool(this.PermitX11Forwarding);
            }
            if (this.MaxConnections != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.MaxConnections);
            }
            if (this.MaxSessions != 0) {
                encoder.uint32(0x50);
                encoder.int64(this.MaxSessions);
            }
            if (this.RequestAccess.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.RequestAccess.length);
                encoder.string(this.RequestAccess);
            }
            if (this.RequestPrompt.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.RequestPrompt.length);
                encoder.string(this.RequestPrompt);
            }
            if (this.RequireSessionMFA != 0) {
                encoder.uint32(0x68);
                encoder.bool(this.RequireSessionMFA);
            }
            if (this.Lock.length > 0) {
                encoder.uint32(0x72);
                encoder.uint32(this.Lock.length);
                encoder.string(this.Lock);
            }

            return buf;
        } // encode RoleOptions
    } // RoleOptions

    export class RoleConditions {
        public Logins: Array<string> = new Array<string>();
        public Namespaces: Array<string> = new Array<string>();
        public NodeLabels: wrappers.LabelValues = new wrappers.LabelValues();
        public Rules: Array<types.Rule> = new Array<types.Rule>();
        public KubeGroups: Array<string> = new Array<string>();
        public Request: types.AccessRequestConditions =
            new types.AccessRequestConditions();
        public KubeUsers: Array<string> = new Array<string>();
        public AppLabels: wrappers.LabelValues = new wrappers.LabelValues();
        public ClusterLabels: wrappers.LabelValues = new wrappers.LabelValues();
        public KubernetesLabels: wrappers.LabelValues =
            new wrappers.LabelValues();
        public DatabaseLabels: wrappers.LabelValues =
            new wrappers.LabelValues();
        public DatabaseNames: Array<string> = new Array<string>();
        public DatabaseUsers: Array<string> = new Array<string>();
        public Impersonate: types.ImpersonateConditions =
            new types.ImpersonateConditions();
        public ReviewRequests: types.AccessReviewConditions =
            new types.AccessReviewConditions();
        public AWSRoleARNs: Array<string> = new Array<string>();
        public WindowsDesktopLogins: Array<string> = new Array<string>();
        public WindowsDesktopLabels: wrappers.LabelValues =
            new wrappers.LabelValues();

        // Decodes RoleConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleConditions {
            return RoleConditions.decode(new DataView(buf));
        }

        // Decodes RoleConditions from a DataView
        static decode(view: DataView): RoleConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Logins.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Namespaces.push(decoder.string());
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.NodeLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Rules.push(
                            types.Rule.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.KubeGroups.push(decoder.string());
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Request = types.AccessRequestConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.KubeUsers.push(decoder.string());
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.AppLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.ClusterLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.KubernetesLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.DatabaseLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        obj.DatabaseNames.push(decoder.string());
                        break;
                    }
                    case 13: {
                        obj.DatabaseUsers.push(decoder.string());
                        break;
                    }
                    case 14: {
                        const length = decoder.uint32();
                        obj.Impersonate = types.ImpersonateConditions.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 15: {
                        const length = decoder.uint32();
                        obj.ReviewRequests =
                            types.AccessReviewConditions.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 16: {
                        obj.AWSRoleARNs.push(decoder.string());
                        break;
                    }
                    case 17: {
                        obj.WindowsDesktopLogins.push(decoder.string());
                        break;
                    }
                    case 18: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopLabels = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Logins);

            size += __size_string_repeated(this.Namespaces);

            if (this.NodeLabels != null) {
                const f: wrappers.LabelValues = this
                    .NodeLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Rules.length; n++) {
                const messageSize = this.Rules[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.KubeGroups);

            if (this.Request != null) {
                const f: types.AccessRequestConditions = this
                    .Request as types.AccessRequestConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.KubeUsers);

            if (this.AppLabels != null) {
                const f: wrappers.LabelValues = this
                    .AppLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ClusterLabels != null) {
                const f: wrappers.LabelValues = this
                    .ClusterLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesLabels != null) {
                const f: wrappers.LabelValues = this
                    .KubernetesLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseLabels != null) {
                const f: wrappers.LabelValues = this
                    .DatabaseLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.DatabaseNames);

            size += __size_string_repeated(this.DatabaseUsers);

            if (this.Impersonate != null) {
                const f: types.ImpersonateConditions = this
                    .Impersonate as types.ImpersonateConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ReviewRequests != null) {
                const f: types.AccessReviewConditions = this
                    .ReviewRequests as types.AccessReviewConditions;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.AWSRoleARNs);

            size += __size_string_repeated(this.WindowsDesktopLogins);

            if (this.WindowsDesktopLabels != null) {
                const f: wrappers.LabelValues = this
                    .WindowsDesktopLabels as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleConditions to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleConditions to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Logins.length > 0) {
                for (let n: i32 = 0; n < this.Logins.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Logins[n].length);
                    encoder.string(this.Logins[n]);
                }
            }

            if (this.Namespaces.length > 0) {
                for (let n: i32 = 0; n < this.Namespaces.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Namespaces[n].length);
                    encoder.string(this.Namespaces[n]);
                }
            }

            if (this.NodeLabels != null) {
                const f = this.NodeLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Rules.length; n++) {
                const messageSize = this.Rules[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.Rules[n].encode(encoder);
                }
            }

            if (this.KubeGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubeGroups.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.KubeGroups[n].length);
                    encoder.string(this.KubeGroups[n]);
                }
            }

            if (this.Request != null) {
                const f = this.Request as types.AccessRequestConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubeUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubeUsers.length; n++) {
                    encoder.uint32(0x3a);
                    encoder.uint32(this.KubeUsers[n].length);
                    encoder.string(this.KubeUsers[n]);
                }
            }

            if (this.AppLabels != null) {
                const f = this.AppLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ClusterLabels != null) {
                const f = this.ClusterLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesLabels != null) {
                const f = this.KubernetesLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseLabels != null) {
                const f = this.DatabaseLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseNames.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseNames.length; n++) {
                    encoder.uint32(0x62);
                    encoder.uint32(this.DatabaseNames[n].length);
                    encoder.string(this.DatabaseNames[n]);
                }
            }

            if (this.DatabaseUsers.length > 0) {
                for (let n: i32 = 0; n < this.DatabaseUsers.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.DatabaseUsers[n].length);
                    encoder.string(this.DatabaseUsers[n]);
                }
            }

            if (this.Impersonate != null) {
                const f = this.Impersonate as types.ImpersonateConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x72);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ReviewRequests != null) {
                const f = this.ReviewRequests as types.AccessReviewConditions;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x7a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AWSRoleARNs.length > 0) {
                for (let n: i32 = 0; n < this.AWSRoleARNs.length; n++) {
                    encoder.uint32(0x82);
                    encoder.uint32(this.AWSRoleARNs[n].length);
                    encoder.string(this.AWSRoleARNs[n]);
                }
            }

            if (this.WindowsDesktopLogins.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.WindowsDesktopLogins.length;
                    n++
                ) {
                    encoder.uint32(0x8a);
                    encoder.uint32(this.WindowsDesktopLogins[n].length);
                    encoder.string(this.WindowsDesktopLogins[n]);
                }
            }

            if (this.WindowsDesktopLabels != null) {
                const f = this.WindowsDesktopLabels as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x92);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RoleConditions
    } // RoleConditions

    export class AccessRequestConditions {
        public Roles: Array<string> = new Array<string>();
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        public Annotations: wrappers.LabelValues = new wrappers.LabelValues();
        public Thresholds: Array<types.AccessReviewThreshold> =
            new Array<types.AccessReviewThreshold>();
        public SuggestedReviewers: Array<string> = new Array<string>();

        // Decodes AccessRequestConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestConditions {
            return AccessRequestConditions.decode(new DataView(buf));
        }

        // Decodes AccessRequestConditions from a DataView
        static decode(view: DataView): AccessRequestConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Annotations = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Thresholds.push(
                            types.AccessReviewThreshold.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.SuggestedReviewers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Annotations != null) {
                const f: wrappers.LabelValues = this
                    .Annotations as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.SuggestedReviewers);

            return size;
        }

        // Encodes AccessRequestConditions to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestConditions to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encode(encoder);
                }
            }

            if (this.Annotations != null) {
                const f = this.Annotations as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Thresholds.length; n++) {
                const messageSize = this.Thresholds[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.Thresholds[n].encode(encoder);
                }
            }

            if (this.SuggestedReviewers.length > 0) {
                for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.SuggestedReviewers[n].length);
                    encoder.string(this.SuggestedReviewers[n]);
                }
            }

            return buf;
        } // encode AccessRequestConditions
    } // AccessRequestConditions

    export class AccessReviewConditions {
        public Roles: Array<string> = new Array<string>();
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        public Where: string = "";

        // Decodes AccessReviewConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessReviewConditions {
            return AccessReviewConditions.decode(new DataView(buf));
        }

        // Decodes AccessReviewConditions from a DataView
        static decode(view: DataView): AccessReviewConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessReviewConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessReviewConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Roles);

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            return size;
        }

        // Encodes AccessReviewConditions to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessReviewConditions to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encode(encoder);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            return buf;
        } // encode AccessReviewConditions
    } // AccessReviewConditions

    export class ClaimMapping {
        public Claim: string = "";
        public Value: string = "";
        public Roles: Array<string> = new Array<string>();

        // Decodes ClaimMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClaimMapping {
            return ClaimMapping.decode(new DataView(buf));
        }

        // Decodes ClaimMapping from a DataView
        static decode(view: DataView): ClaimMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new ClaimMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Claim = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Roles.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClaimMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Claim.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Claim.length) +
                      this.Claim.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            return size;
        }

        // Encodes ClaimMapping to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClaimMapping to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Claim.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Claim.length);
                encoder.string(this.Claim);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            return buf;
        } // encode ClaimMapping
    } // ClaimMapping

    export class Rule {
        public Resources: Array<string> = new Array<string>();
        public Verbs: Array<string> = new Array<string>();
        public Where: string = "";
        public Actions: Array<string> = new Array<string>();

        // Decodes Rule from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Rule {
            return Rule.decode(new DataView(buf));
        }

        // Decodes Rule from a DataView
        static decode(view: DataView): Rule {
            const decoder = new __proto.Decoder(view);
            const obj = new Rule();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Resources.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Verbs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Actions.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Rule

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Resources);

            size += __size_string_repeated(this.Verbs);

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            size += __size_string_repeated(this.Actions);

            return size;
        }

        // Encodes Rule to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Rule to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Resources.length > 0) {
                for (let n: i32 = 0; n < this.Resources.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Resources[n].length);
                    encoder.string(this.Resources[n]);
                }
            }

            if (this.Verbs.length > 0) {
                for (let n: i32 = 0; n < this.Verbs.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Verbs[n].length);
                    encoder.string(this.Verbs[n]);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            if (this.Actions.length > 0) {
                for (let n: i32 = 0; n < this.Actions.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Actions[n].length);
                    encoder.string(this.Actions[n]);
                }
            }

            return buf;
        } // encode Rule
    } // Rule

    export class ImpersonateConditions {
        public Users: Array<string> = new Array<string>();
        public Roles: Array<string> = new Array<string>();
        public Where: string = "";

        // Decodes ImpersonateConditions from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ImpersonateConditions {
            return ImpersonateConditions.decode(new DataView(buf));
        }

        // Decodes ImpersonateConditions from a DataView
        static decode(view: DataView): ImpersonateConditions {
            const decoder = new __proto.Decoder(view);
            const obj = new ImpersonateConditions();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Users.push(decoder.string());
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Where = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ImpersonateConditions

        public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.Users);

            size += __size_string_repeated(this.Roles);

            size +=
                this.Where.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Where.length) +
                      this.Where.length
                    : 0;

            return size;
        }

        // Encodes ImpersonateConditions to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ImpersonateConditions to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Users.length > 0) {
                for (let n: i32 = 0; n < this.Users.length; n++) {
                    encoder.uint32(0xa);
                    encoder.uint32(this.Users[n].length);
                    encoder.string(this.Users[n]);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Where.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Where.length);
                encoder.string(this.Where);
            }

            return buf;
        } // encode ImpersonateConditions
    } // ImpersonateConditions

    export class BoolValue {
        public Value: bool;

        // Decodes BoolValue from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BoolValue {
            return BoolValue.decode(new DataView(buf));
        }

        // Decodes BoolValue from a DataView
        static decode(view: DataView): BoolValue {
            const decoder = new __proto.Decoder(view);
            const obj = new BoolValue();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Value = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BoolValue

        public size(): u32 {
            let size: u32 = 0;

            size += this.Value == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes BoolValue to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BoolValue to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Value != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Value);
            }

            return buf;
        } // encode BoolValue
    } // BoolValue

    export class UserV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.UserSpecV2 = new types.UserSpecV2();

        // Decodes UserV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserV2 {
            return UserV2.decode(new DataView(buf));
        }

        // Decodes UserV2 from a DataView
        static decode(view: DataView): UserV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.UserSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.UserSpecV2 = this.Spec as types.UserSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.UserSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserV2
    } // UserV2

    export class UserSpecV2 {
        public OIDCIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        public SAMLIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        public GithubIdentities: Array<types.ExternalIdentity> =
            new Array<types.ExternalIdentity>();
        public Roles: Array<string> = new Array<string>();
        public Traits: wrappers.LabelValues = new wrappers.LabelValues();
        public Status: types.LoginStatus = new types.LoginStatus();
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public CreatedBy: types.CreatedBy = new types.CreatedBy();
        public LocalAuth: types.LocalAuthSecrets = new types.LocalAuthSecrets();

        // Decodes UserSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserSpecV2 {
            return UserSpecV2.decode(new DataView(buf));
        }

        // Decodes UserSpecV2 from a DataView
        static decode(view: DataView): UserSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new UserSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.OIDCIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.SAMLIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.GithubIdentities.push(
                            types.ExternalIdentity.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Traits = wrappers.LabelValues.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = types.LoginStatus.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.CreatedBy = types.CreatedBy.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.LocalAuth = types.LocalAuthSecrets.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserSpecV2

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {
                const messageSize = this.OIDCIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {
                const messageSize = this.SAMLIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {
                const messageSize = this.GithubIdentities[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            if (this.Traits != null) {
                const f: wrappers.LabelValues = this
                    .Traits as wrappers.LabelValues;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.LoginStatus = this.Status as types.LoginStatus;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.CreatedBy != null) {
                const f: types.CreatedBy = this.CreatedBy as types.CreatedBy;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LocalAuth != null) {
                const f: types.LocalAuthSecrets = this
                    .LocalAuth as types.LocalAuthSecrets;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {
                const messageSize = this.OIDCIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.OIDCIdentities[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {
                const messageSize = this.SAMLIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.SAMLIdentities[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {
                const messageSize = this.GithubIdentities[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    this.GithubIdentities[n].encode(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Traits != null) {
                const f = this.Traits as wrappers.LabelValues;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.LoginStatus;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.CreatedBy != null) {
                const f = this.CreatedBy as types.CreatedBy;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.LocalAuth != null) {
                const f = this.LocalAuth as types.LocalAuthSecrets;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserSpecV2
    } // UserSpecV2

    export class ExternalIdentity {
        public ConnectorID: string = "";
        public Username: string = "";

        // Decodes ExternalIdentity from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ExternalIdentity {
            return ExternalIdentity.decode(new DataView(buf));
        }

        // Decodes ExternalIdentity from a DataView
        static decode(view: DataView): ExternalIdentity {
            const decoder = new __proto.Decoder(view);
            const obj = new ExternalIdentity();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ConnectorID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Username = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ExternalIdentity

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ConnectorID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ConnectorID.length) +
                      this.ConnectorID.length
                    : 0;
            size +=
                this.Username.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Username.length) +
                      this.Username.length
                    : 0;

            return size;
        }

        // Encodes ExternalIdentity to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ExternalIdentity to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ConnectorID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ConnectorID.length);
                encoder.string(this.ConnectorID);
            }
            if (this.Username.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Username.length);
                encoder.string(this.Username);
            }

            return buf;
        } // encode ExternalIdentity
    } // ExternalIdentity

    export class LoginStatus {
        public IsLocked: bool;
        public LockedMessage: string = "";
        public LockedTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public LockExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public RecoveryAttemptLockExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes LoginStatus from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LoginStatus {
            return LoginStatus.decode(new DataView(buf));
        }

        // Decodes LoginStatus from a DataView
        static decode(view: DataView): LoginStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new LoginStatus();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.IsLocked = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.LockedMessage = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LockedTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.LockExpires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.RecoveryAttemptLockExpires =
                            google.protobuf.Timestamp.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LoginStatus

        public size(): u32 {
            let size: u32 = 0;

            size += this.IsLocked == 0 ? 0 : 1 + 1;
            size +=
                this.LockedMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LockedMessage.length) +
                      this.LockedMessage.length
                    : 0;

            if (this.LockedTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LockedTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .LockExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryAttemptLockExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .RecoveryAttemptLockExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LoginStatus to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LoginStatus to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.IsLocked != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.IsLocked);
            }
            if (this.LockedMessage.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.LockedMessage.length);
                encoder.string(this.LockedMessage);
            }

            if (this.LockedTime != null) {
                const f = this.LockedTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.LockExpires != null) {
                const f = this.LockExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RecoveryAttemptLockExpires != null) {
                const f = this
                    .RecoveryAttemptLockExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LoginStatus
    } // LoginStatus

    export class CreatedBy {
        public Connector: types.ConnectorRef = new types.ConnectorRef();
        public Time: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public User: types.UserRef = new types.UserRef();

        // Decodes CreatedBy from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CreatedBy {
            return CreatedBy.decode(new DataView(buf));
        }

        // Decodes CreatedBy from a DataView
        static decode(view: DataView): CreatedBy {
            const decoder = new __proto.Decoder(view);
            const obj = new CreatedBy();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Connector = types.ConnectorRef.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Time = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = types.UserRef.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CreatedBy

        public size(): u32 {
            let size: u32 = 0;

            if (this.Connector != null) {
                const f: types.ConnectorRef = this
                    .Connector as types.ConnectorRef;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Time != null) {
                const f: google.protobuf.Timestamp = this
                    .Time as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: types.UserRef = this.User as types.UserRef;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes CreatedBy to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CreatedBy to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Connector != null) {
                const f = this.Connector as types.ConnectorRef;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Time != null) {
                const f = this.Time as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as types.UserRef;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode CreatedBy
    } // CreatedBy

    export class U2FRegistrationData {
        public Raw: Array<u8> = new Array<u8>();
        public KeyHandle: Array<u8> = new Array<u8>();
        public PubKey: Array<u8> = new Array<u8>();

        // Decodes U2FRegistrationData from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2FRegistrationData {
            return U2FRegistrationData.decode(new DataView(buf));
        }

        // Decodes U2FRegistrationData from a DataView
        static decode(view: DataView): U2FRegistrationData {
            const decoder = new __proto.Decoder(view);
            const obj = new U2FRegistrationData();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Raw = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.KeyHandle = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.PubKey = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2FRegistrationData

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Raw.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Raw.length) +
                      this.Raw.length
                    : 0;
            size +=
                this.KeyHandle.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KeyHandle.length) +
                      this.KeyHandle.length
                    : 0;
            size +=
                this.PubKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PubKey.length) +
                      this.PubKey.length
                    : 0;

            return size;
        }

        // Encodes U2FRegistrationData to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2FRegistrationData to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Raw.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Raw.length);
                encoder.bytes(this.Raw);
            }
            if (this.KeyHandle.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.KeyHandle.length);
                encoder.bytes(this.KeyHandle);
            }
            if (this.PubKey.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.PubKey.length);
                encoder.bytes(this.PubKey);
            }

            return buf;
        } // encode U2FRegistrationData
    } // U2FRegistrationData

    export class LocalAuthSecrets {
        public PasswordHash: Array<u8> = new Array<u8>();
        public TOTPKey: string = "";
        public U2FRegistration: types.U2FRegistrationData =
            new types.U2FRegistrationData();
        public U2FCounter: u32;
        public MFA: Array<types.MFADevice> = new Array<types.MFADevice>();
        public Webauthn: types.WebauthnLocalAuth =
            new types.WebauthnLocalAuth();

        // Decodes LocalAuthSecrets from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LocalAuthSecrets {
            return LocalAuthSecrets.decode(new DataView(buf));
        }

        // Decodes LocalAuthSecrets from a DataView
        static decode(view: DataView): LocalAuthSecrets {
            const decoder = new __proto.Decoder(view);
            const obj = new LocalAuthSecrets();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PasswordHash = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.TOTPKey = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.U2FRegistration = types.U2FRegistrationData.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.U2FCounter = decoder.uint32();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.MFA.push(
                            types.MFADevice.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Webauthn = types.WebauthnLocalAuth.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LocalAuthSecrets

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PasswordHash.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PasswordHash.length) +
                      this.PasswordHash.length
                    : 0;
            size +=
                this.TOTPKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TOTPKey.length) +
                      this.TOTPKey.length
                    : 0;

            if (this.U2FRegistration != null) {
                const f: types.U2FRegistrationData = this
                    .U2FRegistration as types.U2FRegistrationData;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.U2FCounter == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.U2FCounter);

            for (let n: i32 = 0; n < this.MFA.length; n++) {
                const messageSize = this.MFA[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Webauthn != null) {
                const f: types.WebauthnLocalAuth = this
                    .Webauthn as types.WebauthnLocalAuth;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LocalAuthSecrets to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LocalAuthSecrets to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PasswordHash.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PasswordHash.length);
                encoder.bytes(this.PasswordHash);
            }
            if (this.TOTPKey.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.TOTPKey.length);
                encoder.string(this.TOTPKey);
            }

            if (this.U2FRegistration != null) {
                const f = this.U2FRegistration as types.U2FRegistrationData;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.U2FCounter != 0) {
                encoder.uint32(0x20);
                encoder.uint32(this.U2FCounter);
            }

            for (let n: i32 = 0; n < this.MFA.length; n++) {
                const messageSize = this.MFA[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    this.MFA[n].encode(encoder);
                }
            }

            if (this.Webauthn != null) {
                const f = this.Webauthn as types.WebauthnLocalAuth;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LocalAuthSecrets
    } // LocalAuthSecrets

    export class MFADevice {
        public kind: string = "";
        public sub_kind: string = "";
        public version: string = "";
        public metadata: types.Metadata = new types.Metadata();
        public id: string = "";
        public added_at: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public last_used: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public totp: types.TOTPDevice | null;
        public u2f: types.U2FDevice | null;
        public webauthn: types.WebauthnDevice | null;

        // Decodes MFADevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADevice {
            return MFADevice.decode(new DataView(buf));
        }

        // Decodes MFADevice from a DataView
        static decode(view: DataView): MFADevice {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.sub_kind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.id = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.added_at = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.last_used = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.totp = types.TOTPDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.u2f = types.U2FDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.webauthn = types.WebauthnDevice.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.kind.length) +
                      this.kind.length
                    : 0;
            size +=
                this.sub_kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.sub_kind.length) +
                      this.sub_kind.length
                    : 0;
            size +=
                this.version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.version.length) +
                      this.version.length
                    : 0;

            if (this.metadata != null) {
                const f: types.Metadata = this.metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.id.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.id.length) +
                      this.id.length
                    : 0;

            if (this.added_at != null) {
                const f: google.protobuf.Timestamp = this
                    .added_at as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.last_used != null) {
                const f: google.protobuf.Timestamp = this
                    .last_used as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.totp != null) {
                const f: types.TOTPDevice = this.totp as types.TOTPDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.u2f != null) {
                const f: types.U2FDevice = this.u2f as types.U2FDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.webauthn != null) {
                const f: types.WebauthnDevice = this
                    .webauthn as types.WebauthnDevice;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADevice to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADevice to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.kind.length);
                encoder.string(this.kind);
            }
            if (this.sub_kind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.sub_kind.length);
                encoder.string(this.sub_kind);
            }
            if (this.version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.version.length);
                encoder.string(this.version);
            }

            if (this.metadata != null) {
                const f = this.metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.id.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.id.length);
                encoder.string(this.id);
            }

            if (this.added_at != null) {
                const f = this.added_at as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.last_used != null) {
                const f = this.last_used as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.totp != null) {
                const f = this.totp as types.TOTPDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.u2f != null) {
                const f = this.u2f as types.U2FDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.webauthn != null) {
                const f = this.webauthn as types.WebauthnDevice;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode MFADevice
    } // MFADevice

    export class TOTPDevice {
        public key: string = "";

        // Decodes TOTPDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TOTPDevice {
            return TOTPDevice.decode(new DataView(buf));
        }

        // Decodes TOTPDevice from a DataView
        static decode(view: DataView): TOTPDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new TOTPDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.key = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TOTPDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.key.length) +
                      this.key.length
                    : 0;

            return size;
        }

        // Encodes TOTPDevice to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TOTPDevice to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.key.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.key.length);
                encoder.string(this.key);
            }

            return buf;
        } // encode TOTPDevice
    } // TOTPDevice

    export class U2FDevice {
        public key_handle: Array<u8> = new Array<u8>();
        public pub_key: Array<u8> = new Array<u8>();
        public counter: u32;

        // Decodes U2FDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): U2FDevice {
            return U2FDevice.decode(new DataView(buf));
        }

        // Decodes U2FDevice from a DataView
        static decode(view: DataView): U2FDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new U2FDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.key_handle = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.pub_key = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.counter = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode U2FDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.key_handle.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.key_handle.length) +
                      this.key_handle.length
                    : 0;
            size +=
                this.pub_key.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.pub_key.length) +
                      this.pub_key.length
                    : 0;
            size +=
                this.counter == 0 ? 0 : 1 + __proto.Sizer.uint32(this.counter);

            return size;
        }

        // Encodes U2FDevice to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes U2FDevice to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.key_handle.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.key_handle.length);
                encoder.bytes(this.key_handle);
            }
            if (this.pub_key.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.pub_key.length);
                encoder.bytes(this.pub_key);
            }
            if (this.counter != 0) {
                encoder.uint32(0x18);
                encoder.uint32(this.counter);
            }

            return buf;
        } // encode U2FDevice
    } // U2FDevice

    export class WebauthnDevice {
        public credential_id: Array<u8> = new Array<u8>();
        public public_key_cbor: Array<u8> = new Array<u8>();
        public attestation_type: string = "";
        public aaguid: Array<u8> = new Array<u8>();
        public signature_counter: u32;

        // Decodes WebauthnDevice from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebauthnDevice {
            return WebauthnDevice.decode(new DataView(buf));
        }

        // Decodes WebauthnDevice from a DataView
        static decode(view: DataView): WebauthnDevice {
            const decoder = new __proto.Decoder(view);
            const obj = new WebauthnDevice();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.credential_id = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.public_key_cbor = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.attestation_type = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.aaguid = decoder.bytes();
                        break;
                    }
                    case 5: {
                        obj.signature_counter = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebauthnDevice

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.credential_id.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.credential_id.length) +
                      this.credential_id.length
                    : 0;
            size +=
                this.public_key_cbor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.public_key_cbor.length) +
                      this.public_key_cbor.length
                    : 0;
            size +=
                this.attestation_type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.attestation_type.length) +
                      this.attestation_type.length
                    : 0;
            size +=
                this.aaguid.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.aaguid.length) +
                      this.aaguid.length
                    : 0;
            size +=
                this.signature_counter == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.signature_counter);

            return size;
        }

        // Encodes WebauthnDevice to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebauthnDevice to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.credential_id.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.credential_id.length);
                encoder.bytes(this.credential_id);
            }
            if (this.public_key_cbor.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.public_key_cbor.length);
                encoder.bytes(this.public_key_cbor);
            }
            if (this.attestation_type.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.attestation_type.length);
                encoder.string(this.attestation_type);
            }
            if (this.aaguid.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.aaguid.length);
                encoder.bytes(this.aaguid);
            }
            if (this.signature_counter != 0) {
                encoder.uint32(0x28);
                encoder.uint32(this.signature_counter);
            }

            return buf;
        } // encode WebauthnDevice
    } // WebauthnDevice

    export class WebauthnLocalAuth {
        public UserID: Array<u8> = new Array<u8>();

        // Decodes WebauthnLocalAuth from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebauthnLocalAuth {
            return WebauthnLocalAuth.decode(new DataView(buf));
        }

        // Decodes WebauthnLocalAuth from a DataView
        static decode(view: DataView): WebauthnLocalAuth {
            const decoder = new __proto.Decoder(view);
            const obj = new WebauthnLocalAuth();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.UserID = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebauthnLocalAuth

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.UserID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UserID.length) +
                      this.UserID.length
                    : 0;

            return size;
        }

        // Encodes WebauthnLocalAuth to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebauthnLocalAuth to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UserID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.UserID.length);
                encoder.bytes(this.UserID);
            }

            return buf;
        } // encode WebauthnLocalAuth
    } // WebauthnLocalAuth

    export class ConnectorRef {
        public Type: string = "";
        public ID: string = "";
        public Identity: string = "";

        // Decodes ConnectorRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ConnectorRef {
            return ConnectorRef.decode(new DataView(buf));
        }

        // Decodes ConnectorRef from a DataView
        static decode(view: DataView): ConnectorRef {
            const decoder = new __proto.Decoder(view);
            const obj = new ConnectorRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Identity = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ConnectorRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.Identity.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Identity.length) +
                      this.Identity.length
                    : 0;

            return size;
        }

        // Encodes ConnectorRef to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ConnectorRef to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Type.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.Identity.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Identity.length);
                encoder.string(this.Identity);
            }

            return buf;
        } // encode ConnectorRef
    } // ConnectorRef

    export class UserRef {
        public Name: string = "";

        // Decodes UserRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserRef {
            return UserRef.decode(new DataView(buf));
        }

        // Decodes UserRef from a DataView
        static decode(view: DataView): UserRef {
            const decoder = new __proto.Decoder(view);
            const obj = new UserRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            return size;
        }

        // Encodes UserRef to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserRef to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            return buf;
        } // encode UserRef
    } // UserRef

    export class ReverseTunnelV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.ReverseTunnelSpecV2 =
            new types.ReverseTunnelSpecV2();

        // Decodes ReverseTunnelV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ReverseTunnelV2 {
            return ReverseTunnelV2.decode(new DataView(buf));
        }

        // Decodes ReverseTunnelV2 from a DataView
        static decode(view: DataView): ReverseTunnelV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ReverseTunnelV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.ReverseTunnelSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ReverseTunnelV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.ReverseTunnelSpecV2 = this
                    .Spec as types.ReverseTunnelSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes ReverseTunnelV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ReverseTunnelV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.ReverseTunnelSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode ReverseTunnelV2
    } // ReverseTunnelV2

    export class ReverseTunnelSpecV2 {
        public ClusterName: string = "";
        public DialAddrs: Array<string> = new Array<string>();
        public Type: string = "";

        // Decodes ReverseTunnelSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ReverseTunnelSpecV2 {
            return ReverseTunnelSpecV2.decode(new DataView(buf));
        }

        // Decodes ReverseTunnelSpecV2 from a DataView
        static decode(view: DataView): ReverseTunnelSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new ReverseTunnelSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DialAddrs.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Type = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ReverseTunnelSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            size += __size_string_repeated(this.DialAddrs);

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;

            return size;
        }

        // Encodes ReverseTunnelSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ReverseTunnelSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            if (this.DialAddrs.length > 0) {
                for (let n: i32 = 0; n < this.DialAddrs.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.DialAddrs[n].length);
                    encoder.string(this.DialAddrs[n]);
                }
            }

            if (this.Type.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }

            return buf;
        } // encode ReverseTunnelSpecV2
    } // ReverseTunnelSpecV2

    export class TunnelConnectionV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.TunnelConnectionSpecV2 =
            new types.TunnelConnectionSpecV2();

        // Decodes TunnelConnectionV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TunnelConnectionV2 {
            return TunnelConnectionV2.decode(new DataView(buf));
        }

        // Decodes TunnelConnectionV2 from a DataView
        static decode(view: DataView): TunnelConnectionV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TunnelConnectionV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.TunnelConnectionSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TunnelConnectionV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.TunnelConnectionSpecV2 = this
                    .Spec as types.TunnelConnectionSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TunnelConnectionV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TunnelConnectionV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.TunnelConnectionSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode TunnelConnectionV2
    } // TunnelConnectionV2

    export class TunnelConnectionSpecV2 {
        public ClusterName: string = "";
        public ProxyName: string = "";
        public LastHeartbeat: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Type: string = "";

        // Decodes TunnelConnectionSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TunnelConnectionSpecV2 {
            return TunnelConnectionSpecV2.decode(new DataView(buf));
        }

        // Decodes TunnelConnectionSpecV2 from a DataView
        static decode(view: DataView): TunnelConnectionSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TunnelConnectionSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClusterName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ProxyName = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LastHeartbeat = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Type = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TunnelConnectionSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;
            size +=
                this.ProxyName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProxyName.length) +
                      this.ProxyName.length
                    : 0;

            if (this.LastHeartbeat != null) {
                const f: google.protobuf.Timestamp = this
                    .LastHeartbeat as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;

            return size;
        }

        // Encodes TunnelConnectionSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TunnelConnectionSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClusterName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }
            if (this.ProxyName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ProxyName.length);
                encoder.string(this.ProxyName);
            }

            if (this.LastHeartbeat != null) {
                const f = this.LastHeartbeat as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Type.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }

            return buf;
        } // encode TunnelConnectionSpecV2
    } // TunnelConnectionSpecV2

    export class SemaphoreFilter {
        public SemaphoreKind: string = "";
        public SemaphoreName: string = "";

        // Decodes SemaphoreFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreFilter {
            return SemaphoreFilter.decode(new DataView(buf));
        }

        // Decodes SemaphoreFilter from a DataView
        static decode(view: DataView): SemaphoreFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;

            return size;
        }

        // Encodes SemaphoreFilter to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreFilter to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }

            return buf;
        } // encode SemaphoreFilter
    } // SemaphoreFilter

    export class AcquireSemaphoreRequest {
        public SemaphoreKind: string = "";
        public SemaphoreName: string = "";
        public MaxLeases: i64;
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Holder: string = "";

        // Decodes AcquireSemaphoreRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AcquireSemaphoreRequest {
            return AcquireSemaphoreRequest.decode(new DataView(buf));
        }

        // Decodes AcquireSemaphoreRequest from a DataView
        static decode(view: DataView): AcquireSemaphoreRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AcquireSemaphoreRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.MaxLeases = decoder.int64();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Holder = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AcquireSemaphoreRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;
            size +=
                this.MaxLeases == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.MaxLeases);

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Holder.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Holder.length) +
                      this.Holder.length
                    : 0;

            return size;
        }

        // Encodes AcquireSemaphoreRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AcquireSemaphoreRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }
            if (this.MaxLeases != 0) {
                encoder.uint32(0x18);
                encoder.int64(this.MaxLeases);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Holder.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Holder.length);
                encoder.string(this.Holder);
            }

            return buf;
        } // encode AcquireSemaphoreRequest
    } // AcquireSemaphoreRequest

    export class SemaphoreLease {
        public SemaphoreKind: string = "";
        public SemaphoreName: string = "";
        public LeaseID: string = "";
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes SemaphoreLease from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreLease {
            return SemaphoreLease.decode(new DataView(buf));
        }

        // Decodes SemaphoreLease from a DataView
        static decode(view: DataView): SemaphoreLease {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreLease();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SemaphoreKind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SemaphoreName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.LeaseID = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreLease

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SemaphoreKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreKind.length) +
                      this.SemaphoreKind.length
                    : 0;
            size +=
                this.SemaphoreName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SemaphoreName.length) +
                      this.SemaphoreName.length
                    : 0;
            size +=
                this.LeaseID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LeaseID.length) +
                      this.LeaseID.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreLease to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreLease to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SemaphoreKind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SemaphoreKind.length);
                encoder.string(this.SemaphoreKind);
            }
            if (this.SemaphoreName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SemaphoreName.length);
                encoder.string(this.SemaphoreName);
            }
            if (this.LeaseID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.LeaseID.length);
                encoder.string(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SemaphoreLease
    } // SemaphoreLease

    export class SemaphoreLeaseRef {
        public LeaseID: string = "";
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Holder: string = "";

        // Decodes SemaphoreLeaseRef from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreLeaseRef {
            return SemaphoreLeaseRef.decode(new DataView(buf));
        }

        // Decodes SemaphoreLeaseRef from a DataView
        static decode(view: DataView): SemaphoreLeaseRef {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreLeaseRef();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.LeaseID = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.Holder = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreLeaseRef

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.LeaseID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LeaseID.length) +
                      this.LeaseID.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Holder.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Holder.length) +
                      this.Holder.length
                    : 0;

            return size;
        }

        // Encodes SemaphoreLeaseRef to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreLeaseRef to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.LeaseID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.LeaseID.length);
                encoder.string(this.LeaseID);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Holder.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Holder.length);
                encoder.string(this.Holder);
            }

            return buf;
        } // encode SemaphoreLeaseRef
    } // SemaphoreLeaseRef

    export class SemaphoreV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.SemaphoreSpecV3 = new types.SemaphoreSpecV3();

        // Decodes SemaphoreV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreV3 {
            return SemaphoreV3.decode(new DataView(buf));
        }

        // Decodes SemaphoreV3 from a DataView
        static decode(view: DataView): SemaphoreV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SemaphoreSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SemaphoreSpecV3 = this
                    .Spec as types.SemaphoreSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SemaphoreSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SemaphoreV3
    } // SemaphoreV3

    export class SemaphoreSpecV3 {
        public Leases: Array<types.SemaphoreLeaseRef> =
            new Array<types.SemaphoreLeaseRef>();

        // Decodes SemaphoreSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SemaphoreSpecV3 {
            return SemaphoreSpecV3.decode(new DataView(buf));
        }

        // Decodes SemaphoreSpecV3 from a DataView
        static decode(view: DataView): SemaphoreSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new SemaphoreSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Leases.push(
                            types.SemaphoreLeaseRef.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SemaphoreSpecV3

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Leases.length; n++) {
                const messageSize = this.Leases[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SemaphoreSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SemaphoreSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Leases.length; n++) {
                const messageSize = this.Leases[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Leases[n].encode(encoder);
                }
            }

            return buf;
        } // encode SemaphoreSpecV3
    } // SemaphoreSpecV3

    export class WebSessionV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.WebSessionSpecV2 = new types.WebSessionSpecV2();

        // Decodes WebSessionV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionV2 {
            return WebSessionV2.decode(new DataView(buf));
        }

        // Decodes WebSessionV2 from a DataView
        static decode(view: DataView): WebSessionV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.WebSessionSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WebSessionSpecV2 = this
                    .Spec as types.WebSessionSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WebSessionV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WebSessionSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode WebSessionV2
    } // WebSessionV2

    export class WebSessionSpecV2 {
        public User: string = "";
        public Pub: Array<u8> = new Array<u8>();
        public Priv: Array<u8> = new Array<u8>();
        public TLSCert: Array<u8> = new Array<u8>();
        public BearerToken: string = "";
        public BearerTokenExpires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public LoginTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public IdleTimeout: i64;

        // Decodes WebSessionSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionSpecV2 {
            return WebSessionSpecV2.decode(new DataView(buf));
        }

        // Decodes WebSessionSpecV2 from a DataView
        static decode(view: DataView): WebSessionSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Pub = decoder.bytes();
                        break;
                    }
                    case 3: {
                        obj.Priv = decoder.bytes();
                        break;
                    }
                    case 4: {
                        obj.TLSCert = decoder.bytes();
                        break;
                    }
                    case 5: {
                        obj.BearerToken = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.BearerTokenExpires =
                            google.protobuf.Timestamp.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.LoginTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.IdleTimeout = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Pub.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Pub.length) +
                      this.Pub.length
                    : 0;
            size +=
                this.Priv.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Priv.length) +
                      this.Priv.length
                    : 0;
            size +=
                this.TLSCert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TLSCert.length) +
                      this.TLSCert.length
                    : 0;
            size +=
                this.BearerToken.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.BearerToken.length) +
                      this.BearerToken.length
                    : 0;

            if (this.BearerTokenExpires != null) {
                const f: google.protobuf.Timestamp = this
                    .BearerTokenExpires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LoginTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LoginTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.IdleTimeout == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.IdleTimeout);

            return size;
        }

        // Encodes WebSessionSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Pub.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Pub.length);
                encoder.bytes(this.Pub);
            }
            if (this.Priv.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Priv.length);
                encoder.bytes(this.Priv);
            }
            if (this.TLSCert.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.TLSCert.length);
                encoder.bytes(this.TLSCert);
            }
            if (this.BearerToken.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.BearerToken.length);
                encoder.string(this.BearerToken);
            }

            if (this.BearerTokenExpires != null) {
                const f = this.BearerTokenExpires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.LoginTime != null) {
                const f = this.LoginTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.IdleTimeout != 0) {
                encoder.uint32(0x48);
                encoder.int64(this.IdleTimeout);
            }

            return buf;
        } // encode WebSessionSpecV2
    } // WebSessionSpecV2

    export class WebSessionFilter {
        public User: string = "";

        // Decodes WebSessionFilter from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebSessionFilter {
            return WebSessionFilter.decode(new DataView(buf));
        }

        // Decodes WebSessionFilter from a DataView
        static decode(view: DataView): WebSessionFilter {
            const decoder = new __proto.Decoder(view);
            const obj = new WebSessionFilter();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebSessionFilter

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;

            return size;
        }

        // Encodes WebSessionFilter to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebSessionFilter to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }

            return buf;
        } // encode WebSessionFilter
    } // WebSessionFilter

    export class RemoteClusterV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Status: types.RemoteClusterStatusV3 =
            new types.RemoteClusterStatusV3();

        // Decodes RemoteClusterV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RemoteClusterV3 {
            return RemoteClusterV3.decode(new DataView(buf));
        }

        // Decodes RemoteClusterV3 from a DataView
        static decode(view: DataView): RemoteClusterV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new RemoteClusterV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Status = types.RemoteClusterStatusV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RemoteClusterV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: types.RemoteClusterStatusV3 = this
                    .Status as types.RemoteClusterStatusV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RemoteClusterV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RemoteClusterV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as types.RemoteClusterStatusV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RemoteClusterV3
    } // RemoteClusterV3

    export class RemoteClusterStatusV3 {
        public Connection: string = "";
        public LastHeartbeat: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RemoteClusterStatusV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RemoteClusterStatusV3 {
            return RemoteClusterStatusV3.decode(new DataView(buf));
        }

        // Decodes RemoteClusterStatusV3 from a DataView
        static decode(view: DataView): RemoteClusterStatusV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new RemoteClusterStatusV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Connection = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.LastHeartbeat = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RemoteClusterStatusV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Connection.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Connection.length) +
                      this.Connection.length
                    : 0;

            if (this.LastHeartbeat != null) {
                const f: google.protobuf.Timestamp = this
                    .LastHeartbeat as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RemoteClusterStatusV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RemoteClusterStatusV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Connection.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Connection.length);
                encoder.string(this.Connection);
            }

            if (this.LastHeartbeat != null) {
                const f = this.LastHeartbeat as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RemoteClusterStatusV3
    } // RemoteClusterStatusV3

    export class KubernetesCluster {
        public Name: string = "";
        public StaticLabels: Map<string, string> = new Map<string, string>();
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();

        // Decodes KubernetesCluster from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesCluster {
            return KubernetesCluster.decode(new DataView(buf));
        }

        // Decodes KubernetesCluster from a DataView
        static decode(view: DataView): KubernetesCluster {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesCluster();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.StaticLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesCluster

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes KubernetesCluster to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesCluster to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            if (this.StaticLabels.size > 0) {
                const keys = this.StaticLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.StaticLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x12);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode KubernetesCluster
    } // KubernetesCluster

    export class KubernetesClusterV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.KubernetesClusterSpecV3 =
            new types.KubernetesClusterSpecV3();

        // Decodes KubernetesClusterV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterV3 {
            return KubernetesClusterV3.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterV3 from a DataView
        static decode(view: DataView): KubernetesClusterV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.KubernetesClusterSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.KubernetesClusterSpecV3 = this
                    .Spec as types.KubernetesClusterSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes KubernetesClusterV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.KubernetesClusterSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode KubernetesClusterV3
    } // KubernetesClusterV3

    export class KubernetesClusterSpecV3 {
        public DynamicLabels: Map<string, types.CommandLabelV2> = new Map<
            string,
            types.CommandLabelV2
        >();

        // Decodes KubernetesClusterSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterSpecV3 {
            return KubernetesClusterSpecV3.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterSpecV3 from a DataView
        static decode(view: DataView): KubernetesClusterSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        __decodeMap_string_types_CommandLabelV2(
                            decoder,
                            length,
                            obj.DynamicLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterSpecV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const itemSize = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes KubernetesClusterSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DynamicLabels.size > 0) {
                const keys = this.DynamicLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DynamicLabels.get(key);
                    const size = __sizeMapEntry_string_types_CommandLabelV2(
                        key,
                        value
                    );
                    if (size > 0) {
                        encoder.uint32(0xa);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }

                        const messageSize = value.size();

                        if (messageSize > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(messageSize);
                            value.encode(encoder);
                        }
                    }
                }
            }

            return buf;
        } // encode KubernetesClusterSpecV3
    } // KubernetesClusterSpecV3

    export class WebTokenV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.WebTokenSpecV3 = new types.WebTokenSpecV3();

        // Decodes WebTokenV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebTokenV3 {
            return WebTokenV3.decode(new DataView(buf));
        }

        // Decodes WebTokenV3 from a DataView
        static decode(view: DataView): WebTokenV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebTokenV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.WebTokenSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebTokenV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WebTokenSpecV3 = this
                    .Spec as types.WebTokenSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WebTokenV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebTokenV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WebTokenSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode WebTokenV3
    } // WebTokenV3

    export class WebTokenSpecV3 {
        public User: string = "";
        public Token: string = "";

        // Decodes WebTokenSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WebTokenSpecV3 {
            return WebTokenSpecV3.decode(new DataView(buf));
        }

        // Decodes WebTokenSpecV3 from a DataView
        static decode(view: DataView): WebTokenSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WebTokenSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WebTokenSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes WebTokenSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WebTokenSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode WebTokenSpecV3
    } // WebTokenSpecV3

    export class GetWebSessionRequest {
        public User: string = "";
        public SessionID: string = "";

        // Decodes GetWebSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GetWebSessionRequest {
            return GetWebSessionRequest.decode(new DataView(buf));
        }

        // Decodes GetWebSessionRequest from a DataView
        static decode(view: DataView): GetWebSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new GetWebSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SessionID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GetWebSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;

            return size;
        }

        // Encodes GetWebSessionRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GetWebSessionRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.SessionID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }

            return buf;
        } // encode GetWebSessionRequest
    } // GetWebSessionRequest

    export class DeleteWebSessionRequest {
        public User: string = "";
        public SessionID: string = "";

        // Decodes DeleteWebSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DeleteWebSessionRequest {
            return DeleteWebSessionRequest.decode(new DataView(buf));
        }

        // Decodes DeleteWebSessionRequest from a DataView
        static decode(view: DataView): DeleteWebSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteWebSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SessionID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DeleteWebSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;

            return size;
        }

        // Encodes DeleteWebSessionRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DeleteWebSessionRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.SessionID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }

            return buf;
        } // encode DeleteWebSessionRequest
    } // DeleteWebSessionRequest

    export class GetWebTokenRequest {
        public User: string = "";
        public Token: string = "";

        // Decodes GetWebTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GetWebTokenRequest {
            return GetWebTokenRequest.decode(new DataView(buf));
        }

        // Decodes GetWebTokenRequest from a DataView
        static decode(view: DataView): GetWebTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new GetWebTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GetWebTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes GetWebTokenRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GetWebTokenRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode GetWebTokenRequest
    } // GetWebTokenRequest

    export class DeleteWebTokenRequest {
        public User: string = "";
        public Token: string = "";

        // Decodes DeleteWebTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DeleteWebTokenRequest {
            return DeleteWebTokenRequest.decode(new DataView(buf));
        }

        // Decodes DeleteWebTokenRequest from a DataView
        static decode(view: DataView): DeleteWebTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteWebTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Token = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DeleteWebTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            return size;
        }

        // Encodes DeleteWebTokenRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DeleteWebTokenRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            return buf;
        } // encode DeleteWebTokenRequest
    } // DeleteWebTokenRequest

    export class ResourceRequest {
        public Name: string = "";

        // Decodes ResourceRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceRequest {
            return ResourceRequest.decode(new DataView(buf));
        }

        // Decodes ResourceRequest from a DataView
        static decode(view: DataView): ResourceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            return size;
        }

        // Encodes ResourceRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            return buf;
        } // encode ResourceRequest
    } // ResourceRequest

    export class ResourceWithSecretsRequest {
        public Name: string = "";
        public WithSecrets: bool;

        // Decodes ResourceWithSecretsRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceWithSecretsRequest {
            return ResourceWithSecretsRequest.decode(new DataView(buf));
        }

        // Decodes ResourceWithSecretsRequest from a DataView
        static decode(view: DataView): ResourceWithSecretsRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceWithSecretsRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.WithSecrets = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceWithSecretsRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size += this.WithSecrets == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes ResourceWithSecretsRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceWithSecretsRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.WithSecrets != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.WithSecrets);
            }

            return buf;
        } // encode ResourceWithSecretsRequest
    } // ResourceWithSecretsRequest

    export class ResourcesWithSecretsRequest {
        public WithSecrets: bool;

        // Decodes ResourcesWithSecretsRequest from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ResourcesWithSecretsRequest {
            return ResourcesWithSecretsRequest.decode(new DataView(buf));
        }

        // Decodes ResourcesWithSecretsRequest from a DataView
        static decode(view: DataView): ResourcesWithSecretsRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourcesWithSecretsRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.WithSecrets = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourcesWithSecretsRequest

        public size(): u32 {
            let size: u32 = 0;

            size += this.WithSecrets == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes ResourcesWithSecretsRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourcesWithSecretsRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.WithSecrets != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.WithSecrets);
            }

            return buf;
        } // encode ResourcesWithSecretsRequest
    } // ResourcesWithSecretsRequest

    export class ResourceInNamespaceRequest {
        public Name: string = "";
        public Namespace: string = "";

        // Decodes ResourceInNamespaceRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceInNamespaceRequest {
            return ResourceInNamespaceRequest.decode(new DataView(buf));
        }

        // Decodes ResourceInNamespaceRequest from a DataView
        static decode(view: DataView): ResourceInNamespaceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceInNamespaceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Namespace = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceInNamespaceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;

            return size;
        }

        // Encodes ResourceInNamespaceRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceInNamespaceRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Namespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }

            return buf;
        } // encode ResourceInNamespaceRequest
    } // ResourceInNamespaceRequest

    export class ResourcesInNamespaceRequest {
        public Namespace: string = "";

        // Decodes ResourcesInNamespaceRequest from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): ResourcesInNamespaceRequest {
            return ResourcesInNamespaceRequest.decode(new DataView(buf));
        }

        // Decodes ResourcesInNamespaceRequest from a DataView
        static decode(view: DataView): ResourcesInNamespaceRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourcesInNamespaceRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Namespace = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourcesInNamespaceRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Namespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Namespace.length) +
                      this.Namespace.length
                    : 0;

            return size;
        }

        // Encodes ResourcesInNamespaceRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourcesInNamespaceRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Namespace.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Namespace.length);
                encoder.string(this.Namespace);
            }

            return buf;
        } // encode ResourcesInNamespaceRequest
    } // ResourcesInNamespaceRequest

    export class OIDCConnectorV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.OIDCConnectorSpecV2 =
            new types.OIDCConnectorSpecV2();

        // Decodes OIDCConnectorV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorV2 {
            return OIDCConnectorV2.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorV2 from a DataView
        static decode(view: DataView): OIDCConnectorV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.OIDCConnectorSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.OIDCConnectorSpecV2 = this
                    .Spec as types.OIDCConnectorSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.OIDCConnectorSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorV2
    } // OIDCConnectorV2

    export class OIDCConnectorV2List {
        public OIDCConnectors: Array<types.OIDCConnectorV2> =
            new Array<types.OIDCConnectorV2>();

        // Decodes OIDCConnectorV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorV2List {
            return OIDCConnectorV2List.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorV2List from a DataView
        static decode(view: DataView): OIDCConnectorV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.OIDCConnectors.push(
                            types.OIDCConnectorV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {
                const messageSize = this.OIDCConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorV2List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorV2List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {
                const messageSize = this.OIDCConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.OIDCConnectors[n].encode(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorV2List
    } // OIDCConnectorV2List

    export class OIDCConnectorSpecV2 {
        public IssuerURL: string = "";
        public ClientID: string = "";
        public ClientSecret: string = "";
        public RedirectURL: string = "";
        public ACR: string = "";
        public Provider: string = "";
        public Display: string = "";
        public Scope: Array<string> = new Array<string>();
        public Prompt: string = "";
        public ClaimsToRoles: Array<types.ClaimMapping> =
            new Array<types.ClaimMapping>();
        public GoogleServiceAccountURI: string = "";
        public GoogleServiceAccount: string = "";
        public GoogleAdminEmail: string = "";

        // Decodes OIDCConnectorSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorSpecV2 {
            return OIDCConnectorSpecV2.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorSpecV2 from a DataView
        static decode(view: DataView): OIDCConnectorSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.IssuerURL = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClientID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ClientSecret = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.RedirectURL = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ACR = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Provider = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Display = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Scope.push(decoder.string());
                        break;
                    }
                    case 9: {
                        obj.Prompt = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.ClaimsToRoles.push(
                            types.ClaimMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        obj.GoogleServiceAccountURI = decoder.string();
                        break;
                    }
                    case 12: {
                        obj.GoogleServiceAccount = decoder.string();
                        break;
                    }
                    case 13: {
                        obj.GoogleAdminEmail = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.IssuerURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.IssuerURL.length) +
                      this.IssuerURL.length
                    : 0;
            size +=
                this.ClientID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientID.length) +
                      this.ClientID.length
                    : 0;
            size +=
                this.ClientSecret.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientSecret.length) +
                      this.ClientSecret.length
                    : 0;
            size +=
                this.RedirectURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RedirectURL.length) +
                      this.RedirectURL.length
                    : 0;
            size +=
                this.ACR.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ACR.length) +
                      this.ACR.length
                    : 0;
            size +=
                this.Provider.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Provider.length) +
                      this.Provider.length
                    : 0;
            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;

            size += __size_string_repeated(this.Scope);

            size +=
                this.Prompt.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Prompt.length) +
                      this.Prompt.length
                    : 0;

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.GoogleServiceAccountURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.GoogleServiceAccountURI.length
                      ) +
                      this.GoogleServiceAccountURI.length
                    : 0;
            size +=
                this.GoogleServiceAccount.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.GoogleServiceAccount.length) +
                      this.GoogleServiceAccount.length
                    : 0;
            size +=
                this.GoogleAdminEmail.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.GoogleAdminEmail.length) +
                      this.GoogleAdminEmail.length
                    : 0;

            return size;
        }

        // Encodes OIDCConnectorSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.IssuerURL.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.IssuerURL.length);
                encoder.string(this.IssuerURL);
            }
            if (this.ClientID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClientID.length);
                encoder.string(this.ClientID);
            }
            if (this.ClientSecret.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ClientSecret.length);
                encoder.string(this.ClientSecret);
            }
            if (this.RedirectURL.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.RedirectURL.length);
                encoder.string(this.RedirectURL);
            }
            if (this.ACR.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ACR.length);
                encoder.string(this.ACR);
            }
            if (this.Provider.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Provider.length);
                encoder.string(this.Provider);
            }
            if (this.Display.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }

            if (this.Scope.length > 0) {
                for (let n: i32 = 0; n < this.Scope.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Scope[n].length);
                    encoder.string(this.Scope[n]);
                }
            }

            if (this.Prompt.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.Prompt.length);
                encoder.string(this.Prompt);
            }

            for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {
                const messageSize = this.ClaimsToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.ClaimsToRoles[n].encode(encoder);
                }
            }

            if (this.GoogleServiceAccountURI.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.GoogleServiceAccountURI.length);
                encoder.string(this.GoogleServiceAccountURI);
            }
            if (this.GoogleServiceAccount.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.GoogleServiceAccount.length);
                encoder.string(this.GoogleServiceAccount);
            }
            if (this.GoogleAdminEmail.length > 0) {
                encoder.uint32(0x6a);
                encoder.uint32(this.GoogleAdminEmail.length);
                encoder.string(this.GoogleAdminEmail);
            }

            return buf;
        } // encode OIDCConnectorSpecV2
    } // OIDCConnectorSpecV2

    export class SAMLConnectorV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.SAMLConnectorSpecV2 =
            new types.SAMLConnectorSpecV2();

        // Decodes SAMLConnectorV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorV2 {
            return SAMLConnectorV2.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorV2 from a DataView
        static decode(view: DataView): SAMLConnectorV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.SAMLConnectorSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.SAMLConnectorSpecV2 = this
                    .Spec as types.SAMLConnectorSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.SAMLConnectorSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorV2
    } // SAMLConnectorV2

    export class SAMLConnectorV2List {
        public SAMLConnectors: Array<types.SAMLConnectorV2> =
            new Array<types.SAMLConnectorV2>();

        // Decodes SAMLConnectorV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorV2List {
            return SAMLConnectorV2List.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorV2List from a DataView
        static decode(view: DataView): SAMLConnectorV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.SAMLConnectors.push(
                            types.SAMLConnectorV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {
                const messageSize = this.SAMLConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorV2List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorV2List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {
                const messageSize = this.SAMLConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.SAMLConnectors[n].encode(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorV2List
    } // SAMLConnectorV2List

    export class SAMLConnectorSpecV2 {
        public Issuer: string = "";
        public SSO: string = "";
        public Cert: string = "";
        public Display: string = "";
        public AssertionConsumerService: string = "";
        public Audience: string = "";
        public ServiceProviderIssuer: string = "";
        public EntityDescriptor: string = "";
        public EntityDescriptorURL: string = "";
        public AttributesToRoles: Array<types.AttributeMapping> =
            new Array<types.AttributeMapping>();
        public SigningKeyPair: types.AsymmetricKeyPair =
            new types.AsymmetricKeyPair();
        public Provider: string = "";
        public EncryptionKeyPair: types.AsymmetricKeyPair =
            new types.AsymmetricKeyPair();

        // Decodes SAMLConnectorSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorSpecV2 {
            return SAMLConnectorSpecV2.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorSpecV2 from a DataView
        static decode(view: DataView): SAMLConnectorSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Issuer = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SSO = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Cert = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Display = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AssertionConsumerService = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Audience = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ServiceProviderIssuer = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.EntityDescriptor = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.EntityDescriptorURL = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.AttributesToRoles.push(
                            types.AttributeMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.SigningKeyPair = types.AsymmetricKeyPair.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        obj.Provider = decoder.string();
                        break;
                    }
                    case 13: {
                        const length = decoder.uint32();
                        obj.EncryptionKeyPair = types.AsymmetricKeyPair.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Issuer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Issuer.length) +
                      this.Issuer.length
                    : 0;
            size +=
                this.SSO.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SSO.length) +
                      this.SSO.length
                    : 0;
            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;
            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;
            size +=
                this.AssertionConsumerService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.AssertionConsumerService.length
                      ) +
                      this.AssertionConsumerService.length
                    : 0;
            size +=
                this.Audience.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Audience.length) +
                      this.Audience.length
                    : 0;
            size +=
                this.ServiceProviderIssuer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.ServiceProviderIssuer.length
                      ) +
                      this.ServiceProviderIssuer.length
                    : 0;
            size +=
                this.EntityDescriptor.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EntityDescriptor.length) +
                      this.EntityDescriptor.length
                    : 0;
            size +=
                this.EntityDescriptorURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EntityDescriptorURL.length) +
                      this.EntityDescriptorURL.length
                    : 0;

            for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {
                const messageSize = this.AttributesToRoles[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SigningKeyPair != null) {
                const f: types.AsymmetricKeyPair = this
                    .SigningKeyPair as types.AsymmetricKeyPair;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Provider.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Provider.length) +
                      this.Provider.length
                    : 0;

            if (this.EncryptionKeyPair != null) {
                const f: types.AsymmetricKeyPair = this
                    .EncryptionKeyPair as types.AsymmetricKeyPair;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Issuer.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Issuer.length);
                encoder.string(this.Issuer);
            }
            if (this.SSO.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SSO.length);
                encoder.string(this.SSO);
            }
            if (this.Cert.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Cert.length);
                encoder.string(this.Cert);
            }
            if (this.Display.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }
            if (this.AssertionConsumerService.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.AssertionConsumerService.length);
                encoder.string(this.AssertionConsumerService);
            }
            if (this.Audience.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Audience.length);
                encoder.string(this.Audience);
            }
            if (this.ServiceProviderIssuer.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ServiceProviderIssuer.length);
                encoder.string(this.ServiceProviderIssuer);
            }
            if (this.EntityDescriptor.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.EntityDescriptor.length);
                encoder.string(this.EntityDescriptor);
            }
            if (this.EntityDescriptorURL.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.EntityDescriptorURL.length);
                encoder.string(this.EntityDescriptorURL);
            }

            for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {
                const messageSize = this.AttributesToRoles[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    this.AttributesToRoles[n].encode(encoder);
                }
            }

            if (this.SigningKeyPair != null) {
                const f = this.SigningKeyPair as types.AsymmetricKeyPair;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Provider.length > 0) {
                encoder.uint32(0x62);
                encoder.uint32(this.Provider.length);
                encoder.string(this.Provider);
            }

            if (this.EncryptionKeyPair != null) {
                const f = this.EncryptionKeyPair as types.AsymmetricKeyPair;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x6a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorSpecV2
    } // SAMLConnectorSpecV2

    export class AttributeMapping {
        public Name: string = "";
        public Value: string = "";
        public Roles: Array<string> = new Array<string>();

        // Decodes AttributeMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AttributeMapping {
            return AttributeMapping.decode(new DataView(buf));
        }

        // Decodes AttributeMapping from a DataView
        static decode(view: DataView): AttributeMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new AttributeMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Value = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Roles.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AttributeMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Value.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Value.length) +
                      this.Value.length
                    : 0;

            size += __size_string_repeated(this.Roles);

            return size;
        }

        // Encodes AttributeMapping to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AttributeMapping to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Value.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Value.length);
                encoder.string(this.Value);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            return buf;
        } // encode AttributeMapping
    } // AttributeMapping

    export class AsymmetricKeyPair {
        public PrivateKey: string = "";
        public Cert: string = "";

        // Decodes AsymmetricKeyPair from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AsymmetricKeyPair {
            return AsymmetricKeyPair.decode(new DataView(buf));
        }

        // Decodes AsymmetricKeyPair from a DataView
        static decode(view: DataView): AsymmetricKeyPair {
            const decoder = new __proto.Decoder(view);
            const obj = new AsymmetricKeyPair();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PrivateKey = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Cert = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AsymmetricKeyPair

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.PrivateKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PrivateKey.length) +
                      this.PrivateKey.length
                    : 0;
            size +=
                this.Cert.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Cert.length) +
                      this.Cert.length
                    : 0;

            return size;
        }

        // Encodes AsymmetricKeyPair to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AsymmetricKeyPair to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PrivateKey.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.PrivateKey.length);
                encoder.string(this.PrivateKey);
            }
            if (this.Cert.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Cert.length);
                encoder.string(this.Cert);
            }

            return buf;
        } // encode AsymmetricKeyPair
    } // AsymmetricKeyPair

    export class GithubConnectorV3 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.GithubConnectorSpecV3 =
            new types.GithubConnectorSpecV3();

        // Decodes GithubConnectorV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorV3 {
            return GithubConnectorV3.decode(new DataView(buf));
        }

        // Decodes GithubConnectorV3 from a DataView
        static decode(view: DataView): GithubConnectorV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.GithubConnectorSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.GithubConnectorSpecV3 = this
                    .Spec as types.GithubConnectorSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.GithubConnectorSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorV3
    } // GithubConnectorV3

    export class GithubConnectorV3List {
        public GithubConnectors: Array<types.GithubConnectorV3> =
            new Array<types.GithubConnectorV3>();

        // Decodes GithubConnectorV3List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorV3List {
            return GithubConnectorV3List.decode(new DataView(buf));
        }

        // Decodes GithubConnectorV3List from a DataView
        static decode(view: DataView): GithubConnectorV3List {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorV3List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.GithubConnectors.push(
                            types.GithubConnectorV3.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorV3List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {
                const messageSize = this.GithubConnectors[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorV3List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorV3List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {
                const messageSize = this.GithubConnectors[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.GithubConnectors[n].encode(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorV3List
    } // GithubConnectorV3List

    export class GithubConnectorSpecV3 {
        public ClientID: string = "";
        public ClientSecret: string = "";
        public RedirectURL: string = "";
        public TeamsToLogins: Array<types.TeamMapping> =
            new Array<types.TeamMapping>();
        public Display: string = "";

        // Decodes GithubConnectorSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorSpecV3 {
            return GithubConnectorSpecV3.decode(new DataView(buf));
        }

        // Decodes GithubConnectorSpecV3 from a DataView
        static decode(view: DataView): GithubConnectorSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ClientID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ClientSecret = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.RedirectURL = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.TeamsToLogins.push(
                            types.TeamMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Display = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ClientID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientID.length) +
                      this.ClientID.length
                    : 0;
            size +=
                this.ClientSecret.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClientSecret.length) +
                      this.ClientSecret.length
                    : 0;
            size +=
                this.RedirectURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RedirectURL.length) +
                      this.RedirectURL.length
                    : 0;

            for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {
                const messageSize = this.TeamsToLogins[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Display.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Display.length) +
                      this.Display.length
                    : 0;

            return size;
        }

        // Encodes GithubConnectorSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ClientID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ClientID.length);
                encoder.string(this.ClientID);
            }
            if (this.ClientSecret.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ClientSecret.length);
                encoder.string(this.ClientSecret);
            }
            if (this.RedirectURL.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.RedirectURL.length);
                encoder.string(this.RedirectURL);
            }

            for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {
                const messageSize = this.TeamsToLogins[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    this.TeamsToLogins[n].encode(encoder);
                }
            }

            if (this.Display.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Display.length);
                encoder.string(this.Display);
            }

            return buf;
        } // encode GithubConnectorSpecV3
    } // GithubConnectorSpecV3

    export class TeamMapping {
        public Organization: string = "";
        public Team: string = "";
        public Logins: Array<string> = new Array<string>();
        public KubeGroups: Array<string> = new Array<string>();
        public KubeUsers: Array<string> = new Array<string>();

        // Decodes TeamMapping from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TeamMapping {
            return TeamMapping.decode(new DataView(buf));
        }

        // Decodes TeamMapping from a DataView
        static decode(view: DataView): TeamMapping {
            const decoder = new __proto.Decoder(view);
            const obj = new TeamMapping();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Organization = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Team = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Logins.push(decoder.string());
                        break;
                    }
                    case 4: {
                        obj.KubeGroups.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.KubeUsers.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TeamMapping

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Organization.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Organization.length) +
                      this.Organization.length
                    : 0;
            size +=
                this.Team.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Team.length) +
                      this.Team.length
                    : 0;

            size += __size_string_repeated(this.Logins);

            size += __size_string_repeated(this.KubeGroups);

            size += __size_string_repeated(this.KubeUsers);

            return size;
        }

        // Encodes TeamMapping to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TeamMapping to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Organization.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Organization.length);
                encoder.string(this.Organization);
            }
            if (this.Team.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Team.length);
                encoder.string(this.Team);
            }

            if (this.Logins.length > 0) {
                for (let n: i32 = 0; n < this.Logins.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.Logins[n].length);
                    encoder.string(this.Logins[n]);
                }
            }

            if (this.KubeGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubeGroups.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.KubeGroups[n].length);
                    encoder.string(this.KubeGroups[n]);
                }
            }

            if (this.KubeUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubeUsers.length; n++) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.KubeUsers[n].length);
                    encoder.string(this.KubeUsers[n]);
                }
            }

            return buf;
        } // encode TeamMapping
    } // TeamMapping

    export class TrustedClusterV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.TrustedClusterSpecV2 =
            new types.TrustedClusterSpecV2();

        // Decodes TrustedClusterV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterV2 {
            return TrustedClusterV2.decode(new DataView(buf));
        }

        // Decodes TrustedClusterV2 from a DataView
        static decode(view: DataView): TrustedClusterV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.TrustedClusterSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.TrustedClusterSpecV2 = this
                    .Spec as types.TrustedClusterSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.TrustedClusterSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterV2
    } // TrustedClusterV2

    export class TrustedClusterV2List {
        public TrustedClusters: Array<types.TrustedClusterV2> =
            new Array<types.TrustedClusterV2>();

        // Decodes TrustedClusterV2List from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterV2List {
            return TrustedClusterV2List.decode(new DataView(buf));
        }

        // Decodes TrustedClusterV2List from a DataView
        static decode(view: DataView): TrustedClusterV2List {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterV2List();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.TrustedClusters.push(
                            types.TrustedClusterV2.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterV2List

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {
                const messageSize = this.TrustedClusters[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterV2List to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterV2List to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {
                const messageSize = this.TrustedClusters[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.TrustedClusters[n].encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterV2List
    } // TrustedClusterV2List

    export class TrustedClusterSpecV2 {
        public Enabled: bool;
        public Roles: Array<string> = new Array<string>();
        public Token: string = "";
        public ProxyAddress: string = "";
        public ReverseTunnelAddress: string = "";
        public RoleMap: Array<types.RoleMapping> =
            new Array<types.RoleMapping>();

        // Decodes TrustedClusterSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterSpecV2 {
            return TrustedClusterSpecV2.decode(new DataView(buf));
        }

        // Decodes TrustedClusterSpecV2 from a DataView
        static decode(view: DataView): TrustedClusterSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Enabled = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.Token = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.ProxyAddress = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.ReverseTunnelAddress = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.RoleMap.push(
                            types.RoleMapping.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterSpecV2

        public size(): u32 {
            let size: u32 = 0;

            size += this.Enabled == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.Roles);

            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;
            size +=
                this.ProxyAddress.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProxyAddress.length) +
                      this.ProxyAddress.length
                    : 0;
            size +=
                this.ReverseTunnelAddress.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ReverseTunnelAddress.length) +
                      this.ReverseTunnelAddress.length
                    : 0;

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Enabled != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Enabled);
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Token.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }
            if (this.ProxyAddress.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.ProxyAddress.length);
                encoder.string(this.ProxyAddress);
            }
            if (this.ReverseTunnelAddress.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.ReverseTunnelAddress.length);
                encoder.string(this.ReverseTunnelAddress);
            }

            for (let n: i32 = 0; n < this.RoleMap.length; n++) {
                const messageSize = this.RoleMap[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    this.RoleMap[n].encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterSpecV2
    } // TrustedClusterSpecV2

    export class LockV2 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.LockSpecV2 = new types.LockSpecV2();

        // Decodes LockV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockV2 {
            return LockV2.decode(new DataView(buf));
        }

        // Decodes LockV2 from a DataView
        static decode(view: DataView): LockV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new LockV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.LockSpecV2.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockV2

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.LockSpecV2 = this.Spec as types.LockSpecV2;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.LockSpecV2;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LockV2
    } // LockV2

    export class LockSpecV2 {
        public Target: types.LockTarget = new types.LockTarget();
        public Message: string = "";
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes LockSpecV2 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockSpecV2 {
            return LockSpecV2.decode(new DataView(buf));
        }

        // Decodes LockSpecV2 from a DataView
        static decode(view: DataView): LockSpecV2 {
            const decoder = new __proto.Decoder(view);
            const obj = new LockSpecV2();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Target = types.LockTarget.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.Message = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockSpecV2

        public size(): u32 {
            let size: u32 = 0;

            if (this.Target != null) {
                const f: types.LockTarget = this.Target as types.LockTarget;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Message.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Message.length) +
                      this.Message.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockSpecV2 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockSpecV2 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Target != null) {
                const f = this.Target as types.LockTarget;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Message.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Message.length);
                encoder.string(this.Message);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LockSpecV2
    } // LockSpecV2

    export class LockTarget {
        public User: string = "";
        public Role: string = "";
        public Login: string = "";
        public Node: string = "";
        public MFADevice: string = "";

        // Decodes LockTarget from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockTarget {
            return LockTarget.decode(new DataView(buf));
        }

        // Decodes LockTarget from a DataView
        static decode(view: DataView): LockTarget {
            const decoder = new __proto.Decoder(view);
            const obj = new LockTarget();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Role = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Login = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Node = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.MFADevice = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockTarget

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Role.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Role.length) +
                      this.Role.length
                    : 0;
            size +=
                this.Login.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Login.length) +
                      this.Login.length
                    : 0;
            size +=
                this.Node.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Node.length) +
                      this.Node.length
                    : 0;
            size +=
                this.MFADevice.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.MFADevice.length) +
                      this.MFADevice.length
                    : 0;

            return size;
        }

        // Encodes LockTarget to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockTarget to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Role.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Role.length);
                encoder.string(this.Role);
            }
            if (this.Login.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Login.length);
                encoder.string(this.Login);
            }
            if (this.Node.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Node.length);
                encoder.string(this.Node);
            }
            if (this.MFADevice.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.MFADevice.length);
                encoder.string(this.MFADevice);
            }

            return buf;
        } // encode LockTarget
    } // LockTarget

    export class AddressCondition {
        public CIDR: string = "";

        // Decodes AddressCondition from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AddressCondition {
            return AddressCondition.decode(new DataView(buf));
        }

        // Decodes AddressCondition from a DataView
        static decode(view: DataView): AddressCondition {
            const decoder = new __proto.Decoder(view);
            const obj = new AddressCondition();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.CIDR = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AddressCondition

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.CIDR.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.CIDR.length) +
                      this.CIDR.length
                    : 0;

            return size;
        }

        // Encodes AddressCondition to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AddressCondition to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.CIDR.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.CIDR.length);
                encoder.string(this.CIDR);
            }

            return buf;
        } // encode AddressCondition
    } // AddressCondition

    export class NetworkRestrictionsSpecV4 {
        public Allow: Array<types.AddressCondition> =
            new Array<types.AddressCondition>();
        public Deny: Array<types.AddressCondition> =
            new Array<types.AddressCondition>();

        // Decodes NetworkRestrictionsSpecV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NetworkRestrictionsSpecV4 {
            return NetworkRestrictionsSpecV4.decode(new DataView(buf));
        }

        // Decodes NetworkRestrictionsSpecV4 from a DataView
        static decode(view: DataView): NetworkRestrictionsSpecV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new NetworkRestrictionsSpecV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Allow.push(
                            types.AddressCondition.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Deny.push(
                            types.AddressCondition.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NetworkRestrictionsSpecV4

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            for (let n: i32 = 0; n < this.Deny.length; n++) {
                const messageSize = this.Deny[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes NetworkRestrictionsSpecV4 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NetworkRestrictionsSpecV4 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Allow.length; n++) {
                const messageSize = this.Allow[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Allow[n].encode(encoder);
                }
            }

            for (let n: i32 = 0; n < this.Deny.length; n++) {
                const messageSize = this.Deny[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    this.Deny[n].encode(encoder);
                }
            }

            return buf;
        } // encode NetworkRestrictionsSpecV4
    } // NetworkRestrictionsSpecV4

    export class NetworkRestrictionsV4 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.NetworkRestrictionsSpecV4 =
            new types.NetworkRestrictionsSpecV4();

        // Decodes NetworkRestrictionsV4 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): NetworkRestrictionsV4 {
            return NetworkRestrictionsV4.decode(new DataView(buf));
        }

        // Decodes NetworkRestrictionsV4 from a DataView
        static decode(view: DataView): NetworkRestrictionsV4 {
            const decoder = new __proto.Decoder(view);
            const obj = new NetworkRestrictionsV4();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.NetworkRestrictionsSpecV4.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode NetworkRestrictionsV4

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.NetworkRestrictionsSpecV4 = this
                    .Spec as types.NetworkRestrictionsSpecV4;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes NetworkRestrictionsV4 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes NetworkRestrictionsV4 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.NetworkRestrictionsSpecV4;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode NetworkRestrictionsV4
    } // NetworkRestrictionsV4

    export class WindowsDesktopServiceV3 {
        public Header: types.ResourceHeader = new types.ResourceHeader();
        public Spec: types.WindowsDesktopServiceSpecV3 =
            new types.WindowsDesktopServiceSpecV3();

        // Decodes WindowsDesktopServiceV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopServiceV3 {
            return WindowsDesktopServiceV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopServiceV3 from a DataView
        static decode(view: DataView): WindowsDesktopServiceV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopServiceV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Header = types.ResourceHeader.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Spec = types.WindowsDesktopServiceSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopServiceV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Header != null) {
                const f: types.ResourceHeader = this
                    .Header as types.ResourceHeader;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WindowsDesktopServiceSpecV3 = this
                    .Spec as types.WindowsDesktopServiceSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WindowsDesktopServiceV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopServiceV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Header != null) {
                const f = this.Header as types.ResourceHeader;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WindowsDesktopServiceSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode WindowsDesktopServiceV3
    } // WindowsDesktopServiceV3

    export class WindowsDesktopServiceSpecV3 {
        public Addr: string = "";
        public TeleportVersion: string = "";

        // Decodes WindowsDesktopServiceSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(
            buf: ArrayBuffer
        ): WindowsDesktopServiceSpecV3 {
            return WindowsDesktopServiceSpecV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopServiceSpecV3 from a DataView
        static decode(view: DataView): WindowsDesktopServiceSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopServiceSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.TeleportVersion = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopServiceSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.TeleportVersion.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TeleportVersion.length) +
                      this.TeleportVersion.length
                    : 0;

            return size;
        }

        // Encodes WindowsDesktopServiceSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopServiceSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.TeleportVersion.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.TeleportVersion.length);
                encoder.string(this.TeleportVersion);
            }

            return buf;
        } // encode WindowsDesktopServiceSpecV3
    } // WindowsDesktopServiceSpecV3

    export class WindowsDesktopV3 {
        public Header: types.ResourceHeader = new types.ResourceHeader();
        public Spec: types.WindowsDesktopSpecV3 =
            new types.WindowsDesktopSpecV3();

        // Decodes WindowsDesktopV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopV3 {
            return WindowsDesktopV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopV3 from a DataView
        static decode(view: DataView): WindowsDesktopV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Header = types.ResourceHeader.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Spec = types.WindowsDesktopSpecV3.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopV3

        public size(): u32 {
            let size: u32 = 0;

            if (this.Header != null) {
                const f: types.ResourceHeader = this
                    .Header as types.ResourceHeader;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.WindowsDesktopSpecV3 = this
                    .Spec as types.WindowsDesktopSpecV3;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes WindowsDesktopV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Header != null) {
                const f = this.Header as types.ResourceHeader;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.WindowsDesktopSpecV3;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode WindowsDesktopV3
    } // WindowsDesktopV3

    export class WindowsDesktopSpecV3 {
        public Addr: string = "";
        public Domain: string = "";

        // Decodes WindowsDesktopSpecV3 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSpecV3 {
            return WindowsDesktopSpecV3.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSpecV3 from a DataView
        static decode(view: DataView): WindowsDesktopSpecV3 {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSpecV3();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Addr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Domain = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSpecV3

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;

            return size;
        }

        // Encodes WindowsDesktopSpecV3 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSpecV3 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Addr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }

            return buf;
        } // encode WindowsDesktopSpecV3
    } // WindowsDesktopSpecV3

    export class RegisterUsingTokenRequest {
        public HostID: string = "";
        public NodeName: string = "";
        public Role: string = "";
        public Token: string = "";
        public AdditionalPrincipals: Array<string> = new Array<string>();
        public DNSNames: Array<string> = new Array<string>();
        public PublicTLSKey: Array<u8> = new Array<u8>();
        public PublicSSHKey: Array<u8> = new Array<u8>();
        public RemoteAddr: string = "";
        public EC2IdentityDocument: Array<u8> = new Array<u8>();

        // Decodes RegisterUsingTokenRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RegisterUsingTokenRequest {
            return RegisterUsingTokenRequest.decode(new DataView(buf));
        }

        // Decodes RegisterUsingTokenRequest from a DataView
        static decode(view: DataView): RegisterUsingTokenRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new RegisterUsingTokenRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.HostID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.NodeName = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Role = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Token = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.AdditionalPrincipals.push(decoder.string());
                        break;
                    }
                    case 6: {
                        obj.DNSNames.push(decoder.string());
                        break;
                    }
                    case 7: {
                        obj.PublicTLSKey = decoder.bytes();
                        break;
                    }
                    case 8: {
                        obj.PublicSSHKey = decoder.bytes();
                        break;
                    }
                    case 9: {
                        obj.RemoteAddr = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.EC2IdentityDocument = decoder.bytes();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RegisterUsingTokenRequest

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.HostID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HostID.length) +
                      this.HostID.length
                    : 0;
            size +=
                this.NodeName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.NodeName.length) +
                      this.NodeName.length
                    : 0;
            size +=
                this.Role.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Role.length) +
                      this.Role.length
                    : 0;
            size +=
                this.Token.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Token.length) +
                      this.Token.length
                    : 0;

            size += __size_string_repeated(this.AdditionalPrincipals);

            size += __size_string_repeated(this.DNSNames);

            size +=
                this.PublicTLSKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicTLSKey.length) +
                      this.PublicTLSKey.length
                    : 0;
            size +=
                this.PublicSSHKey.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicSSHKey.length) +
                      this.PublicSSHKey.length
                    : 0;
            size +=
                this.RemoteAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RemoteAddr.length) +
                      this.RemoteAddr.length
                    : 0;
            size +=
                this.EC2IdentityDocument.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.EC2IdentityDocument.length) +
                      this.EC2IdentityDocument.length
                    : 0;

            return size;
        }

        // Encodes RegisterUsingTokenRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RegisterUsingTokenRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.HostID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.HostID.length);
                encoder.string(this.HostID);
            }
            if (this.NodeName.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.NodeName.length);
                encoder.string(this.NodeName);
            }
            if (this.Role.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Role.length);
                encoder.string(this.Role);
            }
            if (this.Token.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Token.length);
                encoder.string(this.Token);
            }

            if (this.AdditionalPrincipals.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.AdditionalPrincipals.length;
                    n++
                ) {
                    encoder.uint32(0x2a);
                    encoder.uint32(this.AdditionalPrincipals[n].length);
                    encoder.string(this.AdditionalPrincipals[n]);
                }
            }

            if (this.DNSNames.length > 0) {
                for (let n: i32 = 0; n < this.DNSNames.length; n++) {
                    encoder.uint32(0x32);
                    encoder.uint32(this.DNSNames[n].length);
                    encoder.string(this.DNSNames[n]);
                }
            }

            if (this.PublicTLSKey.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.PublicTLSKey.length);
                encoder.bytes(this.PublicTLSKey);
            }
            if (this.PublicSSHKey.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.PublicSSHKey.length);
                encoder.bytes(this.PublicSSHKey);
            }
            if (this.RemoteAddr.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.RemoteAddr.length);
                encoder.string(this.RemoteAddr);
            }
            if (this.EC2IdentityDocument.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.EC2IdentityDocument.length);
                encoder.bytes(this.EC2IdentityDocument);
            }

            return buf;
        } // encode RegisterUsingTokenRequest
    } // RegisterUsingTokenRequest

    export class RecoveryCodesV1 {
        public Kind: string = "";
        public SubKind: string = "";
        public Version: string = "";
        public Metadata: types.Metadata = new types.Metadata();
        public Spec: types.RecoveryCodesSpecV1 =
            new types.RecoveryCodesSpecV1();

        // Decodes RecoveryCodesV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodesV1 {
            return RecoveryCodesV1.decode(new DataView(buf));
        }

        // Decodes RecoveryCodesV1 from a DataView
        static decode(view: DataView): RecoveryCodesV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodesV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Kind = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.SubKind = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Version = decoder.string();
                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Metadata = types.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Spec = types.RecoveryCodesSpecV1.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodesV1

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Kind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Kind.length) +
                      this.Kind.length
                    : 0;
            size +=
                this.SubKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SubKind.length) +
                      this.SubKind.length
                    : 0;
            size +=
                this.Version.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Version.length) +
                      this.Version.length
                    : 0;

            if (this.Metadata != null) {
                const f: types.Metadata = this.Metadata as types.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Spec != null) {
                const f: types.RecoveryCodesSpecV1 = this
                    .Spec as types.RecoveryCodesSpecV1;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodesV1 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodesV1 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Kind.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Kind.length);
                encoder.string(this.Kind);
            }
            if (this.SubKind.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.SubKind.length);
                encoder.string(this.SubKind);
            }
            if (this.Version.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Version.length);
                encoder.string(this.Version);
            }

            if (this.Metadata != null) {
                const f = this.Metadata as types.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Spec != null) {
                const f = this.Spec as types.RecoveryCodesSpecV1;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodesV1
    } // RecoveryCodesV1

    export class RecoveryCodesSpecV1 {
        public Codes: Array<types.RecoveryCode> =
            new Array<types.RecoveryCode>();
        public Created: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes RecoveryCodesSpecV1 from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodesSpecV1 {
            return RecoveryCodesSpecV1.decode(new DataView(buf));
        }

        // Decodes RecoveryCodesSpecV1 from a DataView
        static decode(view: DataView): RecoveryCodesSpecV1 {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodesSpecV1();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Codes.push(
                            types.RecoveryCode.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Created = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodesSpecV1

        public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.Codes.length; n++) {
                const messageSize = this.Codes[n].size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Created != null) {
                const f: google.protobuf.Timestamp = this
                    .Created as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodesSpecV1 to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodesSpecV1 to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.Codes.length; n++) {
                const messageSize = this.Codes[n].size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    this.Codes[n].encode(encoder);
                }
            }

            if (this.Created != null) {
                const f = this.Created as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodesSpecV1
    } // RecoveryCodesSpecV1

    export class RecoveryCode {
        public HashedCode: Array<u8> = new Array<u8>();
        public IsUsed: bool;

        // Decodes RecoveryCode from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCode {
            return RecoveryCode.decode(new DataView(buf));
        }

        // Decodes RecoveryCode from a DataView
        static decode(view: DataView): RecoveryCode {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCode();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.HashedCode = decoder.bytes();
                        break;
                    }
                    case 2: {
                        obj.IsUsed = decoder.bool();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCode

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.HashedCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.HashedCode.length) +
                      this.HashedCode.length
                    : 0;
            size += this.IsUsed == 0 ? 0 : 1 + 1;

            return size;
        }

        // Encodes RecoveryCode to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCode to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.HashedCode.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.HashedCode.length);
                encoder.bytes(this.HashedCode);
            }
            if (this.IsUsed != 0) {
                encoder.uint32(0x10);
                encoder.bool(this.IsUsed);
            }

            return buf;
        } // encode RecoveryCode
    } // RecoveryCode
} // types
export namespace events {
    export enum EventAction {
        OBSERVED = 0,
        DENIED = 1,
    } // EventAction
    export class Metadata {
        public Index: i64;
        public Type: string = "";
        public ID: string = "";
        public Code: string = "";
        public Time: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public ClusterName: string = "";

        // Decodes Metadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Metadata {
            return Metadata.decode(new DataView(buf));
        }

        // Decodes Metadata from a DataView
        static decode(view: DataView): Metadata {
            const decoder = new __proto.Decoder(view);
            const obj = new Metadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Index = decoder.int64();
                        break;
                    }
                    case 2: {
                        obj.Type = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ID = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.Code = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Time = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.ClusterName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Metadata

        public size(): u32 {
            let size: u32 = 0;

            size += this.Index == 0 ? 0 : 1 + __proto.Sizer.int64(this.Index);
            size +=
                this.Type.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Type.length) +
                      this.Type.length
                    : 0;
            size +=
                this.ID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ID.length) +
                      this.ID.length
                    : 0;
            size +=
                this.Code.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Code.length) +
                      this.Code.length
                    : 0;

            if (this.Time != null) {
                const f: google.protobuf.Timestamp = this
                    .Time as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.ClusterName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ClusterName.length) +
                      this.ClusterName.length
                    : 0;

            return size;
        }

        // Encodes Metadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Metadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Index != 0) {
                encoder.uint32(0x8);
                encoder.int64(this.Index);
            }
            if (this.Type.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Type.length);
                encoder.string(this.Type);
            }
            if (this.ID.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ID.length);
                encoder.string(this.ID);
            }
            if (this.Code.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Code.length);
                encoder.string(this.Code);
            }

            if (this.Time != null) {
                const f = this.Time as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ClusterName.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.ClusterName.length);
                encoder.string(this.ClusterName);
            }

            return buf;
        } // encode Metadata
    } // Metadata

    export class SessionMetadata {
        public SessionID: string = "";
        public WithMFA: string = "";

        // Decodes SessionMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionMetadata {
            return SessionMetadata.decode(new DataView(buf));
        }

        // Decodes SessionMetadata from a DataView
        static decode(view: DataView): SessionMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.SessionID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.WithMFA = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.SessionID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionID.length) +
                      this.SessionID.length
                    : 0;
            size +=
                this.WithMFA.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WithMFA.length) +
                      this.WithMFA.length
                    : 0;

            return size;
        }

        // Encodes SessionMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.SessionID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.SessionID.length);
                encoder.string(this.SessionID);
            }
            if (this.WithMFA.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.WithMFA.length);
                encoder.string(this.WithMFA);
            }

            return buf;
        } // encode SessionMetadata
    } // SessionMetadata

    export class UserMetadata {
        public User: string = "";
        public Login: string = "";
        public Impersonator: string = "";
        public AWSRoleARN: string = "";

        // Decodes UserMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserMetadata {
            return UserMetadata.decode(new DataView(buf));
        }

        // Decodes UserMetadata from a DataView
        static decode(view: DataView): UserMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new UserMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.User = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.Login = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Impersonator = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.AWSRoleARN = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.User.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.User.length) +
                      this.User.length
                    : 0;
            size +=
                this.Login.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Login.length) +
                      this.Login.length
                    : 0;
            size +=
                this.Impersonator.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Impersonator.length) +
                      this.Impersonator.length
                    : 0;
            size +=
                this.AWSRoleARN.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AWSRoleARN.length) +
                      this.AWSRoleARN.length
                    : 0;

            return size;
        }

        // Encodes UserMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.User.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.User.length);
                encoder.string(this.User);
            }
            if (this.Login.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Login.length);
                encoder.string(this.Login);
            }
            if (this.Impersonator.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Impersonator.length);
                encoder.string(this.Impersonator);
            }
            if (this.AWSRoleARN.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.AWSRoleARN.length);
                encoder.string(this.AWSRoleARN);
            }

            return buf;
        } // encode UserMetadata
    } // UserMetadata

    export class ServerMetadata {
        public ServerNamespace: string = "";
        public ServerID: string = "";
        public ServerHostname: string = "";
        public ServerAddr: string = "";
        public ServerLabels: Map<string, string> = new Map<string, string>();

        // Decodes ServerMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ServerMetadata {
            return ServerMetadata.decode(new DataView(buf));
        }

        // Decodes ServerMetadata from a DataView
        static decode(view: DataView): ServerMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ServerMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.ServerNamespace = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ServerID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.ServerHostname = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.ServerAddr = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.ServerLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ServerMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.ServerNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerNamespace.length) +
                      this.ServerNamespace.length
                    : 0;
            size +=
                this.ServerID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerID.length) +
                      this.ServerID.length
                    : 0;
            size +=
                this.ServerHostname.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerHostname.length) +
                      this.ServerHostname.length
                    : 0;
            size +=
                this.ServerAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ServerAddr.length) +
                      this.ServerAddr.length
                    : 0;

            if (this.ServerLabels.size > 0) {
                const keys = this.ServerLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.ServerLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes ServerMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ServerMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.ServerNamespace.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.ServerNamespace.length);
                encoder.string(this.ServerNamespace);
            }
            if (this.ServerID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ServerID.length);
                encoder.string(this.ServerID);
            }
            if (this.ServerHostname.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.ServerHostname.length);
                encoder.string(this.ServerHostname);
            }
            if (this.ServerAddr.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.ServerAddr.length);
                encoder.string(this.ServerAddr);
            }

            if (this.ServerLabels.size > 0) {
                const keys = this.ServerLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.ServerLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x2a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode ServerMetadata
    } // ServerMetadata

    export class ConnectionMetadata {
        public LocalAddr: string = "";
        public RemoteAddr: string = "";
        public Protocol: string = "";

        // Decodes ConnectionMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ConnectionMetadata {
            return ConnectionMetadata.decode(new DataView(buf));
        }

        // Decodes ConnectionMetadata from a DataView
        static decode(view: DataView): ConnectionMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ConnectionMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.LocalAddr = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.RemoteAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Protocol = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ConnectionMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.LocalAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.LocalAddr.length) +
                      this.LocalAddr.length
                    : 0;
            size +=
                this.RemoteAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RemoteAddr.length) +
                      this.RemoteAddr.length
                    : 0;
            size +=
                this.Protocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Protocol.length) +
                      this.Protocol.length
                    : 0;

            return size;
        }

        // Encodes ConnectionMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ConnectionMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.LocalAddr.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.LocalAddr.length);
                encoder.string(this.LocalAddr);
            }
            if (this.RemoteAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.RemoteAddr.length);
                encoder.string(this.RemoteAddr);
            }
            if (this.Protocol.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Protocol.length);
                encoder.string(this.Protocol);
            }

            return buf;
        } // encode ConnectionMetadata
    } // ConnectionMetadata

    export class KubernetesClusterMetadata {
        public KubernetesCluster: string = "";
        public KubernetesUsers: Array<string> = new Array<string>();
        public KubernetesGroups: Array<string> = new Array<string>();

        // Decodes KubernetesClusterMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesClusterMetadata {
            return KubernetesClusterMetadata.decode(new DataView(buf));
        }

        // Decodes KubernetesClusterMetadata from a DataView
        static decode(view: DataView): KubernetesClusterMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesClusterMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.KubernetesCluster = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.KubernetesUsers.push(decoder.string());
                        break;
                    }
                    case 3: {
                        obj.KubernetesGroups.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesClusterMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.KubernetesCluster.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesCluster.length) +
                      this.KubernetesCluster.length
                    : 0;

            size += __size_string_repeated(this.KubernetesUsers);

            size += __size_string_repeated(this.KubernetesGroups);

            return size;
        }

        // Encodes KubernetesClusterMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesClusterMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.KubernetesCluster.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.KubernetesCluster.length);
                encoder.string(this.KubernetesCluster);
            }

            if (this.KubernetesUsers.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesUsers.length; n++) {
                    encoder.uint32(0x12);
                    encoder.uint32(this.KubernetesUsers[n].length);
                    encoder.string(this.KubernetesUsers[n]);
                }
            }

            if (this.KubernetesGroups.length > 0) {
                for (let n: i32 = 0; n < this.KubernetesGroups.length; n++) {
                    encoder.uint32(0x1a);
                    encoder.uint32(this.KubernetesGroups[n].length);
                    encoder.string(this.KubernetesGroups[n]);
                }
            }

            return buf;
        } // encode KubernetesClusterMetadata
    } // KubernetesClusterMetadata

    export class KubernetesPodMetadata {
        public KubernetesPodName: string = "";
        public KubernetesPodNamespace: string = "";
        public KubernetesContainerName: string = "";
        public KubernetesContainerImage: string = "";
        public KubernetesNodeName: string = "";

        // Decodes KubernetesPodMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubernetesPodMetadata {
            return KubernetesPodMetadata.decode(new DataView(buf));
        }

        // Decodes KubernetesPodMetadata from a DataView
        static decode(view: DataView): KubernetesPodMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new KubernetesPodMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.KubernetesPodName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.KubernetesPodNamespace = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.KubernetesContainerName = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.KubernetesContainerImage = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.KubernetesNodeName = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubernetesPodMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.KubernetesPodName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesPodName.length) +
                      this.KubernetesPodName.length
                    : 0;
            size +=
                this.KubernetesPodNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesPodNamespace.length
                      ) +
                      this.KubernetesPodNamespace.length
                    : 0;
            size +=
                this.KubernetesContainerName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesContainerName.length
                      ) +
                      this.KubernetesContainerName.length
                    : 0;
            size +=
                this.KubernetesContainerImage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.KubernetesContainerImage.length
                      ) +
                      this.KubernetesContainerImage.length
                    : 0;
            size +=
                this.KubernetesNodeName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.KubernetesNodeName.length) +
                      this.KubernetesNodeName.length
                    : 0;

            return size;
        }

        // Encodes KubernetesPodMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubernetesPodMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.KubernetesPodName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.KubernetesPodName.length);
                encoder.string(this.KubernetesPodName);
            }
            if (this.KubernetesPodNamespace.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.KubernetesPodNamespace.length);
                encoder.string(this.KubernetesPodNamespace);
            }
            if (this.KubernetesContainerName.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.KubernetesContainerName.length);
                encoder.string(this.KubernetesContainerName);
            }
            if (this.KubernetesContainerImage.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.KubernetesContainerImage.length);
                encoder.string(this.KubernetesContainerImage);
            }
            if (this.KubernetesNodeName.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.KubernetesNodeName.length);
                encoder.string(this.KubernetesNodeName);
            }

            return buf;
        } // encode KubernetesPodMetadata
    } // KubernetesPodMetadata

    export class SessionStart {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public TerminalSize: string = "";
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();
        public InitialCommand: Array<string> = new Array<string>();
        public SessionRecording: string = "";
        public AccessRequests: Array<string> = new Array<string>();

        // Decodes SessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionStart {
            return SessionStart.decode(new DataView(buf));
        }

        // Decodes SessionStart from a DataView
        static decode(view: DataView): SessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.TerminalSize = decoder.string();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        obj.InitialCommand.push(decoder.string());
                        break;
                    }
                    case 10: {
                        obj.SessionRecording = decoder.string();
                        break;
                    }
                    case 11: {
                        obj.AccessRequests.push(decoder.string());
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.TerminalSize.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TerminalSize.length) +
                      this.TerminalSize.length
                    : 0;

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.InitialCommand);

            size +=
                this.SessionRecording.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionRecording.length) +
                      this.SessionRecording.length
                    : 0;

            size += __size_string_repeated(this.AccessRequests);

            return size;
        }

        // Encodes SessionStart to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionStart to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.TerminalSize.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.TerminalSize.length);
                encoder.string(this.TerminalSize);
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.InitialCommand.length > 0) {
                for (let n: i32 = 0; n < this.InitialCommand.length; n++) {
                    encoder.uint32(0x4a);
                    encoder.uint32(this.InitialCommand[n].length);
                    encoder.string(this.InitialCommand[n]);
                }
            }

            if (this.SessionRecording.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.SessionRecording.length);
                encoder.string(this.SessionRecording);
            }

            if (this.AccessRequests.length > 0) {
                for (let n: i32 = 0; n < this.AccessRequests.length; n++) {
                    encoder.uint32(0x5a);
                    encoder.uint32(this.AccessRequests[n].length);
                    encoder.string(this.AccessRequests[n]);
                }
            }

            return buf;
        } // encode SessionStart
    } // SessionStart

    export class SessionJoin {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();

        // Decodes SessionJoin from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionJoin {
            return SessionJoin.decode(new DataView(buf));
        }

        // Decodes SessionJoin from a DataView
        static decode(view: DataView): SessionJoin {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionJoin();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionJoin

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionJoin to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionJoin to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SessionJoin
    } // SessionJoin

    export class SessionPrint {
        public Metadata: events.Metadata = new events.Metadata();
        public ChunkIndex: i64;
        public Data: Array<u8> = new Array<u8>();
        public Bytes: i64;
        public DelayMilliseconds: i64;
        public Offset: i64;

        // Decodes SessionPrint from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionPrint {
            return SessionPrint.decode(new DataView(buf));
        }

        // Decodes SessionPrint from a DataView
        static decode(view: DataView): SessionPrint {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionPrint();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.ChunkIndex = decoder.int64();
                        break;
                    }
                    case 3: {
                        obj.Data = decoder.bytes();
                        break;
                    }
                    case 4: {
                        obj.Bytes = decoder.int64();
                        break;
                    }
                    case 5: {
                        obj.DelayMilliseconds = decoder.int64();
                        break;
                    }
                    case 6: {
                        obj.Offset = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionPrint

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.ChunkIndex == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.ChunkIndex);
            size +=
                this.Data.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Data.length) +
                      this.Data.length
                    : 0;
            size += this.Bytes == 0 ? 0 : 1 + __proto.Sizer.int64(this.Bytes);
            size +=
                this.DelayMilliseconds == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.DelayMilliseconds);
            size += this.Offset == 0 ? 0 : 1 + __proto.Sizer.int64(this.Offset);

            return size;
        }

        // Encodes SessionPrint to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionPrint to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ChunkIndex != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.ChunkIndex);
            }
            if (this.Data.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Data.length);
                encoder.bytes(this.Data);
            }
            if (this.Bytes != 0) {
                encoder.uint32(0x20);
                encoder.int64(this.Bytes);
            }
            if (this.DelayMilliseconds != 0) {
                encoder.uint32(0x28);
                encoder.int64(this.DelayMilliseconds);
            }
            if (this.Offset != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.Offset);
            }

            return buf;
        } // encode SessionPrint
    } // SessionPrint

    export class SessionReject {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Reason: string = "";
        public Maximum: i64;

        // Decodes SessionReject from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionReject {
            return SessionReject.decode(new DataView(buf));
        }

        // Decodes SessionReject from a DataView
        static decode(view: DataView): SessionReject {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionReject();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Maximum = decoder.int64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionReject

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;
            size +=
                this.Maximum == 0 ? 0 : 1 + __proto.Sizer.int64(this.Maximum);

            return size;
        }

        // Encodes SessionReject to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionReject to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Reason.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }
            if (this.Maximum != 0) {
                encoder.uint32(0x30);
                encoder.int64(this.Maximum);
            }

            return buf;
        } // encode SessionReject
    } // SessionReject

    export class Resize {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public TerminalSize: string = "";
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();

        // Decodes Resize from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Resize {
            return Resize.decode(new DataView(buf));
        }

        // Decodes Resize from a DataView
        static decode(view: DataView): Resize {
            const decoder = new __proto.Decoder(view);
            const obj = new Resize();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.TerminalSize = decoder.string();
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Resize

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.TerminalSize.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TerminalSize.length) +
                      this.TerminalSize.length
                    : 0;

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Resize to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Resize to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.TerminalSize.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.TerminalSize.length);
                encoder.string(this.TerminalSize);
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode Resize
    } // Resize

    export class SessionEnd {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public EnhancedRecording: bool;
        public Interactive: bool;
        public Participants: Array<string> = new Array<string>();
        public StartTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public EndTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();
        public InitialCommand: Array<string> = new Array<string>();
        public SessionRecording: string = "";

        // Decodes SessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionEnd {
            return SessionEnd.decode(new DataView(buf));
        }

        // Decodes SessionEnd from a DataView
        static decode(view: DataView): SessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.EnhancedRecording = decoder.bool();
                        break;
                    }
                    case 7: {
                        obj.Interactive = decoder.bool();
                        break;
                    }
                    case 8: {
                        obj.Participants.push(decoder.string());
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.StartTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.EndTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        obj.InitialCommand.push(decoder.string());
                        break;
                    }
                    case 14: {
                        obj.SessionRecording = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.EnhancedRecording == 0 ? 0 : 1 + 1;
            size += this.Interactive == 0 ? 0 : 1 + 1;

            size += __size_string_repeated(this.Participants);

            if (this.StartTime != null) {
                const f: google.protobuf.Timestamp = this
                    .StartTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.EndTime != null) {
                const f: google.protobuf.Timestamp = this
                    .EndTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.InitialCommand);

            size +=
                this.SessionRecording.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionRecording.length) +
                      this.SessionRecording.length
                    : 0;

            return size;
        }

        // Encodes SessionEnd to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionEnd to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.EnhancedRecording != 0) {
                encoder.uint32(0x30);
                encoder.bool(this.EnhancedRecording);
            }
            if (this.Interactive != 0) {
                encoder.uint32(0x38);
                encoder.bool(this.Interactive);
            }

            if (this.Participants.length > 0) {
                for (let n: i32 = 0; n < this.Participants.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Participants[n].length);
                    encoder.string(this.Participants[n]);
                }
            }

            if (this.StartTime != null) {
                const f = this.StartTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.EndTime != null) {
                const f = this.EndTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.InitialCommand.length > 0) {
                for (let n: i32 = 0; n < this.InitialCommand.length; n++) {
                    encoder.uint32(0x6a);
                    encoder.uint32(this.InitialCommand[n].length);
                    encoder.string(this.InitialCommand[n]);
                }
            }

            if (this.SessionRecording.length > 0) {
                encoder.uint32(0x72);
                encoder.uint32(this.SessionRecording.length);
                encoder.string(this.SessionRecording);
            }

            return buf;
        } // encode SessionEnd
    } // SessionEnd

    export class BPFMetadata {
        public PID: u64;
        public CgroupID: u64;
        public Program: string = "";

        // Decodes BPFMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BPFMetadata {
            return BPFMetadata.decode(new DataView(buf));
        }

        // Decodes BPFMetadata from a DataView
        static decode(view: DataView): BPFMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new BPFMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.PID = decoder.uint64();
                        break;
                    }
                    case 2: {
                        obj.CgroupID = decoder.uint64();
                        break;
                    }
                    case 3: {
                        obj.Program = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BPFMetadata

        public size(): u32 {
            let size: u32 = 0;

            size += this.PID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PID);
            size +=
                this.CgroupID == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.CgroupID);
            size +=
                this.Program.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Program.length) +
                      this.Program.length
                    : 0;

            return size;
        }

        // Encodes BPFMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BPFMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.PID != 0) {
                encoder.uint32(0x8);
                encoder.uint64(this.PID);
            }
            if (this.CgroupID != 0) {
                encoder.uint32(0x10);
                encoder.uint64(this.CgroupID);
            }
            if (this.Program.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Program.length);
                encoder.string(this.Program);
            }

            return buf;
        } // encode BPFMetadata
    } // BPFMetadata

    export class Status {
        public Success: bool;
        public Error: string = "";
        public UserMessage: string = "";

        // Decodes Status from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Status {
            return Status.decode(new DataView(buf));
        }

        // Decodes Status from a DataView
        static decode(view: DataView): Status {
            const decoder = new __proto.Decoder(view);
            const obj = new Status();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Success = decoder.bool();
                        break;
                    }
                    case 2: {
                        obj.Error = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.UserMessage = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Status

        public size(): u32 {
            let size: u32 = 0;

            size += this.Success == 0 ? 0 : 1 + 1;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;
            size +=
                this.UserMessage.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UserMessage.length) +
                      this.UserMessage.length
                    : 0;

            return size;
        }

        // Encodes Status to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Status to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Success != 0) {
                encoder.uint32(0x8);
                encoder.bool(this.Success);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }
            if (this.UserMessage.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.UserMessage.length);
                encoder.string(this.UserMessage);
            }

            return buf;
        } // encode Status
    } // Status

    export class SessionCommand {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        public PPID: u64;
        public Path: string = "";
        public Argv: Array<string> = new Array<string>();
        public ReturnCode: i32;

        // Decodes SessionCommand from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionCommand {
            return SessionCommand.decode(new DataView(buf));
        }

        // Decodes SessionCommand from a DataView
        static decode(view: DataView): SessionCommand {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionCommand();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.PPID = decoder.uint64();
                        break;
                    }
                    case 7: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Argv.push(decoder.string());
                        break;
                    }
                    case 9: {
                        obj.ReturnCode = decoder.int32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionCommand

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += this.PPID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PPID);
            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;

            size += __size_string_repeated(this.Argv);

            size +=
                this.ReturnCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ReturnCode);

            return size;
        }

        // Encodes SessionCommand to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionCommand to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.PPID != 0) {
                encoder.uint32(0x30);
                encoder.uint64(this.PPID);
            }
            if (this.Path.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }

            if (this.Argv.length > 0) {
                for (let n: i32 = 0; n < this.Argv.length; n++) {
                    encoder.uint32(0x42);
                    encoder.uint32(this.Argv[n].length);
                    encoder.string(this.Argv[n]);
                }
            }

            if (this.ReturnCode != 0) {
                encoder.uint32(0x48);
                encoder.int32(this.ReturnCode);
            }

            return buf;
        } // encode SessionCommand
    } // SessionCommand

    export class SessionDisk {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        public Path: string = "";
        public Flags: i32;
        public ReturnCode: i32;

        // Decodes SessionDisk from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionDisk {
            return SessionDisk.decode(new DataView(buf));
        }

        // Decodes SessionDisk from a DataView
        static decode(view: DataView): SessionDisk {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionDisk();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Flags = decoder.int32();
                        break;
                    }
                    case 8: {
                        obj.ReturnCode = decoder.int32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionDisk

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size += this.Flags == 0 ? 0 : 1 + __proto.Sizer.int32(this.Flags);
            size +=
                this.ReturnCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ReturnCode);

            return size;
        }

        // Encodes SessionDisk to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionDisk to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Path.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.Flags != 0) {
                encoder.uint32(0x38);
                encoder.int32(this.Flags);
            }
            if (this.ReturnCode != 0) {
                encoder.uint32(0x40);
                encoder.int32(this.ReturnCode);
            }

            return buf;
        } // encode SessionDisk
    } // SessionDisk

    export class SessionNetwork {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public BPF: events.BPFMetadata = new events.BPFMetadata();
        public SrcAddr: string = "";
        public DstAddr: string = "";
        public DstPort: i32;
        public TCPVersion: i32;
        public Operation: u32;
        public Action: u32;

        // Decodes SessionNetwork from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionNetwork {
            return SessionNetwork.decode(new DataView(buf));
        }

        // Decodes SessionNetwork from a DataView
        static decode(view: DataView): SessionNetwork {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionNetwork();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.BPF = events.BPFMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.SrcAddr = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.DstAddr = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.DstPort = decoder.int32();
                        break;
                    }
                    case 9: {
                        obj.TCPVersion = decoder.int32();
                        break;
                    }
                    case 10: {
                        obj.Operation = decoder.uint32();
                        break;
                    }
                    case 11: {
                        obj.Action = decoder.uint32();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionNetwork

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BPF != null) {
                const f: events.BPFMetadata = this.BPF as events.BPFMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SrcAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SrcAddr.length) +
                      this.SrcAddr.length
                    : 0;
            size +=
                this.DstAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DstAddr.length) +
                      this.DstAddr.length
                    : 0;
            size +=
                this.DstPort == 0 ? 0 : 1 + __proto.Sizer.int32(this.DstPort);
            size +=
                this.TCPVersion == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.TCPVersion);
            size +=
                this.Operation == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.Operation);
            size +=
                this.Action == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Action);

            return size;
        }

        // Encodes SessionNetwork to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionNetwork to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BPF != null) {
                const f = this.BPF as events.BPFMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SrcAddr.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.SrcAddr.length);
                encoder.string(this.SrcAddr);
            }
            if (this.DstAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DstAddr.length);
                encoder.string(this.DstAddr);
            }
            if (this.DstPort != 0) {
                encoder.uint32(0x40);
                encoder.int32(this.DstPort);
            }
            if (this.TCPVersion != 0) {
                encoder.uint32(0x48);
                encoder.int32(this.TCPVersion);
            }
            if (this.Operation != 0) {
                encoder.uint32(0x50);
                encoder.uint32(this.Operation);
            }
            if (this.Action != 0) {
                encoder.uint32(0x58);
                encoder.uint32(this.Action);
            }

            return buf;
        } // encode SessionNetwork
    } // SessionNetwork

    export enum SessionNetwork_NetworkOperation {
        CONNECT = 0,
        SEND = 1,
    } // SessionNetwork_NetworkOperation
    export class SessionData {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public BytesTransmitted: u64;
        public BytesReceived: u64;

        // Decodes SessionData from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionData {
            return SessionData.decode(new DataView(buf));
        }

        // Decodes SessionData from a DataView
        static decode(view: DataView): SessionData {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionData();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.BytesTransmitted = decoder.uint64();
                        break;
                    }
                    case 7: {
                        obj.BytesReceived = decoder.uint64();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionData

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.BytesTransmitted == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.BytesTransmitted);
            size +=
                this.BytesReceived == 0
                    ? 0
                    : 1 + __proto.Sizer.uint64(this.BytesReceived);

            return size;
        }

        // Encodes SessionData to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionData to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BytesTransmitted != 0) {
                encoder.uint32(0x30);
                encoder.uint64(this.BytesTransmitted);
            }
            if (this.BytesReceived != 0) {
                encoder.uint32(0x38);
                encoder.uint64(this.BytesReceived);
            }

            return buf;
        } // encode SessionData
    } // SessionData

    export class SessionLeave {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();

        // Decodes SessionLeave from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionLeave {
            return SessionLeave.decode(new DataView(buf));
        }

        // Decodes SessionLeave from a DataView
        static decode(view: DataView): SessionLeave {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionLeave();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionLeave

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SessionLeave to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionLeave to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SessionLeave
    } // SessionLeave

    export class UserLogin {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Status: events.Status = new events.Status();
        public Method: string = "";
        public IdentityAttributes: google.protobuf.Struct =
            new google.protobuf.Struct();
        public MFADevice: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes UserLogin from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserLogin {
            return UserLogin.decode(new DataView(buf));
        }

        // Decodes UserLogin from a DataView
        static decode(view: DataView): UserLogin {
            const decoder = new __proto.Decoder(view);
            const obj = new UserLogin();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Method = decoder.string();
                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.IdentityAttributes = google.protobuf.Struct.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.MFADevice = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserLogin

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Method.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Method.length) +
                      this.Method.length
                    : 0;

            if (this.IdentityAttributes != null) {
                const f: google.protobuf.Struct = this
                    .IdentityAttributes as google.protobuf.Struct;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADevice != null) {
                const f: events.MFADeviceMetadata = this
                    .MFADevice as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserLogin to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserLogin to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Method.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Method.length);
                encoder.string(this.Method);
            }

            if (this.IdentityAttributes != null) {
                const f = this.IdentityAttributes as google.protobuf.Struct;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.MFADevice != null) {
                const f = this.MFADevice as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserLogin
    } // UserLogin

    export class ResourceMetadata {
        public Name: string = "";
        public Expires: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();
        public UpdatedBy: string = "";
        public TTL: string = "";

        // Decodes ResourceMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ResourceMetadata {
            return ResourceMetadata.decode(new DataView(buf));
        }

        // Decodes ResourceMetadata from a DataView
        static decode(view: DataView): ResourceMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new ResourceMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Expires = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        obj.UpdatedBy = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.TTL = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ResourceMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;

            if (this.Expires != null) {
                const f: google.protobuf.Timestamp = this
                    .Expires as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.UpdatedBy.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UpdatedBy.length) +
                      this.UpdatedBy.length
                    : 0;
            size +=
                this.TTL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.TTL.length) +
                      this.TTL.length
                    : 0;

            return size;
        }

        // Encodes ResourceMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ResourceMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Name.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }

            if (this.Expires != null) {
                const f = this.Expires as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UpdatedBy.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.UpdatedBy.length);
                encoder.string(this.UpdatedBy);
            }
            if (this.TTL.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.TTL.length);
                encoder.string(this.TTL);
            }

            return buf;
        } // encode ResourceMetadata
    } // ResourceMetadata

    export class UserCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public Roles: Array<string> = new Array<string>();
        public Connector: string = "";

        // Decodes UserCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserCreate {
            return UserCreate.decode(new DataView(buf));
        }

        // Decodes UserCreate from a DataView
        static decode(view: DataView): UserCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new UserCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.Connector = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            size +=
                this.Connector.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Connector.length) +
                      this.Connector.length
                    : 0;

            return size;
        }

        // Encodes UserCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.Connector.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Connector.length);
                encoder.string(this.Connector);
            }

            return buf;
        } // encode UserCreate
    } // UserCreate

    export class UserDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes UserDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserDelete {
            return UserDelete.decode(new DataView(buf));
        }

        // Decodes UserDelete from a DataView
        static decode(view: DataView): UserDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new UserDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserDelete
    } // UserDelete

    export class UserPasswordChange {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes UserPasswordChange from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserPasswordChange {
            return UserPasswordChange.decode(new DataView(buf));
        }

        // Decodes UserPasswordChange from a DataView
        static decode(view: DataView): UserPasswordChange {
            const decoder = new __proto.Decoder(view);
            const obj = new UserPasswordChange();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserPasswordChange

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserPasswordChange to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserPasswordChange to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserPasswordChange
    } // UserPasswordChange

    export class AccessRequestCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public Roles: Array<string> = new Array<string>();
        public RequestID: string = "";
        public RequestState: string = "";
        public Delegator: string = "";
        public Reason: string = "";
        public Annotations: google.protobuf.Struct =
            new google.protobuf.Struct();
        public Reviewer: string = "";
        public ProposedState: string = "";

        // Decodes AccessRequestCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AccessRequestCreate {
            return AccessRequestCreate.decode(new DataView(buf));
        }

        // Decodes AccessRequestCreate from a DataView
        static decode(view: DataView): AccessRequestCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessRequestCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Roles.push(decoder.string());
                        break;
                    }
                    case 5: {
                        obj.RequestID = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.RequestState = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.Delegator = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Reason = decoder.string();
                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Annotations = google.protobuf.Struct.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        obj.Reviewer = decoder.string();
                        break;
                    }
                    case 11: {
                        obj.ProposedState = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AccessRequestCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size += __size_string_repeated(this.Roles);

            size +=
                this.RequestID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestID.length) +
                      this.RequestID.length
                    : 0;
            size +=
                this.RequestState.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestState.length) +
                      this.RequestState.length
                    : 0;
            size +=
                this.Delegator.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Delegator.length) +
                      this.Delegator.length
                    : 0;
            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            if (this.Annotations != null) {
                const f: google.protobuf.Struct = this
                    .Annotations as google.protobuf.Struct;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reviewer.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reviewer.length) +
                      this.Reviewer.length
                    : 0;
            size +=
                this.ProposedState.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ProposedState.length) +
                      this.ProposedState.length
                    : 0;

            return size;
        }

        // Encodes AccessRequestCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AccessRequestCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Roles.length > 0) {
                for (let n: i32 = 0; n < this.Roles.length; n++) {
                    encoder.uint32(0x22);
                    encoder.uint32(this.Roles[n].length);
                    encoder.string(this.Roles[n]);
                }
            }

            if (this.RequestID.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.RequestID.length);
                encoder.string(this.RequestID);
            }
            if (this.RequestState.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.RequestState.length);
                encoder.string(this.RequestState);
            }
            if (this.Delegator.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Delegator.length);
                encoder.string(this.Delegator);
            }
            if (this.Reason.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            if (this.Annotations != null) {
                const f = this.Annotations as google.protobuf.Struct;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Reviewer.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.Reviewer.length);
                encoder.string(this.Reviewer);
            }
            if (this.ProposedState.length > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(this.ProposedState.length);
                encoder.string(this.ProposedState);
            }

            return buf;
        } // encode AccessRequestCreate
    } // AccessRequestCreate

    export class PortForward {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Status: events.Status = new events.Status();
        public Addr: string = "";

        // Decodes PortForward from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): PortForward {
            return PortForward.decode(new DataView(buf));
        }

        // Decodes PortForward from a DataView
        static decode(view: DataView): PortForward {
            const decoder = new __proto.Decoder(view);
            const obj = new PortForward();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Addr = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode PortForward

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Addr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Addr.length) +
                      this.Addr.length
                    : 0;

            return size;
        }

        // Encodes PortForward to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes PortForward to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Addr.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Addr.length);
                encoder.string(this.Addr);
            }

            return buf;
        } // encode PortForward
    } // PortForward

    export class X11Forward {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Status: events.Status = new events.Status();

        // Decodes X11Forward from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): X11Forward {
            return X11Forward.decode(new DataView(buf));
        }

        // Decodes X11Forward from a DataView
        static decode(view: DataView): X11Forward {
            const decoder = new __proto.Decoder(view);
            const obj = new X11Forward();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode X11Forward

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes X11Forward to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes X11Forward to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode X11Forward
    } // X11Forward

    export class CommandMetadata {
        public Command: string = "";
        public ExitCode: string = "";
        public Error: string = "";

        // Decodes CommandMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): CommandMetadata {
            return CommandMetadata.decode(new DataView(buf));
        }

        // Decodes CommandMetadata from a DataView
        static decode(view: DataView): CommandMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new CommandMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.Command = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.ExitCode = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.Error = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode CommandMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.Command.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Command.length) +
                      this.Command.length
                    : 0;
            size +=
                this.ExitCode.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ExitCode.length) +
                      this.ExitCode.length
                    : 0;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;

            return size;
        }

        // Encodes CommandMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes CommandMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Command.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.Command.length);
                encoder.string(this.Command);
            }
            if (this.ExitCode.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.ExitCode.length);
                encoder.string(this.ExitCode);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }

            return buf;
        } // encode CommandMetadata
    } // CommandMetadata

    export class Exec {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Command: events.CommandMetadata = new events.CommandMetadata();
        public KubernetesCluster: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();
        public KubernetesPod: events.KubernetesPodMetadata =
            new events.KubernetesPodMetadata();

        // Decodes Exec from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Exec {
            return Exec.decode(new DataView(buf));
        }

        // Decodes Exec from a DataView
        static decode(view: DataView): Exec {
            const decoder = new __proto.Decoder(view);
            const obj = new Exec();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Command = events.CommandMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.KubernetesCluster =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.KubernetesPod = events.KubernetesPodMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Exec

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Command != null) {
                const f: events.CommandMetadata = this
                    .Command as events.CommandMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesCluster != null) {
                const f: events.KubernetesClusterMetadata = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubernetesPod != null) {
                const f: events.KubernetesPodMetadata = this
                    .KubernetesPod as events.KubernetesPodMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes Exec to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Exec to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Command != null) {
                const f = this.Command as events.CommandMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesCluster != null) {
                const f = this
                    .KubernetesCluster as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubernetesPod != null) {
                const f = this.KubernetesPod as events.KubernetesPodMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode Exec
    } // Exec

    export class SCP {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Command: events.CommandMetadata = new events.CommandMetadata();
        public Path: string = "";
        public Action: string = "";

        // Decodes SCP from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SCP {
            return SCP.decode(new DataView(buf));
        }

        // Decodes SCP from a DataView
        static decode(view: DataView): SCP {
            const decoder = new __proto.Decoder(view);
            const obj = new SCP();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Command = events.CommandMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Action = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SCP

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Command != null) {
                const f: events.CommandMetadata = this
                    .Command as events.CommandMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size +=
                this.Action.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Action.length) +
                      this.Action.length
                    : 0;

            return size;
        }

        // Encodes SCP to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SCP to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Command != null) {
                const f = this.Command as events.CommandMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Path.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.Action.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Action.length);
                encoder.string(this.Action);
            }

            return buf;
        } // encode SCP
    } // SCP

    export class Subsystem {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Name: string = "";
        public Error: string = "";

        // Decodes Subsystem from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): Subsystem {
            return Subsystem.decode(new DataView(buf));
        }

        // Decodes Subsystem from a DataView
        static decode(view: DataView): Subsystem {
            const decoder = new __proto.Decoder(view);
            const obj = new Subsystem();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.Name = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.Error = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode Subsystem

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Name.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Name.length) +
                      this.Name.length
                    : 0;
            size +=
                this.Error.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Error.length) +
                      this.Error.length
                    : 0;

            return size;
        }

        // Encodes Subsystem to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes Subsystem to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Name.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.Name.length);
                encoder.string(this.Name);
            }
            if (this.Error.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Error.length);
                encoder.string(this.Error);
            }

            return buf;
        } // encode Subsystem
    } // Subsystem

    export class ClientDisconnect {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Reason: string = "";

        // Decodes ClientDisconnect from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): ClientDisconnect {
            return ClientDisconnect.decode(new DataView(buf));
        }

        // Decodes ClientDisconnect from a DataView
        static decode(view: DataView): ClientDisconnect {
            const decoder = new __proto.Decoder(view);
            const obj = new ClientDisconnect();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.Reason = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode ClientDisconnect

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.Reason.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Reason.length) +
                      this.Reason.length
                    : 0;

            return size;
        }

        // Encodes ClientDisconnect to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes ClientDisconnect to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Reason.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Reason.length);
                encoder.string(this.Reason);
            }

            return buf;
        } // encode ClientDisconnect
    } // ClientDisconnect

    export class AuthAttempt {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Status: events.Status = new events.Status();

        // Decodes AuthAttempt from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AuthAttempt {
            return AuthAttempt.decode(new DataView(buf));
        }

        // Decodes AuthAttempt from a DataView
        static decode(view: DataView): AuthAttempt {
            const decoder = new __proto.Decoder(view);
            const obj = new AuthAttempt();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AuthAttempt

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AuthAttempt to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AuthAttempt to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AuthAttempt
    } // AuthAttempt

    export class UserTokenCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes UserTokenCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): UserTokenCreate {
            return UserTokenCreate.decode(new DataView(buf));
        }

        // Decodes UserTokenCreate from a DataView
        static decode(view: DataView): UserTokenCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new UserTokenCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode UserTokenCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes UserTokenCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes UserTokenCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode UserTokenCreate
    } // UserTokenCreate

    export class RoleCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RoleCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleCreate {
            return RoleCreate.decode(new DataView(buf));
        }

        // Decodes RoleCreate from a DataView
        static decode(view: DataView): RoleCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RoleCreate
    } // RoleCreate

    export class RoleDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RoleDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RoleDelete {
            return RoleDelete.decode(new DataView(buf));
        }

        // Decodes RoleDelete from a DataView
        static decode(view: DataView): RoleDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new RoleDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RoleDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RoleDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RoleDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RoleDelete
    } // RoleDelete

    export class TrustedClusterCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterCreate {
            return TrustedClusterCreate.decode(new DataView(buf));
        }

        // Decodes TrustedClusterCreate from a DataView
        static decode(view: DataView): TrustedClusterCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterCreate
    } // TrustedClusterCreate

    export class TrustedClusterDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterDelete {
            return TrustedClusterDelete.decode(new DataView(buf));
        }

        // Decodes TrustedClusterDelete from a DataView
        static decode(view: DataView): TrustedClusterDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterDelete
    } // TrustedClusterDelete

    export class TrustedClusterTokenCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes TrustedClusterTokenCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): TrustedClusterTokenCreate {
            return TrustedClusterTokenCreate.decode(new DataView(buf));
        }

        // Decodes TrustedClusterTokenCreate from a DataView
        static decode(view: DataView): TrustedClusterTokenCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new TrustedClusterTokenCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode TrustedClusterTokenCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes TrustedClusterTokenCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes TrustedClusterTokenCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode TrustedClusterTokenCreate
    } // TrustedClusterTokenCreate

    export class GithubConnectorCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes GithubConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorCreate {
            return GithubConnectorCreate.decode(new DataView(buf));
        }

        // Decodes GithubConnectorCreate from a DataView
        static decode(view: DataView): GithubConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorCreate
    } // GithubConnectorCreate

    export class GithubConnectorDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes GithubConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): GithubConnectorDelete {
            return GithubConnectorDelete.decode(new DataView(buf));
        }

        // Decodes GithubConnectorDelete from a DataView
        static decode(view: DataView): GithubConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new GithubConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode GithubConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes GithubConnectorDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes GithubConnectorDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode GithubConnectorDelete
    } // GithubConnectorDelete

    export class OIDCConnectorCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes OIDCConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorCreate {
            return OIDCConnectorCreate.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorCreate from a DataView
        static decode(view: DataView): OIDCConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorCreate
    } // OIDCConnectorCreate

    export class OIDCConnectorDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes OIDCConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OIDCConnectorDelete {
            return OIDCConnectorDelete.decode(new DataView(buf));
        }

        // Decodes OIDCConnectorDelete from a DataView
        static decode(view: DataView): OIDCConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new OIDCConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OIDCConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OIDCConnectorDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OIDCConnectorDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode OIDCConnectorDelete
    } // OIDCConnectorDelete

    export class SAMLConnectorCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes SAMLConnectorCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorCreate {
            return SAMLConnectorCreate.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorCreate from a DataView
        static decode(view: DataView): SAMLConnectorCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorCreate
    } // SAMLConnectorCreate

    export class SAMLConnectorDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes SAMLConnectorDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SAMLConnectorDelete {
            return SAMLConnectorDelete.decode(new DataView(buf));
        }

        // Decodes SAMLConnectorDelete from a DataView
        static decode(view: DataView): SAMLConnectorDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new SAMLConnectorDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SAMLConnectorDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes SAMLConnectorDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SAMLConnectorDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode SAMLConnectorDelete
    } // SAMLConnectorDelete

    export class KubeRequest {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public RequestPath: string = "";
        public Verb: string = "";
        public ResourceAPIGroup: string = "";
        public ResourceNamespace: string = "";
        public ResourceKind: string = "";
        public ResourceName: string = "";
        public ResponseCode: i32;
        public Kubernetes: events.KubernetesClusterMetadata =
            new events.KubernetesClusterMetadata();

        // Decodes KubeRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): KubeRequest {
            return KubeRequest.decode(new DataView(buf));
        }

        // Decodes KubeRequest from a DataView
        static decode(view: DataView): KubeRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new KubeRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.RequestPath = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Verb = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.ResourceAPIGroup = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.ResourceNamespace = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.ResourceKind = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.ResourceName = decoder.string();
                        break;
                    }
                    case 11: {
                        obj.ResponseCode = decoder.int32();
                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.Kubernetes =
                            events.KubernetesClusterMetadata.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode KubeRequest

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.RequestPath.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RequestPath.length) +
                      this.RequestPath.length
                    : 0;
            size +=
                this.Verb.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Verb.length) +
                      this.Verb.length
                    : 0;
            size +=
                this.ResourceAPIGroup.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceAPIGroup.length) +
                      this.ResourceAPIGroup.length
                    : 0;
            size +=
                this.ResourceNamespace.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceNamespace.length) +
                      this.ResourceNamespace.length
                    : 0;
            size +=
                this.ResourceKind.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceKind.length) +
                      this.ResourceKind.length
                    : 0;
            size +=
                this.ResourceName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.ResourceName.length) +
                      this.ResourceName.length
                    : 0;
            size +=
                this.ResponseCode == 0
                    ? 0
                    : 1 + __proto.Sizer.int32(this.ResponseCode);

            if (this.Kubernetes != null) {
                const f: events.KubernetesClusterMetadata = this
                    .Kubernetes as events.KubernetesClusterMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes KubeRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes KubeRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RequestPath.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.RequestPath.length);
                encoder.string(this.RequestPath);
            }
            if (this.Verb.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Verb.length);
                encoder.string(this.Verb);
            }
            if (this.ResourceAPIGroup.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.ResourceAPIGroup.length);
                encoder.string(this.ResourceAPIGroup);
            }
            if (this.ResourceNamespace.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.ResourceNamespace.length);
                encoder.string(this.ResourceNamespace);
            }
            if (this.ResourceKind.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.ResourceKind.length);
                encoder.string(this.ResourceKind);
            }
            if (this.ResourceName.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.ResourceName.length);
                encoder.string(this.ResourceName);
            }
            if (this.ResponseCode != 0) {
                encoder.uint32(0x58);
                encoder.int32(this.ResponseCode);
            }

            if (this.Kubernetes != null) {
                const f = this.Kubernetes as events.KubernetesClusterMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode KubeRequest
    } // KubeRequest

    export class AppMetadata {
        public AppURI: string = "";
        public AppPublicAddr: string = "";
        public AppLabels: Map<string, string> = new Map<string, string>();

        // Decodes AppMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppMetadata {
            return AppMetadata.decode(new DataView(buf));
        }

        // Decodes AppMetadata from a DataView
        static decode(view: DataView): AppMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new AppMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.AppURI = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.AppPublicAddr = decoder.string();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.AppLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.AppURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppURI.length) +
                      this.AppURI.length
                    : 0;
            size +=
                this.AppPublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.AppPublicAddr.length) +
                      this.AppPublicAddr.length
                    : 0;

            if (this.AppLabels.size > 0) {
                const keys = this.AppLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.AppLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes AppMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.AppURI.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.AppURI.length);
                encoder.string(this.AppURI);
            }
            if (this.AppPublicAddr.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.AppPublicAddr.length);
                encoder.string(this.AppPublicAddr);
            }

            if (this.AppLabels.size > 0) {
                const keys = this.AppLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.AppLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x1a);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode AppMetadata
    } // AppMetadata

    export class AppCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppCreate {
            return AppCreate.decode(new DataView(buf));
        }

        // Decodes AppCreate from a DataView
        static decode(view: DataView): AppCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new AppCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppCreate
    } // AppCreate

    export class AppUpdate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public App: events.AppMetadata = new events.AppMetadata();

        // Decodes AppUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppUpdate {
            return AppUpdate.decode(new DataView(buf));
        }

        // Decodes AppUpdate from a DataView
        static decode(view: DataView): AppUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new AppUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.App = events.AppMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.App != null) {
                const f: events.AppMetadata = this.App as events.AppMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppUpdate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppUpdate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.App != null) {
                const f = this.App as events.AppMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppUpdate
    } // AppUpdate

    export class AppDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes AppDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppDelete {
            return AppDelete.decode(new DataView(buf));
        }

        // Decodes AppDelete from a DataView
        static decode(view: DataView): AppDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new AppDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes AppDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode AppDelete
    } // AppDelete

    export class AppSessionStart {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public PublicAddr: string = "";

        // Decodes AppSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionStart {
            return AppSessionStart.decode(new DataView(buf));
        }

        // Decodes AppSessionStart from a DataView
        static decode(view: DataView): AppSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.PublicAddr = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.PublicAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.PublicAddr.length) +
                      this.PublicAddr.length
                    : 0;

            return size;
        }

        // Encodes AppSessionStart to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionStart to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.PublicAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.PublicAddr.length);
                encoder.string(this.PublicAddr);
            }

            return buf;
        } // encode AppSessionStart
    } // AppSessionStart

    export class AppSessionChunk {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public SessionChunkID: string = "";

        // Decodes AppSessionChunk from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionChunk {
            return AppSessionChunk.decode(new DataView(buf));
        }

        // Decodes AppSessionChunk from a DataView
        static decode(view: DataView): AppSessionChunk {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionChunk();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.SessionChunkID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionChunk

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.SessionChunkID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionChunkID.length) +
                      this.SessionChunkID.length
                    : 0;

            return size;
        }

        // Encodes AppSessionChunk to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionChunk to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionChunkID.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.SessionChunkID.length);
                encoder.string(this.SessionChunkID);
            }

            return buf;
        } // encode AppSessionChunk
    } // AppSessionChunk

    export class AppSessionRequest {
        public Metadata: events.Metadata = new events.Metadata();
        public StatusCode: u32;
        public Path: string = "";
        public RawQuery: string = "";
        public Method: string = "";

        // Decodes AppSessionRequest from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): AppSessionRequest {
            return AppSessionRequest.decode(new DataView(buf));
        }

        // Decodes AppSessionRequest from a DataView
        static decode(view: DataView): AppSessionRequest {
            const decoder = new __proto.Decoder(view);
            const obj = new AppSessionRequest();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        obj.StatusCode = decoder.uint32();
                        break;
                    }
                    case 3: {
                        obj.Path = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.RawQuery = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.Method = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode AppSessionRequest

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.StatusCode == 0
                    ? 0
                    : 1 + __proto.Sizer.uint32(this.StatusCode);
            size +=
                this.Path.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Path.length) +
                      this.Path.length
                    : 0;
            size +=
                this.RawQuery.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.RawQuery.length) +
                      this.RawQuery.length
                    : 0;
            size +=
                this.Method.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Method.length) +
                      this.Method.length
                    : 0;

            return size;
        }

        // Encodes AppSessionRequest to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes AppSessionRequest to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.StatusCode != 0) {
                encoder.uint32(0x10);
                encoder.uint32(this.StatusCode);
            }
            if (this.Path.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.Path.length);
                encoder.string(this.Path);
            }
            if (this.RawQuery.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.RawQuery.length);
                encoder.string(this.RawQuery);
            }
            if (this.Method.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.Method.length);
                encoder.string(this.Method);
            }

            return buf;
        } // encode AppSessionRequest
    } // AppSessionRequest

    export class DatabaseMetadata {
        public DatabaseService: string = "";
        public DatabaseProtocol: string = "";
        public DatabaseURI: string = "";
        public DatabaseName: string = "";
        public DatabaseUser: string = "";
        public DatabaseLabels: Map<string, string> = new Map<string, string>();
        public DatabaseAWSRegion: string = "";
        public DatabaseAWSRedshiftClusterID: string = "";
        public DatabaseGCPProjectID: string = "";
        public DatabaseGCPInstanceID: string = "";

        // Decodes DatabaseMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseMetadata {
            return DatabaseMetadata.decode(new DataView(buf));
        }

        // Decodes DatabaseMetadata from a DataView
        static decode(view: DataView): DatabaseMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.DatabaseService = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DatabaseProtocol = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.DatabaseURI = decoder.string();
                        break;
                    }
                    case 4: {
                        obj.DatabaseName = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.DatabaseUser = decoder.string();
                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DatabaseLabels
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        obj.DatabaseAWSRegion = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.DatabaseAWSRedshiftClusterID = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.DatabaseGCPProjectID = decoder.string();
                        break;
                    }
                    case 10: {
                        obj.DatabaseGCPInstanceID = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.DatabaseService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseService.length) +
                      this.DatabaseService.length
                    : 0;
            size +=
                this.DatabaseProtocol.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseProtocol.length) +
                      this.DatabaseProtocol.length
                    : 0;
            size +=
                this.DatabaseURI.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseURI.length) +
                      this.DatabaseURI.length
                    : 0;
            size +=
                this.DatabaseName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseName.length) +
                      this.DatabaseName.length
                    : 0;
            size +=
                this.DatabaseUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseUser.length) +
                      this.DatabaseUser.length
                    : 0;

            if (this.DatabaseLabels.size > 0) {
                const keys = this.DatabaseLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DatabaseLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            size +=
                this.DatabaseAWSRegion.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseAWSRegion.length) +
                      this.DatabaseAWSRegion.length
                    : 0;
            size +=
                this.DatabaseAWSRedshiftClusterID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.DatabaseAWSRedshiftClusterID.length
                      ) +
                      this.DatabaseAWSRedshiftClusterID.length
                    : 0;
            size +=
                this.DatabaseGCPProjectID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseGCPProjectID.length) +
                      this.DatabaseGCPProjectID.length
                    : 0;
            size +=
                this.DatabaseGCPInstanceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.DatabaseGCPInstanceID.length
                      ) +
                      this.DatabaseGCPInstanceID.length
                    : 0;

            return size;
        }

        // Encodes DatabaseMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DatabaseService.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.DatabaseService.length);
                encoder.string(this.DatabaseService);
            }
            if (this.DatabaseProtocol.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.DatabaseProtocol.length);
                encoder.string(this.DatabaseProtocol);
            }
            if (this.DatabaseURI.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.DatabaseURI.length);
                encoder.string(this.DatabaseURI);
            }
            if (this.DatabaseName.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.DatabaseName.length);
                encoder.string(this.DatabaseName);
            }
            if (this.DatabaseUser.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DatabaseUser.length);
                encoder.string(this.DatabaseUser);
            }

            if (this.DatabaseLabels.size > 0) {
                const keys = this.DatabaseLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DatabaseLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x32);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            if (this.DatabaseAWSRegion.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DatabaseAWSRegion.length);
                encoder.string(this.DatabaseAWSRegion);
            }
            if (this.DatabaseAWSRedshiftClusterID.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.DatabaseAWSRedshiftClusterID.length);
                encoder.string(this.DatabaseAWSRedshiftClusterID);
            }
            if (this.DatabaseGCPProjectID.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.DatabaseGCPProjectID.length);
                encoder.string(this.DatabaseGCPProjectID);
            }
            if (this.DatabaseGCPInstanceID.length > 0) {
                encoder.uint32(0x52);
                encoder.uint32(this.DatabaseGCPInstanceID.length);
                encoder.string(this.DatabaseGCPInstanceID);
            }

            return buf;
        } // encode DatabaseMetadata
    } // DatabaseMetadata

    export class DatabaseCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseCreate {
            return DatabaseCreate.decode(new DataView(buf));
        }

        // Decodes DatabaseCreate from a DataView
        static decode(view: DataView): DatabaseCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseCreate
    } // DatabaseCreate

    export class DatabaseUpdate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseUpdate {
            return DatabaseUpdate.decode(new DataView(buf));
        }

        // Decodes DatabaseUpdate from a DataView
        static decode(view: DataView): DatabaseUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseUpdate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseUpdate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseUpdate
    } // DatabaseUpdate

    export class DatabaseDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();

        // Decodes DatabaseDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseDelete {
            return DatabaseDelete.decode(new DataView(buf));
        }

        // Decodes DatabaseDelete from a DataView
        static decode(view: DataView): DatabaseDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseDelete
    } // DatabaseDelete

    export class DatabaseSessionStart {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Server: events.ServerMetadata = new events.ServerMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Status: events.Status = new events.Status();
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionStart {
            return DatabaseSessionStart.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionStart from a DataView
        static decode(view: DataView): DatabaseSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Server = events.ServerMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Server != null) {
                const f: events.ServerMetadata = this
                    .Server as events.ServerMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionStart to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionStart to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Server != null) {
                const f = this.Server as events.ServerMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionStart
    } // DatabaseSessionStart

    export class DatabaseSessionQuery {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();
        public DatabaseQuery: string = "";
        public DatabaseQueryParameters: Array<string> = new Array<string>();
        public Status: events.Status = new events.Status();

        // Decodes DatabaseSessionQuery from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionQuery {
            return DatabaseSessionQuery.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionQuery from a DataView
        static decode(view: DataView): DatabaseSessionQuery {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionQuery();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        obj.DatabaseQuery = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.DatabaseQueryParameters.push(decoder.string());
                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionQuery

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.DatabaseQuery.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DatabaseQuery.length) +
                      this.DatabaseQuery.length
                    : 0;

            size += __size_string_repeated(this.DatabaseQueryParameters);

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionQuery to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionQuery to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseQuery.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DatabaseQuery.length);
                encoder.string(this.DatabaseQuery);
            }

            if (this.DatabaseQueryParameters.length > 0) {
                for (
                    let n: i32 = 0;
                    n < this.DatabaseQueryParameters.length;
                    n++
                ) {
                    encoder.uint32(0x32);
                    encoder.uint32(this.DatabaseQueryParameters[n].length);
                    encoder.string(this.DatabaseQueryParameters[n]);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionQuery
    } // DatabaseSessionQuery

    export class WindowsDesktopSessionStart {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Connection: events.ConnectionMetadata =
            new events.ConnectionMetadata();
        public Status: events.Status = new events.Status();
        public WindowsDesktopService: string = "";
        public DesktopAddr: string = "";
        public Domain: string = "";
        public WindowsUser: string = "";
        public DesktopLabels: Map<string, string> = new Map<string, string>();

        // Decodes WindowsDesktopSessionStart from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSessionStart {
            return WindowsDesktopSessionStart.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSessionStart from a DataView
        static decode(view: DataView): WindowsDesktopSessionStart {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSessionStart();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Connection = events.ConnectionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        obj.WindowsDesktopService = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.DesktopAddr = decoder.string();
                        break;
                    }
                    case 8: {
                        obj.Domain = decoder.string();
                        break;
                    }
                    case 9: {
                        obj.WindowsUser = decoder.string();
                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DesktopLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSessionStart

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Connection != null) {
                const f: events.ConnectionMetadata = this
                    .Connection as events.ConnectionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.WindowsDesktopService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.WindowsDesktopService.length
                      ) +
                      this.WindowsDesktopService.length
                    : 0;
            size +=
                this.DesktopAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DesktopAddr.length) +
                      this.DesktopAddr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;
            size +=
                this.WindowsUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WindowsUser.length) +
                      this.WindowsUser.length
                    : 0;

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes WindowsDesktopSessionStart to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSessionStart to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Connection != null) {
                const f = this.Connection as events.ConnectionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.WindowsDesktopService.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.WindowsDesktopService.length);
                encoder.string(this.WindowsDesktopService);
            }
            if (this.DesktopAddr.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.DesktopAddr.length);
                encoder.string(this.DesktopAddr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x42);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }
            if (this.WindowsUser.length > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(this.WindowsUser.length);
                encoder.string(this.WindowsUser);
            }

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x52);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode WindowsDesktopSessionStart
    } // WindowsDesktopSessionStart

    export class DatabaseSessionEnd {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public Database: events.DatabaseMetadata =
            new events.DatabaseMetadata();

        // Decodes DatabaseSessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): DatabaseSessionEnd {
            return DatabaseSessionEnd.decode(new DataView(buf));
        }

        // Decodes DatabaseSessionEnd from a DataView
        static decode(view: DataView): DatabaseSessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new DatabaseSessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.Database = events.DatabaseMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode DatabaseSessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Database != null) {
                const f: events.DatabaseMetadata = this
                    .Database as events.DatabaseMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes DatabaseSessionEnd to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes DatabaseSessionEnd to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Database != null) {
                const f = this.Database as events.DatabaseMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode DatabaseSessionEnd
    } // DatabaseSessionEnd

    export class MFADeviceMetadata {
        public DeviceName: string = "";
        public DeviceID: string = "";
        public DeviceType: string = "";

        // Decodes MFADeviceMetadata from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceMetadata {
            return MFADeviceMetadata.decode(new DataView(buf));
        }

        // Decodes MFADeviceMetadata from a DataView
        static decode(view: DataView): MFADeviceMetadata {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceMetadata();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.DeviceName = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.DeviceID = decoder.string();
                        break;
                    }
                    case 3: {
                        obj.DeviceType = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceMetadata

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.DeviceName.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceName.length) +
                      this.DeviceName.length
                    : 0;
            size +=
                this.DeviceID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceID.length) +
                      this.DeviceID.length
                    : 0;
            size +=
                this.DeviceType.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DeviceType.length) +
                      this.DeviceType.length
                    : 0;

            return size;
        }

        // Encodes MFADeviceMetadata to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceMetadata to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.DeviceName.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.DeviceName.length);
                encoder.string(this.DeviceName);
            }
            if (this.DeviceID.length > 0) {
                encoder.uint32(0x12);
                encoder.uint32(this.DeviceID.length);
                encoder.string(this.DeviceID);
            }
            if (this.DeviceType.length > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(this.DeviceType.length);
                encoder.string(this.DeviceType);
            }

            return buf;
        } // encode MFADeviceMetadata
    } // MFADeviceMetadata

    export class MFADeviceAdd {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Device: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes MFADeviceAdd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceAdd {
            return MFADeviceAdd.decode(new DataView(buf));
        }

        // Decodes MFADeviceAdd from a DataView
        static decode(view: DataView): MFADeviceAdd {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceAdd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Device = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceAdd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Device != null) {
                const f: events.MFADeviceMetadata = this
                    .Device as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADeviceAdd to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceAdd to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Device != null) {
                const f = this.Device as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode MFADeviceAdd
    } // MFADeviceAdd

    export class MFADeviceDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Device: events.MFADeviceMetadata =
            new events.MFADeviceMetadata();

        // Decodes MFADeviceDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): MFADeviceDelete {
            return MFADeviceDelete.decode(new DataView(buf));
        }

        // Decodes MFADeviceDelete from a DataView
        static decode(view: DataView): MFADeviceDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new MFADeviceDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Device = events.MFADeviceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode MFADeviceDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Device != null) {
                const f: events.MFADeviceMetadata = this
                    .Device as events.MFADeviceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes MFADeviceDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes MFADeviceDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Device != null) {
                const f = this.Device as events.MFADeviceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode MFADeviceDelete
    } // MFADeviceDelete

    export class BillingInformationUpdate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingInformationUpdate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingInformationUpdate {
            return BillingInformationUpdate.decode(new DataView(buf));
        }

        // Decodes BillingInformationUpdate from a DataView
        static decode(view: DataView): BillingInformationUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingInformationUpdate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingInformationUpdate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingInformationUpdate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingInformationUpdate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode BillingInformationUpdate
    } // BillingInformationUpdate

    export class BillingCardCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingCardCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingCardCreate {
            return BillingCardCreate.decode(new DataView(buf));
        }

        // Decodes BillingCardCreate from a DataView
        static decode(view: DataView): BillingCardCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingCardCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingCardCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingCardCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingCardCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode BillingCardCreate
    } // BillingCardCreate

    export class BillingCardDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes BillingCardDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): BillingCardDelete {
            return BillingCardDelete.decode(new DataView(buf));
        }

        // Decodes BillingCardDelete from a DataView
        static decode(view: DataView): BillingCardDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new BillingCardDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode BillingCardDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes BillingCardDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes BillingCardDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode BillingCardDelete
    } // BillingCardDelete

    export class LockCreate {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes LockCreate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockCreate {
            return LockCreate.decode(new DataView(buf));
        }

        // Decodes LockCreate from a DataView
        static decode(view: DataView): LockCreate {
            const decoder = new __proto.Decoder(view);
            const obj = new LockCreate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockCreate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockCreate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockCreate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LockCreate
    } // LockCreate

    export class LockDelete {
        public Metadata: events.Metadata = new events.Metadata();
        public Resource: events.ResourceMetadata =
            new events.ResourceMetadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes LockDelete from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): LockDelete {
            return LockDelete.decode(new DataView(buf));
        }

        // Decodes LockDelete from a DataView
        static decode(view: DataView): LockDelete {
            const decoder = new __proto.Decoder(view);
            const obj = new LockDelete();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.Resource = events.ResourceMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode LockDelete

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resource != null) {
                const f: events.ResourceMetadata = this
                    .Resource as events.ResourceMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes LockDelete to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes LockDelete to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resource != null) {
                const f = this.Resource as events.ResourceMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode LockDelete
    } // LockDelete

    export class RecoveryCodeGenerate {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();

        // Decodes RecoveryCodeGenerate from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodeGenerate {
            return RecoveryCodeGenerate.decode(new DataView(buf));
        }

        // Decodes RecoveryCodeGenerate from a DataView
        static decode(view: DataView): RecoveryCodeGenerate {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodeGenerate();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodeGenerate

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodeGenerate to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodeGenerate to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodeGenerate
    } // RecoveryCodeGenerate

    export class RecoveryCodeUsed {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Status: events.Status = new events.Status();

        // Decodes RecoveryCodeUsed from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): RecoveryCodeUsed {
            return RecoveryCodeUsed.decode(new DataView(buf));
        }

        // Decodes RecoveryCodeUsed from a DataView
        static decode(view: DataView): RecoveryCodeUsed {
            const decoder = new __proto.Decoder(view);
            const obj = new RecoveryCodeUsed();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Status = events.Status.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode RecoveryCodeUsed

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Status != null) {
                const f: events.Status = this.Status as events.Status;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes RecoveryCodeUsed to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes RecoveryCodeUsed to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Status != null) {
                const f = this.Status as events.Status;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode RecoveryCodeUsed
    } // RecoveryCodeUsed

    export class WindowsDesktopSessionEnd {
        public Metadata: events.Metadata = new events.Metadata();
        public User: events.UserMetadata = new events.UserMetadata();
        public Session: events.SessionMetadata = new events.SessionMetadata();
        public WindowsDesktopService: string = "";
        public DesktopAddr: string = "";
        public Domain: string = "";
        public WindowsUser: string = "";
        public DesktopLabels: Map<string, string> = new Map<string, string>();

        // Decodes WindowsDesktopSessionEnd from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): WindowsDesktopSessionEnd {
            return WindowsDesktopSessionEnd.decode(new DataView(buf));
        }

        // Decodes WindowsDesktopSessionEnd from a DataView
        static decode(view: DataView): WindowsDesktopSessionEnd {
            const decoder = new __proto.Decoder(view);
            const obj = new WindowsDesktopSessionEnd();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.User = events.UserMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.Session = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.WindowsDesktopService = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.DesktopAddr = decoder.string();
                        break;
                    }
                    case 6: {
                        obj.Domain = decoder.string();
                        break;
                    }
                    case 7: {
                        obj.WindowsUser = decoder.string();
                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        __decodeMap_string_string(
                            decoder,
                            length,
                            obj.DesktopLabels
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode WindowsDesktopSessionEnd

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.User != null) {
                const f: events.UserMetadata = this.User as events.UserMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Session != null) {
                const f: events.SessionMetadata = this
                    .Session as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.WindowsDesktopService.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(
                          this.WindowsDesktopService.length
                      ) +
                      this.WindowsDesktopService.length
                    : 0;
            size +=
                this.DesktopAddr.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.DesktopAddr.length) +
                      this.DesktopAddr.length
                    : 0;
            size +=
                this.Domain.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.Domain.length) +
                      this.Domain.length
                    : 0;
            size +=
                this.WindowsUser.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.WindowsUser.length) +
                      this.WindowsUser.length
                    : 0;

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const itemSize = __sizeMapEntry_string_string(key, value);
                    if (itemSize > 0) {
                        size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;
                    }
                }
            }

            return size;
        }

        // Encodes WindowsDesktopSessionEnd to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes WindowsDesktopSessionEnd to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.User != null) {
                const f = this.User as events.UserMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Session != null) {
                const f = this.Session as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.WindowsDesktopService.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.WindowsDesktopService.length);
                encoder.string(this.WindowsDesktopService);
            }
            if (this.DesktopAddr.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.DesktopAddr.length);
                encoder.string(this.DesktopAddr);
            }
            if (this.Domain.length > 0) {
                encoder.uint32(0x32);
                encoder.uint32(this.Domain.length);
                encoder.string(this.Domain);
            }
            if (this.WindowsUser.length > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(this.WindowsUser.length);
                encoder.string(this.WindowsUser);
            }

            if (this.DesktopLabels.size > 0) {
                const keys = this.DesktopLabels.keys();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = this.DesktopLabels.get(key);
                    const size = __sizeMapEntry_string_string(key, value);
                    if (size > 0) {
                        encoder.uint32(0x42);
                        encoder.uint32(size);
                        if (key.length > 0) {
                            encoder.uint32(0xa);
                            encoder.uint32(key.length);
                            encoder.string(key);
                        }
                        if (value.length > 0) {
                            encoder.uint32(0x12);
                            encoder.uint32(value.length);
                            encoder.string(value);
                        }
                    }
                }
            }

            return buf;
        } // encode WindowsDesktopSessionEnd
    } // WindowsDesktopSessionEnd

    export class OneOf {
        public UserLogin: events.UserLogin | null;
        public UserCreate: events.UserCreate | null;
        public UserDelete: events.UserDelete | null;
        public UserPasswordChange: events.UserPasswordChange | null;
        public SessionStart: events.SessionStart | null;
        public SessionJoin: events.SessionJoin | null;
        public SessionPrint: events.SessionPrint | null;
        public SessionReject: events.SessionReject | null;
        public Resize: events.Resize | null;
        public SessionEnd: events.SessionEnd | null;
        public SessionCommand: events.SessionCommand | null;
        public SessionDisk: events.SessionDisk | null;
        public SessionNetwork: events.SessionNetwork | null;
        public SessionData: events.SessionData | null;
        public SessionLeave: events.SessionLeave | null;
        public PortForward: events.PortForward | null;
        public X11Forward: events.X11Forward | null;
        public SCP: events.SCP | null;
        public Exec: events.Exec | null;
        public Subsystem: events.Subsystem | null;
        public ClientDisconnect: events.ClientDisconnect | null;
        public AuthAttempt: events.AuthAttempt | null;
        public AccessRequestCreate: events.AccessRequestCreate | null;
        public UserTokenCreate: events.UserTokenCreate | null;
        public RoleCreate: events.RoleCreate | null;
        public RoleDelete: events.RoleDelete | null;
        public TrustedClusterCreate: events.TrustedClusterCreate | null;
        public TrustedClusterDelete: events.TrustedClusterDelete | null;
        public TrustedClusterTokenCreate: events.TrustedClusterTokenCreate | null;
        public GithubConnectorCreate: events.GithubConnectorCreate | null;
        public GithubConnectorDelete: events.GithubConnectorDelete | null;
        public OIDCConnectorCreate: events.OIDCConnectorCreate | null;
        public OIDCConnectorDelete: events.OIDCConnectorDelete | null;
        public SAMLConnectorCreate: events.SAMLConnectorCreate | null;
        public SAMLConnectorDelete: events.SAMLConnectorDelete | null;
        public KubeRequest: events.KubeRequest | null;
        public AppSessionStart: events.AppSessionStart | null;
        public AppSessionChunk: events.AppSessionChunk | null;
        public AppSessionRequest: events.AppSessionRequest | null;
        public DatabaseSessionStart: events.DatabaseSessionStart | null;
        public DatabaseSessionEnd: events.DatabaseSessionEnd | null;
        public DatabaseSessionQuery: events.DatabaseSessionQuery | null;
        public SessionUpload: events.SessionUpload | null;
        public MFADeviceAdd: events.MFADeviceAdd | null;
        public MFADeviceDelete: events.MFADeviceDelete | null;
        public BillingInformationUpdate: events.BillingInformationUpdate | null;
        public BillingCardCreate: events.BillingCardCreate | null;
        public BillingCardDelete: events.BillingCardDelete | null;
        public LockCreate: events.LockCreate | null;
        public LockDelete: events.LockDelete | null;
        public RecoveryCodeGenerate: events.RecoveryCodeGenerate | null;
        public RecoveryCodeUsed: events.RecoveryCodeUsed | null;
        public DatabaseCreate: events.DatabaseCreate | null;
        public DatabaseUpdate: events.DatabaseUpdate | null;
        public DatabaseDelete: events.DatabaseDelete | null;
        public AppCreate: events.AppCreate | null;
        public AppUpdate: events.AppUpdate | null;
        public AppDelete: events.AppDelete | null;
        public WindowsDesktopSessionStart: events.WindowsDesktopSessionStart | null;
        public WindowsDesktopSessionEnd: events.WindowsDesktopSessionEnd | null;

        // Decodes OneOf from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): OneOf {
            return OneOf.decode(new DataView(buf));
        }

        // Decodes OneOf from a DataView
        static decode(view: DataView): OneOf {
            const decoder = new __proto.Decoder(view);
            const obj = new OneOf();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.UserLogin = events.UserLogin.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.UserCreate = events.UserCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.UserDelete = events.UserDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        const length = decoder.uint32();
                        obj.UserPasswordChange =
                            events.UserPasswordChange.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 5: {
                        const length = decoder.uint32();
                        obj.SessionStart = events.SessionStart.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 6: {
                        const length = decoder.uint32();
                        obj.SessionJoin = events.SessionJoin.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 7: {
                        const length = decoder.uint32();
                        obj.SessionPrint = events.SessionPrint.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 8: {
                        const length = decoder.uint32();
                        obj.SessionReject = events.SessionReject.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 9: {
                        const length = decoder.uint32();
                        obj.Resize = events.Resize.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 10: {
                        const length = decoder.uint32();
                        obj.SessionEnd = events.SessionEnd.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 11: {
                        const length = decoder.uint32();
                        obj.SessionCommand = events.SessionCommand.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 12: {
                        const length = decoder.uint32();
                        obj.SessionDisk = events.SessionDisk.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 13: {
                        const length = decoder.uint32();
                        obj.SessionNetwork = events.SessionNetwork.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 14: {
                        const length = decoder.uint32();
                        obj.SessionData = events.SessionData.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 15: {
                        const length = decoder.uint32();
                        obj.SessionLeave = events.SessionLeave.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 16: {
                        const length = decoder.uint32();
                        obj.PortForward = events.PortForward.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 17: {
                        const length = decoder.uint32();
                        obj.X11Forward = events.X11Forward.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 18: {
                        const length = decoder.uint32();
                        obj.SCP = events.SCP.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 19: {
                        const length = decoder.uint32();
                        obj.Exec = events.Exec.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 20: {
                        const length = decoder.uint32();
                        obj.Subsystem = events.Subsystem.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 21: {
                        const length = decoder.uint32();
                        obj.ClientDisconnect = events.ClientDisconnect.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 22: {
                        const length = decoder.uint32();
                        obj.AuthAttempt = events.AuthAttempt.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 23: {
                        const length = decoder.uint32();
                        obj.AccessRequestCreate =
                            events.AccessRequestCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 24: {
                        const length = decoder.uint32();
                        obj.UserTokenCreate = events.UserTokenCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 25: {
                        const length = decoder.uint32();
                        obj.RoleCreate = events.RoleCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 26: {
                        const length = decoder.uint32();
                        obj.RoleDelete = events.RoleDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 27: {
                        const length = decoder.uint32();
                        obj.TrustedClusterCreate =
                            events.TrustedClusterCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 28: {
                        const length = decoder.uint32();
                        obj.TrustedClusterDelete =
                            events.TrustedClusterDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 29: {
                        const length = decoder.uint32();
                        obj.TrustedClusterTokenCreate =
                            events.TrustedClusterTokenCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 30: {
                        const length = decoder.uint32();
                        obj.GithubConnectorCreate =
                            events.GithubConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 31: {
                        const length = decoder.uint32();
                        obj.GithubConnectorDelete =
                            events.GithubConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 32: {
                        const length = decoder.uint32();
                        obj.OIDCConnectorCreate =
                            events.OIDCConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 33: {
                        const length = decoder.uint32();
                        obj.OIDCConnectorDelete =
                            events.OIDCConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 34: {
                        const length = decoder.uint32();
                        obj.SAMLConnectorCreate =
                            events.SAMLConnectorCreate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 35: {
                        const length = decoder.uint32();
                        obj.SAMLConnectorDelete =
                            events.SAMLConnectorDelete.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 36: {
                        const length = decoder.uint32();
                        obj.KubeRequest = events.KubeRequest.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 37: {
                        const length = decoder.uint32();
                        obj.AppSessionStart = events.AppSessionStart.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 38: {
                        const length = decoder.uint32();
                        obj.AppSessionChunk = events.AppSessionChunk.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 39: {
                        const length = decoder.uint32();
                        obj.AppSessionRequest = events.AppSessionRequest.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 40: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionStart =
                            events.DatabaseSessionStart.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 41: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionEnd =
                            events.DatabaseSessionEnd.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 42: {
                        const length = decoder.uint32();
                        obj.DatabaseSessionQuery =
                            events.DatabaseSessionQuery.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 43: {
                        const length = decoder.uint32();
                        obj.SessionUpload = events.SessionUpload.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 44: {
                        const length = decoder.uint32();
                        obj.MFADeviceAdd = events.MFADeviceAdd.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 45: {
                        const length = decoder.uint32();
                        obj.MFADeviceDelete = events.MFADeviceDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 46: {
                        const length = decoder.uint32();
                        obj.BillingInformationUpdate =
                            events.BillingInformationUpdate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 47: {
                        const length = decoder.uint32();
                        obj.BillingCardCreate = events.BillingCardCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 48: {
                        const length = decoder.uint32();
                        obj.BillingCardDelete = events.BillingCardDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 49: {
                        const length = decoder.uint32();
                        obj.LockCreate = events.LockCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 50: {
                        const length = decoder.uint32();
                        obj.LockDelete = events.LockDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 51: {
                        const length = decoder.uint32();
                        obj.RecoveryCodeGenerate =
                            events.RecoveryCodeGenerate.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 52: {
                        const length = decoder.uint32();
                        obj.RecoveryCodeUsed = events.RecoveryCodeUsed.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 53: {
                        const length = decoder.uint32();
                        obj.DatabaseCreate = events.DatabaseCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 54: {
                        const length = decoder.uint32();
                        obj.DatabaseUpdate = events.DatabaseUpdate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 55: {
                        const length = decoder.uint32();
                        obj.DatabaseDelete = events.DatabaseDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 56: {
                        const length = decoder.uint32();
                        obj.AppCreate = events.AppCreate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 57: {
                        const length = decoder.uint32();
                        obj.AppUpdate = events.AppUpdate.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 58: {
                        const length = decoder.uint32();
                        obj.AppDelete = events.AppDelete.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 59: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopSessionStart =
                            events.WindowsDesktopSessionStart.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }
                    case 60: {
                        const length = decoder.uint32();
                        obj.WindowsDesktopSessionEnd =
                            events.WindowsDesktopSessionEnd.decode(
                                new DataView(
                                    decoder.view.buffer,
                                    decoder.pos + decoder.view.byteOffset,
                                    length
                                )
                            );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode OneOf

        public size(): u32 {
            let size: u32 = 0;

            if (this.UserLogin != null) {
                const f: events.UserLogin = this.UserLogin as events.UserLogin;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserCreate != null) {
                const f: events.UserCreate = this
                    .UserCreate as events.UserCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserDelete != null) {
                const f: events.UserDelete = this
                    .UserDelete as events.UserDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserPasswordChange != null) {
                const f: events.UserPasswordChange = this
                    .UserPasswordChange as events.UserPasswordChange;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionStart != null) {
                const f: events.SessionStart = this
                    .SessionStart as events.SessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionJoin != null) {
                const f: events.SessionJoin = this
                    .SessionJoin as events.SessionJoin;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionPrint != null) {
                const f: events.SessionPrint = this
                    .SessionPrint as events.SessionPrint;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionReject != null) {
                const f: events.SessionReject = this
                    .SessionReject as events.SessionReject;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Resize != null) {
                const f: events.Resize = this.Resize as events.Resize;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionEnd != null) {
                const f: events.SessionEnd = this
                    .SessionEnd as events.SessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionCommand != null) {
                const f: events.SessionCommand = this
                    .SessionCommand as events.SessionCommand;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionDisk != null) {
                const f: events.SessionDisk = this
                    .SessionDisk as events.SessionDisk;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionNetwork != null) {
                const f: events.SessionNetwork = this
                    .SessionNetwork as events.SessionNetwork;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionData != null) {
                const f: events.SessionData = this
                    .SessionData as events.SessionData;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionLeave != null) {
                const f: events.SessionLeave = this
                    .SessionLeave as events.SessionLeave;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.PortForward != null) {
                const f: events.PortForward = this
                    .PortForward as events.PortForward;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.X11Forward != null) {
                const f: events.X11Forward = this
                    .X11Forward as events.X11Forward;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SCP != null) {
                const f: events.SCP = this.SCP as events.SCP;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Exec != null) {
                const f: events.Exec = this.Exec as events.Exec;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.Subsystem != null) {
                const f: events.Subsystem = this.Subsystem as events.Subsystem;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.ClientDisconnect != null) {
                const f: events.ClientDisconnect = this
                    .ClientDisconnect as events.ClientDisconnect;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AuthAttempt != null) {
                const f: events.AuthAttempt = this
                    .AuthAttempt as events.AuthAttempt;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AccessRequestCreate != null) {
                const f: events.AccessRequestCreate = this
                    .AccessRequestCreate as events.AccessRequestCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.UserTokenCreate != null) {
                const f: events.UserTokenCreate = this
                    .UserTokenCreate as events.UserTokenCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleCreate != null) {
                const f: events.RoleCreate = this
                    .RoleCreate as events.RoleCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RoleDelete != null) {
                const f: events.RoleDelete = this
                    .RoleDelete as events.RoleDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterCreate != null) {
                const f: events.TrustedClusterCreate = this
                    .TrustedClusterCreate as events.TrustedClusterCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterDelete != null) {
                const f: events.TrustedClusterDelete = this
                    .TrustedClusterDelete as events.TrustedClusterDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.TrustedClusterTokenCreate != null) {
                const f: events.TrustedClusterTokenCreate = this
                    .TrustedClusterTokenCreate as events.TrustedClusterTokenCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GithubConnectorCreate != null) {
                const f: events.GithubConnectorCreate = this
                    .GithubConnectorCreate as events.GithubConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.GithubConnectorDelete != null) {
                const f: events.GithubConnectorDelete = this
                    .GithubConnectorDelete as events.GithubConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.OIDCConnectorCreate != null) {
                const f: events.OIDCConnectorCreate = this
                    .OIDCConnectorCreate as events.OIDCConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.OIDCConnectorDelete != null) {
                const f: events.OIDCConnectorDelete = this
                    .OIDCConnectorDelete as events.OIDCConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SAMLConnectorCreate != null) {
                const f: events.SAMLConnectorCreate = this
                    .SAMLConnectorCreate as events.SAMLConnectorCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SAMLConnectorDelete != null) {
                const f: events.SAMLConnectorDelete = this
                    .SAMLConnectorDelete as events.SAMLConnectorDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.KubeRequest != null) {
                const f: events.KubeRequest = this
                    .KubeRequest as events.KubeRequest;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionStart != null) {
                const f: events.AppSessionStart = this
                    .AppSessionStart as events.AppSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionChunk != null) {
                const f: events.AppSessionChunk = this
                    .AppSessionChunk as events.AppSessionChunk;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppSessionRequest != null) {
                const f: events.AppSessionRequest = this
                    .AppSessionRequest as events.AppSessionRequest;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionStart != null) {
                const f: events.DatabaseSessionStart = this
                    .DatabaseSessionStart as events.DatabaseSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionEnd != null) {
                const f: events.DatabaseSessionEnd = this
                    .DatabaseSessionEnd as events.DatabaseSessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseSessionQuery != null) {
                const f: events.DatabaseSessionQuery = this
                    .DatabaseSessionQuery as events.DatabaseSessionQuery;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionUpload != null) {
                const f: events.SessionUpload = this
                    .SessionUpload as events.SessionUpload;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADeviceAdd != null) {
                const f: events.MFADeviceAdd = this
                    .MFADeviceAdd as events.MFADeviceAdd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.MFADeviceDelete != null) {
                const f: events.MFADeviceDelete = this
                    .MFADeviceDelete as events.MFADeviceDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingInformationUpdate != null) {
                const f: events.BillingInformationUpdate = this
                    .BillingInformationUpdate as events.BillingInformationUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingCardCreate != null) {
                const f: events.BillingCardCreate = this
                    .BillingCardCreate as events.BillingCardCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.BillingCardDelete != null) {
                const f: events.BillingCardDelete = this
                    .BillingCardDelete as events.BillingCardDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockCreate != null) {
                const f: events.LockCreate = this
                    .LockCreate as events.LockCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.LockDelete != null) {
                const f: events.LockDelete = this
                    .LockDelete as events.LockDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryCodeGenerate != null) {
                const f: events.RecoveryCodeGenerate = this
                    .RecoveryCodeGenerate as events.RecoveryCodeGenerate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.RecoveryCodeUsed != null) {
                const f: events.RecoveryCodeUsed = this
                    .RecoveryCodeUsed as events.RecoveryCodeUsed;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseCreate != null) {
                const f: events.DatabaseCreate = this
                    .DatabaseCreate as events.DatabaseCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseUpdate != null) {
                const f: events.DatabaseUpdate = this
                    .DatabaseUpdate as events.DatabaseUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.DatabaseDelete != null) {
                const f: events.DatabaseDelete = this
                    .DatabaseDelete as events.DatabaseDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppCreate != null) {
                const f: events.AppCreate = this.AppCreate as events.AppCreate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppUpdate != null) {
                const f: events.AppUpdate = this.AppUpdate as events.AppUpdate;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.AppDelete != null) {
                const f: events.AppDelete = this.AppDelete as events.AppDelete;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.WindowsDesktopSessionStart != null) {
                const f: events.WindowsDesktopSessionStart = this
                    .WindowsDesktopSessionStart as events.WindowsDesktopSessionStart;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.WindowsDesktopSessionEnd != null) {
                const f: events.WindowsDesktopSessionEnd = this
                    .WindowsDesktopSessionEnd as events.WindowsDesktopSessionEnd;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        2 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes OneOf to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes OneOf to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UserLogin != null) {
                const f = this.UserLogin as events.UserLogin;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UserCreate != null) {
                const f = this.UserCreate as events.UserCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UserDelete != null) {
                const f = this.UserDelete as events.UserDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UserPasswordChange != null) {
                const f = this.UserPasswordChange as events.UserPasswordChange;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x22);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionStart != null) {
                const f = this.SessionStart as events.SessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x2a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionJoin != null) {
                const f = this.SessionJoin as events.SessionJoin;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x32);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionPrint != null) {
                const f = this.SessionPrint as events.SessionPrint;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x3a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionReject != null) {
                const f = this.SessionReject as events.SessionReject;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x42);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Resize != null) {
                const f = this.Resize as events.Resize;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x4a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionEnd != null) {
                const f = this.SessionEnd as events.SessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x52);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionCommand != null) {
                const f = this.SessionCommand as events.SessionCommand;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x5a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionDisk != null) {
                const f = this.SessionDisk as events.SessionDisk;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x62);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionNetwork != null) {
                const f = this.SessionNetwork as events.SessionNetwork;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x6a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionData != null) {
                const f = this.SessionData as events.SessionData;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x72);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionLeave != null) {
                const f = this.SessionLeave as events.SessionLeave;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x7a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.PortForward != null) {
                const f = this.PortForward as events.PortForward;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x82);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.X11Forward != null) {
                const f = this.X11Forward as events.X11Forward;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x8a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SCP != null) {
                const f = this.SCP as events.SCP;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x92);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Exec != null) {
                const f = this.Exec as events.Exec;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x9a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.Subsystem != null) {
                const f = this.Subsystem as events.Subsystem;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.ClientDisconnect != null) {
                const f = this.ClientDisconnect as events.ClientDisconnect;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xaa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AuthAttempt != null) {
                const f = this.AuthAttempt as events.AuthAttempt;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xb2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AccessRequestCreate != null) {
                const f = this
                    .AccessRequestCreate as events.AccessRequestCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xba);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UserTokenCreate != null) {
                const f = this.UserTokenCreate as events.UserTokenCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xc2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RoleCreate != null) {
                const f = this.RoleCreate as events.RoleCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xca);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RoleDelete != null) {
                const f = this.RoleDelete as events.RoleDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xd2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.TrustedClusterCreate != null) {
                const f = this
                    .TrustedClusterCreate as events.TrustedClusterCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xda);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.TrustedClusterDelete != null) {
                const f = this
                    .TrustedClusterDelete as events.TrustedClusterDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xe2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.TrustedClusterTokenCreate != null) {
                const f = this
                    .TrustedClusterTokenCreate as events.TrustedClusterTokenCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xea);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.GithubConnectorCreate != null) {
                const f = this
                    .GithubConnectorCreate as events.GithubConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xf2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.GithubConnectorDelete != null) {
                const f = this
                    .GithubConnectorDelete as events.GithubConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xfa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.OIDCConnectorCreate != null) {
                const f = this
                    .OIDCConnectorCreate as events.OIDCConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x102);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.OIDCConnectorDelete != null) {
                const f = this
                    .OIDCConnectorDelete as events.OIDCConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x10a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SAMLConnectorCreate != null) {
                const f = this
                    .SAMLConnectorCreate as events.SAMLConnectorCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x112);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SAMLConnectorDelete != null) {
                const f = this
                    .SAMLConnectorDelete as events.SAMLConnectorDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x11a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.KubeRequest != null) {
                const f = this.KubeRequest as events.KubeRequest;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x122);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppSessionStart != null) {
                const f = this.AppSessionStart as events.AppSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppSessionChunk != null) {
                const f = this.AppSessionChunk as events.AppSessionChunk;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x132);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppSessionRequest != null) {
                const f = this.AppSessionRequest as events.AppSessionRequest;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x13a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseSessionStart != null) {
                const f = this
                    .DatabaseSessionStart as events.DatabaseSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x142);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseSessionEnd != null) {
                const f = this.DatabaseSessionEnd as events.DatabaseSessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x14a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseSessionQuery != null) {
                const f = this
                    .DatabaseSessionQuery as events.DatabaseSessionQuery;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x152);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionUpload != null) {
                const f = this.SessionUpload as events.SessionUpload;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x15a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.MFADeviceAdd != null) {
                const f = this.MFADeviceAdd as events.MFADeviceAdd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x162);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.MFADeviceDelete != null) {
                const f = this.MFADeviceDelete as events.MFADeviceDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x16a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BillingInformationUpdate != null) {
                const f = this
                    .BillingInformationUpdate as events.BillingInformationUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x172);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BillingCardCreate != null) {
                const f = this.BillingCardCreate as events.BillingCardCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x17a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.BillingCardDelete != null) {
                const f = this.BillingCardDelete as events.BillingCardDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x182);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.LockCreate != null) {
                const f = this.LockCreate as events.LockCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x18a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.LockDelete != null) {
                const f = this.LockDelete as events.LockDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x192);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RecoveryCodeGenerate != null) {
                const f = this
                    .RecoveryCodeGenerate as events.RecoveryCodeGenerate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x19a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.RecoveryCodeUsed != null) {
                const f = this.RecoveryCodeUsed as events.RecoveryCodeUsed;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseCreate != null) {
                const f = this.DatabaseCreate as events.DatabaseCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1aa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseUpdate != null) {
                const f = this.DatabaseUpdate as events.DatabaseUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1b2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.DatabaseDelete != null) {
                const f = this.DatabaseDelete as events.DatabaseDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1ba);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppCreate != null) {
                const f = this.AppCreate as events.AppCreate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1c2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppUpdate != null) {
                const f = this.AppUpdate as events.AppUpdate;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1ca);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.AppDelete != null) {
                const f = this.AppDelete as events.AppDelete;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1d2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.WindowsDesktopSessionStart != null) {
                const f = this
                    .WindowsDesktopSessionStart as events.WindowsDesktopSessionStart;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1da);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.WindowsDesktopSessionEnd != null) {
                const f = this
                    .WindowsDesktopSessionEnd as events.WindowsDesktopSessionEnd;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1e2);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode OneOf
    } // OneOf

    export class StreamStatus {
        public UploadID: string = "";
        public LastEventIndex: i64;
        public LastUploadTime: google.protobuf.Timestamp =
            new google.protobuf.Timestamp();

        // Decodes StreamStatus from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): StreamStatus {
            return StreamStatus.decode(new DataView(buf));
        }

        // Decodes StreamStatus from a DataView
        static decode(view: DataView): StreamStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new StreamStatus();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        obj.UploadID = decoder.string();
                        break;
                    }
                    case 2: {
                        obj.LastEventIndex = decoder.int64();
                        break;
                    }
                    case 3: {
                        const length = decoder.uint32();
                        obj.LastUploadTime = google.protobuf.Timestamp.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode StreamStatus

        public size(): u32 {
            let size: u32 = 0;

            size +=
                this.UploadID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UploadID.length) +
                      this.UploadID.length
                    : 0;
            size +=
                this.LastEventIndex == 0
                    ? 0
                    : 1 + __proto.Sizer.int64(this.LastEventIndex);

            if (this.LastUploadTime != null) {
                const f: google.protobuf.Timestamp = this
                    .LastUploadTime as google.protobuf.Timestamp;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            return size;
        }

        // Encodes StreamStatus to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes StreamStatus to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.UploadID.length > 0) {
                encoder.uint32(0xa);
                encoder.uint32(this.UploadID.length);
                encoder.string(this.UploadID);
            }
            if (this.LastEventIndex != 0) {
                encoder.uint32(0x10);
                encoder.int64(this.LastEventIndex);
            }

            if (this.LastUploadTime != null) {
                const f = this.LastUploadTime as google.protobuf.Timestamp;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x1a);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            return buf;
        } // encode StreamStatus
    } // StreamStatus

    export class SessionUpload {
        public Metadata: events.Metadata = new events.Metadata();
        public SessionMetadata: events.SessionMetadata =
            new events.SessionMetadata();
        public UID: string = "";
        public SessionURL: string = "";

        // Decodes SessionUpload from an ArrayBuffer
        static decodeArrayBuffer(buf: ArrayBuffer): SessionUpload {
            return SessionUpload.decode(new DataView(buf));
        }

        // Decodes SessionUpload from a DataView
        static decode(view: DataView): SessionUpload {
            const decoder = new __proto.Decoder(view);
            const obj = new SessionUpload();

            while (!decoder.eof()) {
                const tag = decoder.tag();
                const number = tag >>> 3;

                switch (number) {
                    case 1: {
                        const length = decoder.uint32();
                        obj.Metadata = events.Metadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 2: {
                        const length = decoder.uint32();
                        obj.SessionMetadata = events.SessionMetadata.decode(
                            new DataView(
                                decoder.view.buffer,
                                decoder.pos + decoder.view.byteOffset,
                                length
                            )
                        );
                        decoder.skip(length);

                        break;
                    }
                    case 4: {
                        obj.UID = decoder.string();
                        break;
                    }
                    case 5: {
                        obj.SessionURL = decoder.string();
                        break;
                    }

                    default:
                        decoder.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        } // decode SessionUpload

        public size(): u32 {
            let size: u32 = 0;

            if (this.Metadata != null) {
                const f: events.Metadata = this.Metadata as events.Metadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            if (this.SessionMetadata != null) {
                const f: events.SessionMetadata = this
                    .SessionMetadata as events.SessionMetadata;
                const messageSize = f.size();

                if (messageSize > 0) {
                    size +=
                        1 + __proto.Sizer.varint64(messageSize) + messageSize;
                }
            }

            size +=
                this.UID.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.UID.length) +
                      this.UID.length
                    : 0;
            size +=
                this.SessionURL.length > 0
                    ? 1 +
                      __proto.Sizer.varint64(this.SessionURL.length) +
                      this.SessionURL.length
                    : 0;

            return size;
        }

        // Encodes SessionUpload to the DataView
        encodeDataView(): DataView {
            const source = this.encode();
            const view = new DataView(new ArrayBuffer(source.length));
            for (let i: i32 = 0; i < source.length; i++) {
                view.setUint8(i, source.at(i));
            }
            return view;
        }

        // Encodes SessionUpload to the Array<u8>
        encode(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
            const buf = encoder.buf;

            if (this.Metadata != null) {
                const f = this.Metadata as events.Metadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0xa);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.SessionMetadata != null) {
                const f = this.SessionMetadata as events.SessionMetadata;

                const messageSize = f.size();

                if (messageSize > 0) {
                    encoder.uint32(0x12);
                    encoder.uint32(messageSize);
                    f.encode(encoder);
                }
            }

            if (this.UID.length > 0) {
                encoder.uint32(0x22);
                encoder.uint32(this.UID.length);
                encoder.string(this.UID);
            }
            if (this.SessionURL.length > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(this.SessionURL.length);
                encoder.string(this.SessionURL);
            }

            return buf;
        } // encode SessionUpload
    } // SessionUpload
} // events

// __decodeMap_string_google_protobuf_Value

function __decodeMap_string_google_protobuf_Value(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, google.protobuf.Value>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: google.protobuf.Value = new google.protobuf.Value();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = google.protobuf.Value.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as google.protobuf.Value);
}

// __sizeMapEntry_string_google_protobuf_Value

function __sizeMapEntry_string_google_protobuf_Value(
    key: string,
    value: google.protobuf.Value
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __size_string_repeated

function __size_string_repeated(value: Array<string>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;
    }

    return size;
}

// __decodeMap_string_wrappers_StringValues

function __decodeMap_string_wrappers_StringValues(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, wrappers.StringValues>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: wrappers.StringValues = new wrappers.StringValues();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = wrappers.StringValues.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as wrappers.StringValues);
}

// __sizeMapEntry_string_wrappers_StringValues

function __sizeMapEntry_string_wrappers_StringValues(
    key: string,
    value: wrappers.StringValues
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __decodeMap_string_string

function __decodeMap_string_string(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, string>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: string = "";

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                value = decoder.string();
                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as string);
}

// __sizeMapEntry_string_string

function __sizeMapEntry_string_string(key: string, value: string): u32 {
    return (
        (key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0) +
        (value.length > 0
            ? 1 + __proto.Sizer.varint64(value.length) + value.length
            : 0)
    );
}

// __decodeMap_string_types_CommandLabelV2

function __decodeMap_string_types_CommandLabelV2(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.CommandLabelV2>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.CommandLabelV2 = new types.CommandLabelV2();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.CommandLabelV2.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.CommandLabelV2);
}

// __sizeMapEntry_string_types_CommandLabelV2

function __sizeMapEntry_string_types_CommandLabelV2(
    key: string,
    value: types.CommandLabelV2
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __size_bytes_repeated

function __size_bytes_repeated(value: Array<Array<u8>>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;
    }

    return size;
}

// __size_uint32_repeated

function __size_uint32_repeated(value: Array<u32>): u32 {
    let size: u32 = 0;

    for (let n: i32 = 0; n < value.length; n++) {
        size += 1 + __proto.Sizer.uint32(value[n]);
    }

    return size;
}

// __decodeMap_string_types_ThresholdIndexSets

function __decodeMap_string_types_ThresholdIndexSets(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.ThresholdIndexSets>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.ThresholdIndexSets = new types.ThresholdIndexSets();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.ThresholdIndexSets.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.ThresholdIndexSets);
}

// __sizeMapEntry_string_types_ThresholdIndexSets

function __sizeMapEntry_string_types_ThresholdIndexSets(
    key: string,
    value: types.ThresholdIndexSets
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}

// __decodeMap_string_types_PluginDataEntry

function __decodeMap_string_types_PluginDataEntry(
    parentDecoder: __proto.Decoder,
    length: i32,
    map: Map<string, types.PluginDataEntry>
): void {
    const decoder = new __proto.Decoder(
        new DataView(
            parentDecoder.view.buffer,
            parentDecoder.pos + parentDecoder.view.byteOffset,
            length
        )
    );

    let key: string = "";
    let value: types.PluginDataEntry = new types.PluginDataEntry();

    while (!decoder.eof()) {
        const tag = decoder.tag();
        const number = tag >>> 3;

        switch (number) {
            case 1: {
                key = decoder.string();
                break;
            }

            case 2: {
                const length = decoder.uint32();
                value = types.PluginDataEntry.decode(
                    new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                    )
                );
                decoder.skip(length);

                break;
            }

            default:
                decoder.skipType(tag & 7);
                break;
        }
    }
    map.set(key as string, value as types.PluginDataEntry);
}

// __sizeMapEntry_string_types_PluginDataEntry

function __sizeMapEntry_string_types_PluginDataEntry(
    key: string,
    value: types.PluginDataEntry
): u32 {
    const keySize =
        key.length > 0
            ? 1 + __proto.Sizer.varint64(key.length) + key.length
            : 0;
    const valueSize = value.size();

    if (valueSize == 0) {
        return keySize;
    }

    return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;
}
